<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<title>3D Creator - Project History & Unmerge</title>

<!-- 1. CSS STYLES -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">

<style>
    body, html { margin: 0; padding: 0; overflow: hidden; height: 100%; background: #e0e0e0; font-family: 'Segoe UI', sans-serif; }
    /* FPS Counter Styling */
    #fps-display {
        position: absolute;
        top: 10px;
        left: 80px; /* Offset to not cover the toolbar */
        background: rgba(0, 0, 0, 0.7);
        color: #00ff00;
        font-family: monospace;
        font-size: 14px;
        font-weight: bold;
        padding: 4px 8px;
        border-radius: 4px;
        pointer-events: none; /* Let clicks pass through */
        z-index: 1000;
        display: none; /* Hidden by default */
    }
        /* Full Screen Editor */
    #designer-area {
        position: absolute; top: 0; left: 0;
        width: 100vw; height: 100vh;
        z-index: 1;
        background: radial-gradient(circle at center, #f0f0f0 0%, #d0d0d0 100%);
    }
    #designer-canvas { width: 100%; height: 100%; display: block; outline: none; }

    /* UI Panels (Floating) */
    .float-panel {
        position: absolute;
        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(5px);
        border: 1px solid rgba(0,0,0,0.1);
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        padding: 8px;
        z-index: 100;
        pointer-events: auto;
    }

    /* Toolbar (Left) */
    .float-toolbar { top: 20px; left: 20px; width: 50px; display: flex; flex-direction: column; gap: 6px; align-items: center; }

    /* Top Header */
    .float-header { top: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; padding: 8px 15px; align-items: center;}


    /* Object List (Bottom Right) - Fixed Layout */
    .float-list {
        bottom: 20px;
        right: 20px;
        width: 220px;

        /* Constraint: Never grow taller than 40% of screen */
        max-height: 40vh;
        height: auto;

        display: flex;
        flex-direction: column;
        overflow: hidden; /* Prevent outer scroll */
    }

    /* The Header (Objects label) */
    .float-list > .panel-header {
        flex-shrink: 0; /* Never squash header */
    }

    /* The Wrapper for List + Buttons */
    #content-list {
        display: flex;
        flex-direction: column;
        flex: 1;          /* Take up all remaining height */
        min-height: 0;    /* Critical Fix for Flexbox scrolling */
        padding-top: 5px;
    }

    /* The Scrollable List */
    #object-list {
        flex: 1;          /* Grow to fill space between header and buttons */
        overflow-y: auto; /* Scroll ONLY this area */
        margin-bottom: 10px; /* Space above buttons */
        border-bottom: 1px solid #ddd;
        list-style: none;
        padding: 0;
    }

    /* The Buttons */
    #content-list .btn-group {
        flex-shrink: 0;   /* Never squash buttons */
        width: 100%;
        margin-bottom: 5px;
    }
    /* Properties (Top Right) */
    .float-props { top: 20px; right: 20px; width: 240px; display: none; }

    /* Export Modal */
    .float-export { top: 50%; left: 50%; transform: translate(-50%, -50%); width: 300px; display: none; padding: 20px; }

    /* UI Elements */
    .btn-tool { width: 36px; height: 36px; padding: 0; display: flex; align-items: center; justify-content: center; border-radius: 6px; }
    .active-tool { background-color: #0d6efd !important; color: white !important; border-color: #0b5ed7 !important; }
    .divider { width: 80%; height: 1px; background: #ddd; margin: 2px 0; }

    /* Measurement Labels */
    .label-overlay { pointer-events: none; z-index: 50; font-family: sans-serif; overflow: hidden; }
    .tinker-label-container { pointer-events: auto; padding: 2px; }
    .tinker-input {
        pointer-events: auto; background: rgba(255, 255, 255, 0.95);
        border: 1px solid #0d6efd; border-radius: 4px; padding: 2px 0;
        font-size: 13px; font-weight: bold; color: #000; width: 55px;
        text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .dim-pos { color: #0d6efd; border-color: #0d6efd; }
    .dim-size { color: #212529; border-color: #6c757d; }
    .rot-label { background:rgba(0,0,0,0.8); color:#ffc107; padding:4px; border-radius:4px; font-weight:bold; font-size:12px; }

    /* List Items */
    .object-list-item { font-size: 0.85rem; padding: 8px; border-bottom: 1px solid #eee; cursor: pointer; display: flex; align-items: center; background:white; }
    .object-list-item:hover { background: #f8f9fa; }
    .object-list-item.selected { background: #e7f1ff; border-left: 3px solid #0d6efd; font-weight: 600; }

    .color-picker { display:flex; flex-wrap:wrap; gap:4px; margin-top: 5px; }
    .color-option { width:20px; height:20px; border-radius:3px; cursor:pointer; border:1px solid rgba(0,0,0,0.1); }
    .color-option.selected { border:2px solid #000; transform:scale(1.2); }
.cursor-cross { cursor: crosshair !important; }
.cursor-grab { cursor: grab !important; }
/* --- MOBILE & LANDSCAPE OPTIMIZATIONS --- */
    @media (max-width: 950px) {
        /* General Scaling for Touch */
        .btn-tool { width: 40px; height: 40px; } /* Larger touch targets */

        /* 1. TOP HEADER: Allow horizontal scroll if buttons overflow */
        .float-header {
            top: 10px;
            width: 90%;
            max-width: 100%;
            overflow-x: auto;
            white-space: nowrap;
            justify-content: flex-start;
            padding: 5px 10px;
            /* Hide Scrollbar */
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .float-header::-webkit-scrollbar { display: none; }

        /* 2. LEFT TOOLBAR: Scrollable & Collapsible */
        .float-toolbar {
            top: 60px; /* Push down below header */
            left: 10px;
            bottom: 10px; /* Stretch to bottom */
            height: auto;
            max-height: calc(100vh - 80px);
            overflow-y: auto; /* Enable Scroll */
            -webkit-overflow-scrolling: touch;
            transition: transform 0.3s ease;
        }

        /* 3. PROPERTIES PANEL: Scale Down & Reposition */
        .float-props {
            top: 60px;
            right: 10px;
            width: 200px; /* Slimmer */
            font-size: 0.8rem;
            max-height: 80vh;
            overflow-y: auto;
            transition: height 0.3s ease;
        }
        .float-props input, .float-props select { font-size: 0.8rem; }
        .float-props .row { --bs-gutter-x: 0.5rem; } /* Tighten grid */

        /* 4. OBJECT LIST: Minimize Logic */
        .float-list {
            bottom: 10px;
            right: 10px;
            width: 180px; /* Slimmer */
            max-height: 40vh; /* Don't cover too much vertical space */
            transition: height 0.3s ease;
        }
        /* When minimized class is added */
        .float-list.minimized {
            height: 40px !important; /* Header height only */
            overflow: hidden !important;
        }
        .float-list.minimized #object-list,
        .float-list.minimized .btn-group {
            display: none;
        }
        .float-props.minimized #content-props {
            display: none; /* Hide the innards */
        }
        /* --- PREVENT IPHONE TEXT SELECTION --- */
        #auto-save-status,
        #fps-display,
        .float-header,
        .float-list,
        .float-props,
        .float-toolbar {
            -webkit-touch-callout: none !important; /* Disable magnifying glass */
            -webkit-user-select: none !important;   /* Disable text selection */
            user-select: none !important;
        }

        /* Re-enable for inputs only */
        input {
            -webkit-user-select: text !important;
            user-select: text !important;
        }

        /* iPhone Safe Areas (Notch/Home Bar) */
        body {
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }
    }
</style>

<!-- 2. IMPORT MAP -->
<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
        "three-mesh-bvh": "https://unpkg.com/three-mesh-bvh@0.7.3/build/index.module.js",
        "three-bvh-csg": "https://unpkg.com/three-bvh-csg@0.0.16/build/index.module.js",
        "zstd-wasm": "https://unpkg.com/@bokuweb/zstd-wasm@0.0.27/dist/web/index.web.js",
        "three-rounded-box": "https://unpkg.com/three@0.160.0/examples/jsm/geometries/RoundedBoxGeometry.js",
        "three/addons/loaders/FontLoader.js": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/FontLoader.js",
        "three/addons/geometries/TextGeometry.js": "https://unpkg.com/three@0.160.0/examples/jsm/geometries/TextGeometry.js",
        "three/addons/loaders/MTLLoader.js": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/MTLLoader.js"
    }
}
</script>

<!-- 3. Polyfills -->
<script async src="https://ga.jspm.io/npm:es-module-shims@1.8.0/dist/es-module-shims.js"></script>
</head>
<body>

<div id="designer-area">
    <canvas id="designer-canvas"></canvas>
<div id="fps-display">FPS: 0</div>
    <!-- Auto Save Indicator -->
    <div id="auto-save-status" style="position:absolute; bottom:20px; left:50%; transform:translateX(-50%); color:white; background:rgba(0,0,0,0.6); padding:4px 12px; border-radius:20px; opacity:0; pointer-events:none; transition: opacity 0.5s; font-size: 0.8rem;">Saved</div>

    <!-- Header Controls -->
    <div class="float-panel float-header">
        <button class="btn btn-sm btn-outline-dark border-0" onclick="window.undo()" title="Undo (Ctrl+Z)">
            <i class="bi bi-arrow-counterclockwise"></i>
        </button>
        <button class="btn btn-sm btn-outline-dark border-0" onclick="window.redo()" title="Redo (Ctrl+Y)">
            <i class="bi bi-arrow-clockwise"></i>
        </button>

        <div style="border-left:1px solid #ccc; margin:0 5px; height:20px;"></div>

        <!-- Settings Button -->
        <button class="btn btn-sm btn-outline-dark border-0"
        onclick="document.getElementById('settings-panel').style.display='block'; window.updateStorageUI()"
        title="Settings">
            <i class="bi bi-gear"></i>
        </button>
        <div style="border-left:1px solid #ccc; margin:0 5px; height:20px;"></div>

        <button class="btn btn-sm btn-outline-dark border-0 fw-bold" onclick="document.getElementById('export-panel').style.display='block'">
            <i class="bi bi-download me-1"></i> Export
        </button>
        <div style="border-left:1px solid #ccc; margin:0 5px; height:20px;"></div>
        <button class="btn btn-sm btn-outline-danger border-0" onclick="if(confirm('Clear Scene?')) window.dDelAll()" title="Clear Scene">
            <i class="bi bi-trash"></i>
        </button>
<!-- RULER TOOLS -->
<div style="border-left:1px solid #ccc; margin:0 5px; height:20px;"></div>

<!-- 1. Toggle Ruler On/Off -->
<button id="btn-ruler" class="btn btn-sm btn-outline-dark border-0" onclick="window.toggleRuler()" title="Toggle Ruler (M)">
    <i class="bi bi-ruler"></i>
</button>

<!-- 2. Smart Snap Ruler (New) -->
<button id="btn-ruler-snap" class="btn btn-sm btn-outline-dark border-0" onclick="window.startRulerSnap()" title="Align Ruler to Object (Click Point, then Click Edge)">
    <i class="bi bi-magnet"></i>
</button>

<!-- 3. Reset Ruler -->
<button class="btn btn-sm btn-outline-dark border-0" onclick="window.resetRuler()" title="Reset Ruler to World Center">
    <i class="bi bi-arrow-counterclockwise"></i>
</button>
<button id="btn-ruler-mode" class="btn btn-sm btn-outline-dark border-0" onclick="window.toggleRulerMode()" title="Toggle Center/Endpoint">
    <i class="bi bi-arrows-collapse"></i>
</button>
        <div style="border-left:1px solid #ccc; margin:0 5px; height:20px;"></div>
    </div>

<!-- Toolbar (Left) -->
    <div class="float-panel float-toolbar" id="main-toolbar">
        <!-- New Mobile Toggle Icon -->
        <div class="d-md-none mb-2" onclick="window.toggleToolbar()" style="cursor:pointer">
            <i class="bi bi-three-dots-vertical"></i>
        </div>
        <div class="small fw-bold text-muted" style="font-size:0.6rem">ADD</div>
        <button class="btn btn-light border btn-tool" onclick="window.dAdd('cube')" title="Cube"><i class="bi bi-box"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.dAdd('cyl')" title="Cylinder"><i class="bi bi-database"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.dAdd('sph')" title="Sphere"><i class="bi bi-circle"></i></button>

        <button class="btn btn-light border btn-tool" onclick="window.dAdd('cone')" title="Cone / Pyramid"><i class="bi bi-cone-striped"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.dAdd('torus')" title="Torus (Donut)"><i class="bi bi-circle-half"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.dAdd('wedge')" title="Wedge / Ramp"><i class="bi bi-caret-up-fill"></i></button>
        <!-- NEW THREAD BUTTON -->
        <button class="btn btn-light border btn-tool" onclick="window.dAdd('thread')" title="Screw Thread (ISO/UNC)"><i class="bi bi-gear-wide-connected"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.dStartText()" title="3D Text"><i class="bi bi-type"></i></button>
        <div class="divider"></div>

        <div class="small fw-bold text-muted" style="font-size:0.6rem">EDIT</div>
        <button class="btn btn-light border btn-tool" onclick="window.setMode('translate')" data-mode="translate" title="Move"><i class="bi bi-arrows-move"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.setMode('rotate')" data-mode="rotate" title="Rotate"><i class="bi bi-arrow-repeat"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.setMode('scale')" data-mode="scale" title="Scale"><i class="bi bi-arrows-angle-expand"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.startAlignTool()" title="Snap Face to Face"><i class="bi bi-magnet"></i></button>
        <button class="btn btn-light border btn-tool" onclick="document.getElementById('mirror-panel').style.display='block'" title="Mirror / Flip"><i class="bi bi-symmetry-vertical"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.dExtrude()" title="Extrude / Push-Pull (E)"><i class="bi bi-box-arrow-up"></i></button>
        <div class="divider"></div>

        <div class="small fw-bold text-muted" style="font-size:0.6rem">ACT</div>
        <button class="btn btn-light border btn-tool" onclick="window.dDuplicate()" title="Duplicate"><i class="bi bi-files"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.dLoft()" title="Loft / Hull"><i class="bi bi-bezier2"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.dShell()" title="Hollow / Shell"><i class="bi bi-nut"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.dDrop()" title="Drop to Floor"><i class="bi bi-arrow-bar-down"></i></button>
        <!-- ADD THIS BUTTON -->
        <button class="btn btn-light border btn-tool" onclick="window.dVacuum()" title="Vacuum Mold (Create Mount Impression)"><i class="bi bi-cloud-download"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.dShrinkWrap()" title="Shrink Wrap / Snap to Surface"><i class="bi bi-bandaid"></i></button>
        <div class="divider"></div>

        <button class="btn btn-primary border btn-tool" onclick="document.getElementById('file-upload').click()" title="Import File"><i class="bi bi-upload"></i></button>
        <input type="file" id="file-upload" multiple accept=".stl,.obj,.mtl,.jpg,.png,.glb,.gltf,.usdz" style="display:none" onchange="window.dImportFile(this)">
    </div>

    <!-- Object List (Bottom Right) -->
    <div class="float-panel float-list" id="panel-list">
        <!-- Header: Added class 'panel-header' for CSS targeting -->
        <div class="d-flex justify-content-between align-items-center mb-1 border-bottom pb-1 panel-header"
            onclick="window.togglePanel('panel-list')" style="cursor:pointer">
            <span class="fw-bold small"><i class="bi bi-list-ul"></i> Objects</span>
            <i class="bi bi-chevron-down small" id="icon-panel-list"></i>
        </div>

        <!-- Content Container -->
        <div id="content-list">
            <!-- The List -->
            <ul id="object-list"></ul>

            <!-- The Buttons -->
            <div class="btn-group">
                <button class="btn btn-sm btn-warning" id="merge-btn" onclick="window.dMerge()">Merge (0)</button>
                <button class="btn btn-sm btn-outline-dark" id="unmerge-btn" onclick="window.dUnmerge()" style="display:none;">Unmerge</button>
                <button class="btn btn-sm btn-danger" onclick="window.dDel()">Delete</button>
            </div>
        </div>
    </div>

<!-- Properties (Top Right) -->
    <div class="float-panel float-props" id="prop-panel" style="overflow-y: auto; max-height: 70vh;">
        <!-- Header: Clicking this minimizes the panel but KEEPS selection -->
        <div class="d-flex justify-content-between border-bottom pb-1 mb-2"
             onclick="window.togglePanel('prop-panel')" style="cursor:pointer">
            <span class="fw-bold small">Properties</span>
            <div>
                <!-- Toggle Icon -->
                <i class="bi bi-chevron-down small me-2" id="icon-panel-props"></i>
                <!-- Deselect (X) Button -->
                <button class="btn-close btn-sm" onclick="event.stopPropagation(); window.selectObject(null)"></button>
            </div>
        </div>

        <!-- Inner Content (Hidden when minimized) -->
        <div id="content-props">
            <div class="mb-2">
                <input type="text" id="opt-obj-name" class="form-control form-control-sm mb-1" placeholder="Name" onchange="window.updateObjectName(this.value)">
                <div class="d-flex justify-content-between align-items-center">
                     <select id="opt-d-type" class="form-select form-select-sm w-50" onchange="window.dUpdMat(this.value)">
                        <option value="solid">Solid</option>
                        <option value="hole">Hole (Sub)</option>
                     </select>
                     <div class="color-picker" id="color-picker"></div>
                </div>
            </div>
            <!-- DYNAMIC SHAPE PARAMETERS -->
            <div id="shape-params" class="mb-2 pt-2 border-top" style="display:none; background:#f8f9fa; padding:5px; border-radius:4px;"></div>

            <div class="row g-1 mb-2">
                <label class="small text-muted col-12 mb-0">Size (mm)</label>
                <div class="col-4"><input type="number" id="opt-sz-x" class="form-control form-control-sm" placeholder="W" onchange="window.dSz()"></div>
                <div class="col-4"><input type="number" id="opt-sz-y" class="form-control form-control-sm" placeholder="L" onchange="window.dSz()"></div>
                <div class="col-4"><input type="number" id="opt-sz-z" class="form-control form-control-sm" placeholder="H" onchange="window.dSz()"></div>
            </div>
            <div class="row g-1">
                <label class="small text-muted col-12 mb-0">Rotation (Deg)</label>
                <div class="col-4"><input type="number" id="opt-rot-x" class="form-control form-control-sm" placeholder="X" onchange="window.dRot()"></div>
                <div class="col-4"><input type="number" id="opt-rot-y" class="form-control form-control-sm" placeholder="Y" onchange="window.dRot()"></div>
                <div class="col-4"><input type="number" id="opt-rot-z" class="form-control form-control-sm" placeholder="Z" onchange="window.dRot()"></div>
            </div>
        </div>
    </div>

    <!-- Export Panel -->
    <div class="float-panel float-export" id="export-panel">
        <div class="d-flex justify-content-between mb-3">
            <strong><i class="bi bi-box-seam"></i> Export Design</strong>
            <button class="btn-close" onclick="document.getElementById('export-panel').style.display='none'"></button>
        </div>
        <div class="mb-3">
            <label class="small fw-bold">File Name</label>
            <input id="d-name" class="form-control form-control-sm" placeholder="My Design">
        </div>
        <div class="mb-3">
            <label class="small fw-bold">Format</label>
            <select id="export-format" class="form-select form-select-sm">
                <!-- NEW PROJECT OPTION -->
                <option value="json" style="font-weight:bold; color:#0d6efd;">★ Project (Editable, With History)</option>
                <option value="stl">STL (3D Printing)</option>
                <option value="obj">OBJ (Standard)</option>
                <option value="gltf">GLTF (Web/Unity)</option>
                <option value="glb">GLB (Android AR)</option>
                <option value="usdz">USDZ (Apple AR)</option>
            </select>
        </div>
        <div class="d-grid gap-2">
            <button class="btn btn-primary" onclick="window.triggerExport()">
                <i class="bi bi-download"></i> Download File
            </button>
            <div class="divider my-1"></div>
             <!-- NEW IMPORT PROJECT BUTTON -->
            <button class="btn btn-sm btn-secondary" onclick="document.getElementById('project-upload').click()">
                <i class="bi bi-folder2-open"></i> Open Project File
            </button>
            <input type="file" id="project-upload" accept="*" style="display:none" onchange="window.loadProjectFile(this)">
        </div>
    </div>
    <!-- Mirror / Flip Panel -->
    <div class="float-panel float-export" id="mirror-panel" style="display:none; width: 250px;">
        <div class="d-flex justify-content-between mb-3 border-bottom pb-2">
            <strong><i class="bi bi-symmetry-vertical"></i> Mirror Object</strong>
            <button class="btn-close" onclick="document.getElementById('mirror-panel').style.display='none'"></button>
        </div>

        <div class="form-check mb-3">
            <input class="form-check-input" type="checkbox" id="mirror-copy">
            <label class="form-check-label small fw-bold">Duplicate (Keep Original)</label>
        </div>

        <div class="row g-2">
            <div class="col-4">
                <button class="btn btn-outline-primary w-100 btn-sm" onclick="window.dMirror('x')">
                    <span class="d-block fw-bold">X</span>
                    <i class="bi bi-arrow-left-right small"></i>
                </button>
            </div>
            <div class="col-4">
                <button class="btn btn-outline-primary w-100 btn-sm" onclick="window.dMirror('y')">
                    <span class="d-block fw-bold">Y</span>
                    <i class="bi bi-arrow-down-up small"></i>
                </button>
            </div>
            <div class="col-4">
                <button class="btn btn-outline-primary w-100 btn-sm" onclick="window.dMirror('z')">
                    <span class="d-block fw-bold">Z</span>
                    <i class="bi bi-arrow-down-up small" style="transform: rotate(90deg)"></i>
                </button>
            </div>
        </div>
        <div class="text-center mt-2">
            <small class="text-muted" style="font-size:0.7rem">Flips scale along axis</small>
        </div>
    </div>
    <!-- Settings Panel -->
    <div class="float-panel float-export" id="settings-panel" style="display:none; width: 320px;">
        <div class="d-flex justify-content-between mb-3 border-bottom pb-2">
            <strong><i class="bi bi-sliders"></i> Scene Settings</strong>
            <button class="btn-close" onclick="document.getElementById('settings-panel').style.display='none'"></button>
        </div>

        <!-- Lighting -->
        <div class="mb-3">
            <label class="small fw-bold text-muted">Lighting & Shadows</label>

            <div class="d-flex justify-content-between align-items-center mt-2">
                <span class="small">Shadow Darkness (Ambient)</span>
                <input type="range" class="form-range w-50" min="0" max="2" step="0.1" id="set-ambient" oninput="window.updateSettings('ambient', this.value)">
            </div>

            <div class="d-flex justify-content-between align-items-center">
                <span class="small">Sun Brightness</span>
                <input type="range" class="form-range w-50" min="0" max="3" step="0.1" id="set-direct" oninput="window.updateSettings('direct', this.value)">
            </div>
        </div>

<!-- Visuals -->
        <div class="mb-3">
            <label class="small fw-bold text-muted">Visual Style</label>

            <div class="form-check form-switch mt-2">
                <input class="form-check-input" type="checkbox" id="set-shadows" onchange="window.updateSettings('shadows', this.checked)">
                <label class="form-check-label small">Cast Shadows</label>
            </div>

            <!-- CINEMATIC TOGGLE -->
            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" id="set-cinematic" onchange="window.updateSettings('cinematic', this.checked)">
                <label class="form-check-label small" style="color:#0d6efd; font-weight:600;">✨ Studio View (Screenshot)</label>
            </div>

            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" id="set-grid" onchange="window.updateSettings('grid', this.checked)">
                <label class="form-check-label small">Show Grid</label>
            </div>

            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" id="set-wireframe" onchange="window.updateSettings('wireframe', this.checked)">
                <label class="form-check-label small">Wireframe Mode</label>
            </div>
        </div>
        <!-- Performance Settings -->
        <div class="mb-3">
            <label class="small fw-bold text-muted">Performance</label>
            <div class="d-flex justify-content-between align-items-center mt-2">
                <span class="small">Frame Rate Limit</span>
                <select id="set-fps" class="form-select form-select-sm w-50" onchange="window.updateSettings('fps', this.value)">
                    <option value="30">30 FPS (Save Battery)</option>
                    <option value="60">60 FPS (Standard)</option>
                    <option value="unlocked">Unlocked (Max)</option>
                </select>
            </div>
        </div>

        <div class="form-check form-switch mt-2">
            <input class="form-check-input" type="checkbox" id="set-show-fps" onchange="window.updateSettings('showFps', this.checked)">
            <label class="form-check-label small">Show FPS Counter</label>
        </div>

        <!-- NEW: Storage Meter -->
        <div class="mb-3 border-top pt-3">
            <label class="small fw-bold text-muted mb-1">Local Storage Usage</label>
            <div class="progress" style="height: 8px; background-color: #e9ecef;">
                <div id="storage-bar" class="progress-bar" role="progressbar" style="width: 0%"></div>
            </div>
            <div class="d-flex justify-content-between mt-1">
                <span id="storage-text" class="small text-muted" style="font-size: 0.75rem;">Calculating...</span>
                <span class="small text-muted" style="font-size: 0.75rem;">5.0 MB Limit</span>
            </div>
        </div>

        <div class="text-end">
            <button class="btn btn-sm btn-outline-secondary" onclick="window.resetSettings()">Reset Defaults</button>
        </div>
    </div>
</div>

<!-- 4. MAIN LOGIC -->
<script type="module">
import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { TransformControls } from "three/addons/controls/TransformControls.js";
    import { CSS2DRenderer, CSS2DObject } from "three/addons/renderers/CSS2DRenderer.js";
    import { ConvexGeometry } from "three/addons/geometries/ConvexGeometry.js";
    import { RoundedBoxGeometry } from "three-rounded-box"; // NEW IMPORT
    import { mergeVertices } from "three/addons/utils/BufferGeometryUtils.js";
    import { OBJExporter } from "three/addons/exporters/OBJExporter.js";
    import { STLExporter } from "three/addons/exporters/STLExporter.js";
    import { GLTFExporter } from "three/addons/exporters/GLTFExporter.js";
    import { USDZExporter } from "three/addons/exporters/USDZExporter.js";

    import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
    import { STLLoader } from "three/addons/loaders/STLLoader.js";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { USDZLoader } from "three/addons/loaders/USDZLoader.js";
    import { MTLLoader } from "three/addons/loaders/MTLLoader.js";

    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

    import { SUBTRACTION, ADDITION, Brush, Evaluator } from "three-bvh-csg";
    import { MeshBVH } from "three-mesh-bvh";

    // IMPORT ZSTD
    import { init as initZstd, compress, decompress } from "zstd-wasm";

    // --- GLOBALS ---
    let scene, cam, ren, labelRen, ctrl, tCtrl, ray;
    let selectedObjects = [];
    let liftCone, isLifting = false, liftStartMouseY = 0, liftStartObjZ = 0;
    let rotLabelDiv, rotLabelObj;
    let rulerGroup, rulerMode = 'endpoint';
    let schematicGroup;
    const activeLabels = [];
    const MESH_HIGHLIGHT_COLOR = 0xff0000;
    let isInteracting = false;
    let needsRender = true;
    let rulerRotState = 0; // 0=BottomLeft, 1=BottomRight, 2=TopRight, 3=TopLeft
    // Globals for Smart Ruler
    let rulerSnapState = 0; // 0=Idle, 1=Pick Origin, 2=Pick Axis
    let rulerGhost = null;
    let rulerOriginVec = new THREE.Vector3();
    let ghostRulerGroup, snapMarker, snapEdgeLine;


    // --- ALIGN / SNAP FACE TOOL ---
    let alignState = 'none'; // 'none', 'pick-source', 'pick-target'
    let alignSourceInfo = null;
    let alignGhost = null;
    const invisibleFloor = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // Z-up floor

    // Saving & History
    let saveTimeout;
    let zstdReady = false;
    let historyStack = [];
    let historyStep = -1;
    const MAX_HISTORY = 30;
    let isUndoRedoAction = false;
    let isStorageFull = false;
    // --- TEXT GLOBALS ---
    let loadedFont = null;
    let textPlaceMode = false;
    let textGhost = null;
    let shadowPlane;
        // --- NEW GLOBALS FOR SHELL ---
    let isShellSelectMode = false;
    let shellSelectedFaces = [];
    let shellMarkers = []; // Stores the visual green meshes


    let isExtrudeMode = false;
    let isExtrudeDragging = false;
    let extrudeState = -1; // -1=Off, 0=Select, 1=Height, 2=Taper
    let extrudeData = null; 

    
    // --- OPTIMIZATION GLOBALS ---
    let fpsInterval, now, then, elapsed;
    let isFpsLocked = false;
    let fpsFrames = 0;
    let fpsLastTime = 0;
    let frameId;

    let isFaceLoftMode = false;
    let selectedFacesData = [];
    let faceMarkerGroup;
    let showRuler = true; // Default off
    let toolbarExpanded = true;
    let ambientLight, dirLight, gridHelper; // References to update them
    let appSettings = {
        ambient: 0.8,
        direct: 1.0,
        shadows: true,
        grid: true,
        wireframe: false,
        fps: 'unlocked', // Default to unlocked
        showFps: false
    };
    // Load font immediately on startup
    const fLoader = new FontLoader();
    fLoader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json', (font) => {
        loadedFont = font;
        console.log("Font Loaded");
    });

// --- THREAD STANDARDS DATABASE ---
const THREAD_SPECS = {
    // Metric Coarse: name -> [MajorRadius(mm), Pitch(mm)]
    metric: {
        "M3":  [1.5, 0.5],
        "M4":  [2.0, 0.7],
        "M5":  [2.5, 0.8],
        "M6":  [3.0, 1.0],
        "M8":  [4.0, 1.25],
        "M10": [5.0, 1.5],
        "M12": [6.0, 1.75],
        "M16": [8.0, 2.0],
        "M20": [10.0, 2.5]
    },
    // Imperial (UNC): name -> [MajorRadius(mm approx), Pitch(mm approx)]
    imperial: {
        "#6-32":  [1.75, 0.794],
        "#8-32":  [2.08, 0.794],
        "#10-24": [2.4, 1.058],
        "1/4-20": [3.175, 1.27],
        "5/16-18": [3.97, 1.411],
        "3/8-16": [4.76, 1.588],
        "1/2-13": [6.35, 1.954]
    }
};

function generateThreadGeometry(params) {
    const radius = params.r; // Major radius
    const pitch = params.p;
    const len = params.h;
    const segments = 32; // Resolution per turn

    // Calculate iterations
    const totalAngle = (len / pitch) * Math.PI * 2;
    const steps = Math.ceil((len / pitch) * segments);

    // Thread Profile (ISO-ish triangular cut)
    // We create a "Tube" that modulates radius
    const positions = [];
    const indices = [];

    // We generate a "strip" of vertices spiraling up
    // innerR = Minor Diameter, outerR = Major Diameter
    // ISO threads: depth is approx 0.54 * pitch (simplified for 3D printing)
    const threadDepth = 0.6 * pitch;
    const innerR = radius - threadDepth;
    const outerR = radius;

    // We need 3 rings of vertices per step to define the "V" shape + the core cylinder
    // Ring 0: Bottom Valley (Inner Radius)
    // Ring 1: Peak (Outer Radius)
    // Ring 2: Top Valley (Inner Radius)

    for (let i = 0; i <= steps; i++) {
        const t = i / steps; // 0 to 1
        const angle = t * totalAngle;
        const zBase = t * len;

        const cos = Math.cos(angle);
        const sin = Math.sin(angle);

        // Define the V-shape relative to the current Z height
        // To make it a solid rod, we essentially just modulate the outer surface
        // But for a true thread, we need a specific profile.

        // Simplified approach for robust Boolean operations:
        // Create a central core cylinder (radius = innerR)
        // Add the spiral V-shape on top?
        // No, let's generate the surface directly.

        // Vertices for this slice:
        // 0: Center (for caps)
        positions.push(0, 0, zBase);

        // 1: Inner Radius (Core surface)
        positions.push(innerR * cos, innerR * sin, zBase);

        // 2: Outer Radius (Peak of thread) - Shifted Z by half pitch?
        // Actually, to make a continuous spiral, the peak trails the valley.
        // Let's use a Sine wave modulation on the radius for a smooth approximate thread
        // This is computationally cheaper and prints very well.

        // FORMULA: r = base + amp * (1 + cos(z/pitch * 2PI))
        // This creates a "Wavy" cylinder which acts as a thread.
        // For a sharp V-thread, we use a Triangle Wave.
    }

    // --- BETTER APPROACH: PARAMETRIC FUNCTION ---
    // Let's use the 'TubeGeometry' concept but manually push vertices for a sharp thread.

    const vertCountPerStep = 4; // Low, High, Low (next), Center

    const geom = new THREE.BufferGeometry();
    const posArray = [];
    const idxArray = [];

    // Helper to add vertex
    function addV(x, y, z) { posArray.push(x, y, z); }

    // We are going to build a ribbon.
    // Top of thread, Bottom of thread (root).

    for (let i = 0; i <= steps; i++) {
        const angle = (i / segments) * Math.PI * 2;
        const z = (i / segments) * pitch; // This is Z for ONE turn.

        // We accumulate total height via loops?
        // Actually, let's loop total steps across full length.
    }

    // --- FALLBACK TO ROBUST "STACKED" METHOD ---
    // Since custom geometry code is lengthy, let's use a clever hack:
    // Create a Cylinder.
    // Modify its vertex data to twist and bulge.

    // 1. Create High-Res Cylinder
    const radialSegs = 32;
    const heightSegs = Math.ceil(len / (pitch/4)); // High vertical resolution
    const geo = new THREE.CylinderGeometry(radius, radius, len, radialSegs, heightSegs, true); // Open ended
    const pos = geo.attributes.position;

    const Vector3 = THREE.Vector3;
    const v = new Vector3();

    for(let i=0; i < pos.count; i++){
        v.fromBufferAttribute(pos, i);

        // Convert to Cylindrical
        const r = Math.sqrt(v.x*v.x + v.y*v.y);
        let theta = Math.atan2(v.y, v.x);

        // Calculate "Phase" based on Z and Angle
        // We want the bulge to travel up.
        // zIndex relative to pitch
        // Note: Cylinder is centered on Y=0 usually, but we rotated it?
        // Let's assume standard Y-up cylinder from ThreeJS

        const zPos = v.y + (len/2); // 0 to len

        // The Spiral Equation
        // We want the radius to be maximum when z corresponds to the thread peak
        const threadPhase = (zPos / pitch) * (Math.PI * 2);

        // Combine with angle (spiral twist)
        // theta goes -PI to PI.
        const wave = Math.cos(threadPhase - theta);

        // Triangle Wave for sharp thread
        // acos(cos(x)) gives a triangle wave from 0 to PI
        const sharpWave = Math.acos(wave) / Math.PI; // 0 (valley) to 1 (peak)

        // Modulate Radius
        // sharpWave=1 -> Outer Radius. sharpWave=0 -> Inner Radius.
        const currentR = innerR + (sharpWave * (outerR - innerR));

        // Apply new radius
        const scale = currentR / r;
        pos.setXY(i, v.x * scale, v.z * scale); // CylinderGeometry uses X-Z for circle, Y for height?
        // Wait, default Cylinder is Y-up. Circle is X-Z.
        // pos.setX(i, v.x * scale);
        // pos.setZ(i, v.z * scale);
        // Correct logic below:
    }

    // RE-DO LOOP WITH CORRECT AXIS MAPPING
    // ThreeJS Cylinder: Y is Up. X/Z are circle.
    for(let i=0; i < pos.count; i++){
        const x = pos.getX(i);
        const y = pos.getY(i); // Height
        const z = pos.getZ(i);

        // Current Angle
        const theta = Math.atan2(z, x);

        // Z Height (normalize 0 to len)
        const h = y + (len/2);

        // Spiral Math
        const phase = (h / pitch) * (Math.PI * 2);

        // Triangle profile (0.0 to 1.0)
        // Adjust phase by theta creates the spiral
        const val = Math.acos(Math.cos(phase - theta)) / Math.PI;

        // Determine Radius
        const r = innerR + (val * threadDepth);

        // Apply back to X/Z
        const currentAngle = Math.atan2(z, x); // Re-calc or reuse theta
        pos.setX(i, Math.cos(currentAngle) * r);
        pos.setZ(i, Math.sin(currentAngle) * r);
    }

    geo.computeVertexNormals();

    // Close the caps manually (since we used open-ended cylinder to avoid distorting cap vertices)
    // We create simple flat circles for top/bottom and merge.

    const topCap = new THREE.CircleGeometry(innerR, radialSegs);
    topCap.rotateX(-Math.PI/2);
    topCap.translate(0, len/2, 0);

    const botCap = new THREE.CircleGeometry(innerR, radialSegs);
    botCap.rotateX(Math.PI/2);
    botCap.translate(0, -len/2, 0);

    // Use BufferGeometryUtils (imported as mergeVertices, but we need mergeGeometries)
    // Since we don't have mergeGeometries imported in the map, we use a manual approach
    // OR we just use closed cylinder and accept that the caps might look a bit swirled (usually fine for printing).

    // Let's retry with closed cylinder:
    const finalGeo = new THREE.CylinderGeometry(radius, radius, len, radialSegs, heightSegs, false);
    const p = finalGeo.attributes.position;

    for(let i=0; i < p.count; i++){
        const x = p.getX(i);
        const y = p.getY(i);
        const z = p.getZ(i);

        // Only modify side vertices, not caps.
        // Caps are located exactly at y = +/- len/2
        const isCap = Math.abs(Math.abs(y) - len/2) < 0.001;

        if(!isCap) {
             const theta = Math.atan2(z, x);
             const h = y + (len/2);
             const phase = (h / pitch) * (Math.PI * 2);
             const val = Math.acos(Math.cos(phase - theta)) / Math.PI;

             // Taper the ends of the thread so they don't snap off?
             // Optional, but helps printing. For now, straight cut.

             const r = innerR + (val * threadDepth);
             const currentAngle = Math.atan2(z, x);
             p.setX(i, Math.cos(currentAngle) * r);
             p.setZ(i, Math.sin(currentAngle) * r);
        } else {
             // For caps, we set them to the Minor diameter (innerR)
             // so they fit inside the hole if used as a bolt
             const currentR = Math.sqrt(x*x + z*z);
             if(currentR > 0.1) { // Don't squash center point
                 const scale = innerR / currentR;
                 p.setX(i, x * scale);
                 p.setZ(i, z * scale);
             }
        }
    }

    finalGeo.computeVertexNormals();

    // Rotate to Z-up to match app standard
    finalGeo.rotateX(Math.PI/2);

    return finalGeo;
}

    window.startAlignTool = () => {
        if (selectedObjects.length !== 1) {
            alert("Select 1 object to align.");
            return;
        }

        // 1. Enter Mode
        alignState = 'pick-source';
        document.body.style.cursor = 'crosshair';

        // UI Feedback
        const status = document.getElementById("auto-save-status");
        status.innerText = "Step 1: Click a FACE on the selected object";
        status.style.opacity = 1;

        // Highlight button
        document.querySelectorAll(".btn-tool").forEach(b => b.classList.remove("active-tool"));
        document.querySelector('button[onclick="window.startAlignTool()"]').classList.add("active-tool");
    };

// --- MOBILE UI LOGIC ---
    window.togglePanel = (id) => {
            // 1. Toggle class
            const el = document.getElementById(id);
            el.classList.toggle('minimized');

            // 2. Handle Icon Flipping
            // We look for an icon with ID "icon-" + panelID
            // e.g. "icon-panel-list" or "icon-panel-props"
            const icon = document.getElementById('icon-' + id);

            // Note: For properties panel, the ID is 'prop-panel', so icon is 'icon-panel-props'
            // Let's normalize it.
            let targetIcon = icon;
            if(id === 'prop-panel') targetIcon = document.getElementById('icon-panel-props');
            if(id === 'panel-list') targetIcon = document.getElementById('icon-panel-list');

            if(targetIcon) {
                if(el.classList.contains('minimized')) {
                    targetIcon.classList.remove('bi-chevron-down');
                    targetIcon.classList.add('bi-chevron-up');
                } else {
                    targetIcon.classList.remove('bi-chevron-up');
                    targetIcon.classList.add('bi-chevron-down');
                }
            }
        };


    window.toggleToolbar = () => {
        toolbarExpanded = !toolbarExpanded;
        const bar = document.getElementById('main-toolbar');
        if(toolbarExpanded) {
            bar.style.height = 'auto';
            bar.style.overflowY = 'auto';
        } else {
            bar.style.height = '50px'; // Just enough to show the dots
            bar.style.overflowY = 'hidden';
        }
    };
    function handleAlignHover(ray, mouse) {
        // STEP 2: MOVING THE GHOST
        if (alignState === 'pick-target' && alignGhost) {
            // Raycast against everything EXCEPT the ghost and the source object
            const targets = scene.children.filter(o =>
                o.isMesh &&
                o !== alignGhost &&
                o !== selectedObjects[0] &&
                !o.userData.isRuler &&
                o !== liftCone
            );

            const intersects = ray.intersectObjects(targets, false);
            let targetPoint = null;
            let targetNormal = null;

            // Did we hit an object?
            if (intersects.length > 0) {
                targetPoint = intersects[0].point;
                // Transform normal to world space
                targetNormal = intersects[0].face.normal.clone().applyQuaternion(intersects[0].object.quaternion).normalize();
            } else {
                // Did we hit the floor?
                const target = new THREE.Vector3();
                const hit = ray.ray.intersectPlane(invisibleFloor, target);
                if (hit) {
                    targetPoint = target;
                    targetNormal = new THREE.Vector3(0, 0, 1); // Floor points up
                }
            }

            if (targetPoint && targetNormal) {
                alignGhost.visible = true;

                // MATH: Align Source Normal to NEGATIVE Target Normal (faces touching)
                // 1. Calculate rotation needed to turn World Up (0,1,0) or Object Up into Target direction?
                // Actually, simpler: Rotate 'alignSourceInfo.normal' to '-targetNormal'

                // Get the quaternion that rotates the Source Normal to match the Target Normal (inverted)
                const alignQuat = new THREE.Quaternion().setFromUnitVectors(alignSourceInfo.normal, targetNormal.clone().negate());

                // Apply this rotation to the object's original rotation
                const targetRotation = alignQuat.clone().multiply(selectedObjects[0].quaternion);
                alignGhost.quaternion.copy(targetRotation);

                // POSITIONING:
                // We need the point on the ghost that corresponds to the clicked source point
                // to match the target hit point.

                // 1. Get the vector from Object Center to Source Click Point (Rotated by new orientation)
                const offsetVec = alignSourceInfo.localPoint.clone().applyQuaternion(alignGhost.quaternion);

                // 2. Subtract that offset from the target point to place center correctly
                alignGhost.position.copy(targetPoint).sub(offsetVec);
            } else {
                alignGhost.visible = false;
            }
        }
    }

function handleAlignClick(ray) {
        if (alignState === 'pick-source') {
            // User clicking their own object to pick the face
            const intersects = ray.intersectObject(selectedObjects[0], false);
            if (intersects.length > 0) {
                const hit = intersects[0];

                // Store World Normal of the face
                const worldNormal = hit.face.normal.clone().applyQuaternion(hit.object.quaternion).normalize();

                // Store the point clicked relative to the center
                const localPoint = hit.point.clone().sub(hit.object.position).applyQuaternion(hit.object.quaternion.clone().invert());

                alignSourceInfo = {
                    normal: worldNormal,
                    localPoint: localPoint
                };

                // Create Ghost
                const original = selectedObjects[0];
                alignGhost = original.clone();
                alignGhost.material = new THREE.MeshBasicMaterial({
                    color: 0x0d6efd,
                    transparent: true,
                    opacity: 0.5,
                    wireframe: true
                });
                alignGhost.userData = { isGhost: true };
                scene.add(alignGhost);

                // Hide real object temporarily
                original.visible = false;

                // Next Step
                alignState = 'pick-target';
                const status = document.getElementById("auto-save-status");
                status.innerText = "Step 2: Click anywhere to place";
            }
            return true; // Stop other click events
        }

        if (alignState === 'pick-target') {
            // --- CRITICAL FIX FOR MOBILE ---
            // On touch, we didn't "hover" first, so the ghost doesn't know where to go.
            // We FORCE the calculation right now using the click ray.
            handleAlignHover(ray, null);
            // -------------------------------

            if (alignGhost && alignGhost.visible) {
                // APPLY TRANSFORM
                const obj = selectedObjects[0];
                obj.position.copy(alignGhost.position);
                obj.quaternion.copy(alignGhost.quaternion);
                obj.visible = true;
                obj.updateMatrixWorld();

                // Cleanup
                scene.remove(alignGhost);
                alignGhost = null;
                alignState = 'none';
                alignSourceInfo = null;
                document.body.style.cursor = 'default';

                // Reset UI
                document.querySelectorAll(".btn-tool").forEach(b => b.classList.remove("active-tool"));
                window.setMode('translate');

                const status = document.getElementById("auto-save-status");
                status.innerText = "Aligned";
                setTimeout(() => status.style.opacity = 0, 1000);

                updateTinkerLabels();
                updatePropertiesPanel();
                saveState();
                window.requestRender();
            }
            return true;
        }

        return false;
    }






















    // --- UTILS ---
    function prepareCSG(geometry) {
        if (!geometry) return null;
        const geo = geometry.clone();
        if (geo.attributes.color) geo.deleteAttribute('color');
        if (!geo.attributes.normal) geo.computeVertexNormals();
        if (!geo.attributes.uv) {
            const count = geo.attributes.position.count;
            geo.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(count * 2), 2));
        }
        return geo;
    }

    // Binary <-> Base64 helpers
    function uint8ToBase64(u8Arr) {
        const CHUNK_SIZE = 0x8000;
        let index = 0;
        let length = u8Arr.length;
        let result = '';
        while (index < length) {
            const slice = u8Arr.subarray(index, Math.min(index + CHUNK_SIZE, length));
            result += String.fromCharCode.apply(null, slice);
            index += CHUNK_SIZE;
        }
        return btoa(result);
    }

    function base64ToUint8(b64) {
        const binStr = atob(b64);
        const len = binStr.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binStr.charCodeAt(i);
        }
        return bytes;
    }

    // --- INIT ---
// --- GLOBAL VARIABLE FOR SHADOW PLANE ---


// Global reference for the shadow floor


    async function init3D() {
        // Init ZSTD
        try {
            await initZstd('https://unpkg.com/@bokuweb/zstd-wasm@0.0.27/dist/web/zstd.wasm');
            zstdReady = true;
            console.log("Zstd Compression Ready");
        } catch(e) {
            console.warn("Zstd failed to load, saving will be uncompressed", e);
        }

        // --- 1. FONT LOADING (Must happen before LoadFromStorage) ---
        const fLoader = new FontLoader();
        fLoader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json', (font) => {
            loadedFont = font;
            console.log("Font Loaded - Starting App");

            // This is the stable loading point
            loadFromStorage();
        });

        const canvas = document.getElementById("designer-canvas");
        const container = document.getElementById("designer-area");

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xd0d0d0);

        // --- 2. LIGHTING & SHADOWS ---
        ambientLight = new THREE.HemisphereLight(0xffffff, 0x444444, appSettings.ambient);
        scene.add(ambientLight);

        dirLight = new THREE.DirectionalLight(0xffffff, appSettings.direct);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;

        // --- CRITICAL FIX: EXPAND SHADOW COVERAGE ---
        const d = 200; // Cover a 400x400 area (200 in each direction)
        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;

        // Increase depth so it reaches the floor from height 100
        dirLight.shadow.camera.far = 500;

        // Resolution (Keep high for this large area)
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;

        // Artifact cleanup
        dirLight.shadow.bias = -0.0005;
        dirLight.shadow.normalBias = 0.02;
        scene.add(dirLight);

        // --- 3. SHADOW FLOOR PLANE ---
        // Invisible plane that only catches shadows
        const planeGeo = new THREE.PlaneGeometry(1000, 1000);
        const planeMat = new THREE.ShadowMaterial({ opacity: 0.2, color: 0x000000 });
        shadowPlane = new THREE.Mesh(planeGeo, planeMat);
        shadowPlane.position.z = -0.1; // Slightly below zero to avoid Z-fighting
        shadowPlane.receiveShadow = true;
        shadowPlane.userData = { isRuler: true }; // Prevent selection
        scene.add(shadowPlane);

        // --- 4. RENDERER SETUP ---
        ren = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
        ren.setPixelRatio(window.devicePixelRatio);
        ren.setSize(window.innerWidth, window.innerHeight);

        // Soft Shadows
        ren.shadowMap.enabled = true;
        ren.shadowMap.type = THREE.PCFSoftShadowMap;

        cam = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 5000);
        cam.position.set(60, -60, 60);
        cam.up.set(0, 0, 1);
        cam.lookAt(0, 0, 0);

        labelRen = new CSS2DRenderer();
        labelRen.setSize(window.innerWidth, window.innerHeight);
        labelRen.domElement.style.position = 'absolute';
        labelRen.domElement.style.top = '0px';
        labelRen.domElement.className = 'label-overlay';
        container.appendChild(labelRen.domElement);

        ctrl = new OrbitControls(cam, ren.domElement);
        ctrl.enableDamping = true;

        // Performance: Low Res during drag
        ctrl.addEventListener('start', () => { ren.setPixelRatio(1); });
        ctrl.addEventListener('end', () => { ren.setPixelRatio(window.devicePixelRatio); });

        tCtrl = new TransformControls(cam, ren.domElement);
        tCtrl.addEventListener("dragging-changed", e => { ctrl.enabled = !e.value });
        tCtrl.addEventListener("change", () => {
            updateTinkerLabels();
            updateLiftConePos();
            updateRotationFeedback();
            updatePropertiesPanel();
        });
        tCtrl.addEventListener("mouseUp", () => { saveState(); });
        scene.add(tCtrl);

        // Grid
        gridHelper = new THREE.GridHelper(200, 20);
        gridHelper.rotateX(Math.PI / 2);
        gridHelper.material.opacity = 0.4;
        gridHelper.material.transparent = true;
        scene.add(gridHelper);

        ray = new THREE.Raycaster();
        createLiftCone(); createRotationLabel(); createRuler();

        schematicGroup = new THREE.Group(); scene.add(schematicGroup);
        faceMarkerGroup = new THREE.Group(); scene.add(faceMarkerGroup);

        ren.domElement.addEventListener("pointerdown", onPointerDown);
        ren.domElement.addEventListener("pointermove", onPointerMove);
        ren.domElement.addEventListener("pointerup", onPointerUp);
        window.addEventListener('resize', onWindowResize);

        window.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); window.undo(); }
            if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); window.redo(); }
        });

        document.querySelectorAll('.float-panel').forEach(panel => {
            panel.addEventListener('pointerdown', e => e.stopPropagation());
            panel.addEventListener('mousedown', e => e.stopPropagation());
            panel.addEventListener('touchstart', e => e.stopPropagation());
        });

        then = window.performance.now();
        fpsLastTime = then;

        // Loop
        window.requestRender = () => { needsRender = true; };
        ctrl.addEventListener('change', () => { needsRender = true; });
        tCtrl.addEventListener('change', () => { needsRender = true; });
        document.addEventListener('pointerdown', () => { isInteracting = true; needsRender = true; });
        document.addEventListener('pointerup', () => { isInteracting = false; });

        function dLoop(newTime) {
            requestAnimationFrame(dLoop);
            ctrl.update();
            if (isFpsLocked) {
                now = newTime;
                elapsed = now - then;
                if (elapsed < fpsInterval) return;
                then = now - (elapsed % fpsInterval);
            }
            if (needsRender || isInteracting) {
                ren.render(scene, cam);
                labelRen.render(scene, cam);
                if (appSettings.showFps) {
                    fpsFrames++;
                    if (newTime >= fpsLastTime + 1000) {
                        const delta = newTime - fpsLastTime;
                        const fps = Math.round((fpsFrames * 1000) / delta);
                        const div = document.getElementById('fps-display');
                        if (div) div.innerText = `FPS: ${fps}`;
                        fpsLastTime = newTime;
                        fpsFrames = 0;
                    }
                }
                needsRender = false;
            }
        }
        dLoop();

        buildColorPicker();
        window.setMode("translate");

        // Data loading triggered in font loader callback above
    }

window.updateSettings = (key, value) => {
    // 1. Update State
    if (key === 'ambient' || key === 'direct') value = parseFloat(value);
    appSettings[key] = value;

    // 2. Standard Lighting
    if (key === 'ambient' && ambientLight) ambientLight.intensity = value;
    if (key === 'direct' && dirLight) dirLight.intensity = value;

    // 3. SHADOWS TOGGLE (Fixes the "Floor" issue)
    if (key === 'shadows') {
        if (dirLight) dirLight.castShadow = value;

        // Hide/Show the floor plane
        if (shadowPlane) shadowPlane.visible = value;

        // Update objects so they stop calculating shadows (Performance)
        scene.traverse(child => {
            if (child.isMesh && !child.userData.isRuler && child !== liftCone && child !== shadowPlane) {
                child.castShadow = value;
                child.receiveShadow = value;
            }
        });
        window.requestRender();
    }

    // 4. CINEMATIC MODE (Simple Version)
    if (key === 'cinematic') {
        if (value) {
            // Mode ON: White BG, Hide Grid
            scene.background = new THREE.Color(0xffffff); // Pure White
            if(gridHelper) gridHelper.visible = false;
            if(rulerGroup) rulerGroup.visible = false;
            if(shadowPlane) shadowPlane.material.opacity = 0.1; // Fainter shadows for white BG
        } else {
            // Mode OFF: Grey BG, Show Grid
            scene.background = new THREE.Color(0xd0d0d0); // Standard Grey
            if(gridHelper) gridHelper.visible = appSettings.grid; // Respect grid setting
            if(rulerGroup) rulerGroup.visible = showRuler;
            if(shadowPlane) shadowPlane.material.opacity = 0.2; // Standard shadow opacity
        }
        window.requestRender();
    }

    // 5. Grid Toggle
    if (key === 'grid' && !appSettings.cinematic) {
        if (gridHelper) gridHelper.visible = value;
    }

    // 6. Wireframe
    if (key === 'wireframe') {
        scene.traverse(child => {
            if (child.isMesh && !child.userData.isRuler && child !== liftCone && child.parent !== faceMarkerGroup && child !== shadowPlane) {
                if (child.material) child.material.wireframe = value;
            }
        });
    }

    // FPS Settings
    if (key === 'fps') {
        if (value === 'unlocked') {
            isFpsLocked = false;
        } else {
            isFpsLocked = true;
            fpsInterval = 1000 / parseInt(value);
            then = window.performance.now();
        }
    }
    if (key === 'showFps') {
        const div = document.getElementById('fps-display');
        if (div) div.style.display = value ? 'block' : 'none';
        fpsFrames = 0;
        fpsLastTime = performance.now();
    }

    localStorage.setItem('3d_app_settings', JSON.stringify(appSettings));
    window.requestRender();
};

window.updateStorageUI = () => {
        const bar = document.getElementById('storage-bar');
        const txt = document.getElementById('storage-text');
        if(!bar || !txt) return;

        // If explicitly flagged as full
        if (isStorageFull) {
            bar.style.width = "100%";
            bar.className = 'progress-bar bg-danger';
            txt.innerText = "STORAGE FULL (Limit Reached)";
            return;
        }

        // Standard Calculation
        let total = 0;
        for (let x in localStorage) {
            if (localStorage.hasOwnProperty(x)) {
                total += localStorage[x].length;
            }
        }

        const max = 5 * 1024 * 1024;
        const pct = Math.min((total / max) * 100, 100);

        const usedKB = (total / 1024).toFixed(2);
        const usedMB = (total / (1024 * 1024)).toFixed(2);
        const displayTxt = total > 1024 * 1024 ? `${usedMB} MB` : `${usedKB} KB`;

        bar.style.width = `${pct}%`;
        txt.innerText = `${displayTxt} Used`;

        bar.className = 'progress-bar';
        if(pct < 50) bar.classList.add('bg-success');
        else if(pct < 90) bar.classList.add('bg-warning');
        else bar.classList.add('bg-danger');
    };

    function loadSettings() {
        const saved = localStorage.getItem('3d_app_settings');
        if (saved) {
            try {
                const parsed = JSON.parse(saved);
                appSettings = { ...appSettings, ...parsed };
            } catch (e) { console.warn("Settings corrupted"); }
        }

        // Apply UI values
        document.getElementById('set-ambient').value = appSettings.ambient;
        document.getElementById('set-direct').value = appSettings.direct;
        document.getElementById('set-shadows').checked = appSettings.shadows;
        document.getElementById('set-grid').checked = appSettings.grid;
        document.getElementById('set-wireframe').checked = appSettings.wireframe;

        // Apply FPS UI
        const fpsSelect = document.getElementById('set-fps');
        if(fpsSelect) fpsSelect.value = appSettings.fps;
        // Apply UI for FPS Toggle
        const fpsToggle = document.getElementById('set-show-fps');
        if(fpsToggle) fpsToggle.checked = appSettings.showFps;

        // Apply to Scene
        if(ambientLight) ambientLight.intensity = appSettings.ambient;
        if(dirLight) {
            dirLight.intensity = appSettings.direct;
            dirLight.castShadow = appSettings.shadows;
        }
        if(gridHelper) gridHelper.visible = appSettings.grid;

        // Trigger FPS setup
        window.updateSettings('fps', appSettings.fps);
        // Trigger update to set visibility
        window.updateSettings('showFps', appSettings.showFps);
        setTimeout(() => {
            window.updateSettings('wireframe', appSettings.wireframe);
        }, 100);
    }

    window.resetSettings = () => {
        appSettings = { ambient: 0.8, direct: 1.0, shadows: true, grid: true, wireframe: false };
        localStorage.removeItem('3d_app_settings');
        loadSettings(); // Reloads UI and Scene
    };
    function onWindowResize() {
        cam.aspect = window.innerWidth / window.innerHeight;
        cam.updateProjectionMatrix();
        ren.setSize(window.innerWidth, window.innerHeight);
        if(labelRen) labelRen.setSize(window.innerWidth, window.innerHeight);
    }

    // --- DIMENSION LABELS ---
    function addDimensionLines(start, end, offset, color = 0x000000) {
        // Material for the faint extension lines
        const extMaterial = new THREE.LineBasicMaterial({ color: 0x888888, linewidth: 1, opacity: 0.4, transparent: true });
        // Material for the main dimension line
        const connMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: 2, depthTest: false, depthWrite: false });

        // Calculate start/end points with the offset applied
        const offS = start.clone().add(offset);
        const offE = end.clone().add(offset);

        // Draw Extension Lines (From object to measurement point)
        schematicGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([start, offS]), extMaterial));
        schematicGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([end, offE]), extMaterial));

        // Draw Connector Line (The main line between measurements)
        const connLine = new THREE.Line(new THREE.BufferGeometry().setFromPoints([offS, offE]), connMaterial);
        connLine.renderOrder = 999;
        schematicGroup.add(connLine);

        // Return the midpoint (where the text label goes)
        return offS.clone().lerp(offE, 0.5);
    }

    function createInputLabel(pos, value, type, callback) {
        const div = document.createElement('div');
        div.className = 'tinker-label-container';
        const input = document.createElement('input');
        input.type = 'text';
        input.className = `tinker-input ${type === 'size' ? 'dim-size' : 'dim-pos'}`;
        const displayVal = Math.round(value * 10) / 10;
        input.value = displayVal;
        input.setAttribute('value', displayVal);
        input.addEventListener('pointerdown', e => e.stopPropagation());
        input.addEventListener('mousedown', e => e.stopPropagation());
        input.addEventListener('keydown', e => { if(e.key === 'Enter') input.blur(); });
        input.addEventListener('change', () => {
            const val = parseFloat(input.value);
            if(!isNaN(val)) { callback(val); saveState(); }
        });
        div.appendChild(input);
        const label = new CSS2DObject(div);
        label.position.copy(pos);
        scene.add(label);
        activeLabels.push(label);
        return label;
    }
window.rotateRuler = () => {
        if(!rulerGroup || !showRuler) return;

        // Cycle state: 0 -> 1 -> 2 -> 3 -> 0
        rulerRotState = (rulerRotState + 1) % 4;

        // Apply visual rotation (Steps of 90 degrees)
        // -PI/2 is used because Three.js rotation direction vs logical quadrant
        rulerGroup.rotation.z = -(rulerRotState * (Math.PI / 2));

        updateTinkerLabels();
        window.requestRender();
        saveState();
    };

function updateTinkerLabels() {
        // 1. Cleanup Old Labels
        activeLabels.forEach(l => scene.remove(l));
        activeLabels.length = 0;
        while(schematicGroup.children.length > 0){ schematicGroup.remove(schematicGroup.children[0]); }

        // 2. Validate Selection
        if(selectedObjects.length !== 1 || isFaceLoftMode) return;
        const obj = selectedObjects[0];
        if(obj.userData.isRuler) return;

        const box = new THREE.Box3().setFromObject(obj);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());

        // ============================================
        // PART A: OBJECT SIZE (Always On - Gray/Black)
        // ============================================
        // Width (X Size)
        const sizeXPos = addDimensionLines(
            new THREE.Vector3(box.min.x, box.max.y, box.min.z),
            new THREE.Vector3(box.max.x, box.max.y, box.min.z),
            new THREE.Vector3(0, 5, 0), 0x444444
        );
        createInputLabel(sizeXPos, size.x, 'size', (v) => resizeObject(obj, 'x', v));

        // Length (Y Size)
        const sizeYPos = addDimensionLines(
            new THREE.Vector3(box.min.x, box.min.y, box.min.z),
            new THREE.Vector3(box.min.x, box.max.y, box.min.z),
            new THREE.Vector3(-5, 0, 0), 0x444444
        );
        createInputLabel(sizeYPos, size.y, 'size', (v) => resizeObject(obj, 'y', v));

        // Height (Z Size)
        const sizeZPos = addDimensionLines(
            new THREE.Vector3(box.max.x, box.min.y, box.min.z),
            new THREE.Vector3(box.max.x, box.min.y, box.max.z),
            new THREE.Vector3(10, 0, 0), 0x444444
        );
        createInputLabel(sizeZPos, size.z, 'size', (v) => resizeObject(obj, 'z', v));


        // ============================================
        // PART B: RULER RELATIVE (Toggle - Blue)
        // ============================================
        if (showRuler && rulerGroup) {
            const rPos = rulerGroup.position;

            // Define Measurement Targets based on Rotation State
            // State 0: Ruler is Bottom-Left (Measure to MinX, MinY)
            // State 1: Ruler is Bottom-Right (Measure to MaxX, MinY)
            // State 2: Ruler is Top-Right (Measure to MaxX, MaxY)
            // State 3: Ruler is Top-Left (Measure to MinX, MaxY)

            let targetX = box.min.x;
            let targetY = box.min.y;

            // Offset logic for where to draw the text (so it doesn't overlap object)
            let labelOffsetX = new THREE.Vector3(0, -25, 0); // Default below
            let labelOffsetY = new THREE.Vector3(-25, 0, 0); // Default left

            if(rulerMode === 'midpoint') {
                targetX = center.x;
                targetY = center.y;
            } else {
                if(rulerRotState === 1 || rulerRotState === 2) targetX = box.max.x;
                if(rulerRotState === 2 || rulerRotState === 3) targetY = box.max.y;
            }

            // Flip Label Positions based on state
            if(rulerRotState === 2 || rulerRotState === 3) labelOffsetX = new THREE.Vector3(0, 25, 0); // Draw Above
            if(rulerRotState === 1 || rulerRotState === 2) labelOffsetY = new THREE.Vector3(25, 0, 0);  // Draw Right

            // --- 1. X DISTANCE ---
            const valX = targetX - rPos.x; // Math remains simple relative to world
            const startPtX = new THREE.Vector3(rPos.x, targetY, 0); // Ruler X projected to object Y
            const endPtX = new THREE.Vector3(targetX, targetY, 0);

            // Special Visual Fix: Draw the line at the Ruler's Y level, or the Object's Y level?
            // Standard CAD draws it relative to the ruler axis.
            const rulerLineY = (rulerRotState === 0 || rulerRotState === 1) ? Math.min(box.min.y, rPos.y) : Math.max(box.max.y, rPos.y);
            const visStartX = new THREE.Vector3(rPos.x, rulerLineY, 0);
            const visEndX = new THREE.Vector3(targetX, rulerLineY, 0);

            const labelPosX = addDimensionLines(visStartX, visEndX, labelOffsetX, 0x0d6efd);

            createInputLabel(labelPosX, Math.abs(valX), 'pos', (newVal) => {
                // If we are measuring to the Left (negative), keep it negative
                const sign = valX < 0 ? -1 : 1;
                const diff = (newVal * sign) - valX;
                obj.position.x += diff;
                obj.updateMatrixWorld();
                updateTinkerLabels();
                saveState();
                window.requestRender();
            });


            // --- 2. Y DISTANCE ---
            const valY = targetY - rPos.y;

            const rulerLineX = (rulerRotState === 0 || rulerRotState === 3) ? Math.min(box.min.x, rPos.x) : Math.max(box.max.x, rPos.x);
            const visStartY = new THREE.Vector3(rulerLineX, rPos.y, 0);
            const visEndY = new THREE.Vector3(rulerLineX, targetY, 0);

            const labelPosY = addDimensionLines(visStartY, visEndY, labelOffsetY, 0x0d6efd);

            createInputLabel(labelPosY, Math.abs(valY), 'pos', (newVal) => {
                const sign = valY < 0 ? -1 : 1;
                const diff = (newVal * sign) - valY;
                obj.position.y += diff;
                obj.updateMatrixWorld();
                updateTinkerLabels();
                saveState();
                window.requestRender();
            });


            // --- 3. Z DISTANCE (LIFT) ---
            // Lift is usually consistent, but we move the visual line to the ruler's corner
            const currentDistZ = box.min.z - rPos.z;

            // Anchor the Z ruler to the corner closest to the ruler origin
            const anchorX = (rulerRotState === 1 || rulerRotState === 2) ? box.max.x : box.min.x;
            const anchorY = (rulerRotState === 2 || rulerRotState === 3) ? box.max.y : box.min.y;

            const rulerFloorPt = new THREE.Vector3(anchorX, anchorY, rPos.z);
            const objectBottomPt = new THREE.Vector3(anchorX, anchorY, box.min.z);

            const labelPosZ = addDimensionLines(rulerFloorPt, objectBottomPt, new THREE.Vector3(25, 0, 0), 0x0d6efd);
            createInputLabel(labelPosZ, currentDistZ, 'pos', (newVal) => {
                const diff = newVal - currentDistZ;
                obj.position.z += diff;
                obj.updateMatrixWorld();
                updateTinkerLabels();
                updateLiftConePos();
                saveState();
                window.requestRender();
            });
        }
    }

    // Updated Resize to handle scale limits better prevents inverting shapes
    function resizeObject(mesh, axis, targetSize) {
        if(targetSize <= 0.1) return;

        // Ensure matrix is up to date before measuring
        mesh.updateMatrixWorld();

        const box = new THREE.Box3().setFromObject(mesh);
        const currentSize = box.getSize(new THREE.Vector3());

        // Prevent division by zero
        if(Math.abs(currentSize[axis]) < 0.01) return;

        const scaleFactor = targetSize / currentSize[axis];

        // Apply scale
        mesh.scale[axis] *= scaleFactor;

        mesh.updateMatrixWorld();
        updateTinkerLabels();
        updatePropertiesPanel();
        saveState();
    }

    // --- INTERACTION ---
// --- IMPROVED INTERACTION LOGIC ---

    // 1. Variables to track "Click vs Drag"
    let pointerStartX = 0;
    let pointerStartY = 0;

    // 2. UPDATED POINTER DOWN
    const onPointerDown = e => {
        // Just record position, don't trigger logic yet
        pointerStartX = e.clientX;
        pointerStartY = e.clientY;

        // Handle Lift Tool (Exceptions)
        if (liftCone.visible) {
            const rect = ren.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1);
            ray.setFromCamera(mouse, cam);
            const coneHit = ray.intersectObject(liftCone);
            if (coneHit.length > 0) {
                isLifting = true;
                ctrl.enabled = false;
                liftStartMouseY = e.clientY;
                liftStartObjZ = selectedObjects[0].position.z;
                liftCone.material.color.setHex(0xffff00);
            }
        }

        // Mark interaction for render loop
        isInteracting = true;
        window.requestRender();
    };

/// 3. UPDATED POINTER UP (The Brains)
const onPointerUp = e => {
    isInteracting = false; 

    // 1. Calculate Mouse/Ray ONCE for all tools
    const rect = ren.domElement.getBoundingClientRect();
    const mouse = new THREE.Vector2(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1);
    ray.setFromCamera(mouse, cam);

    // 2. Extrude Tool (High Priority)
    if(window.handleExtrudeClick && window.handleExtrudeClick(ray)) return;

    // 3. Lift Tool (High Priority)
    if (isLifting) {
        isLifting = false;
        ctrl.enabled = true;
        liftCone.material.color.setHex(0x222222);
        saveState();
        return;
    }

    // 4. Drag Check (Stop click logic if we just dragged the camera)
    const dist = Math.sqrt(Math.pow(e.clientX - pointerStartX, 2) + Math.pow(e.clientY - pointerStartY, 2));
    if (dist > 5) return;

    // --- FROM HERE DOWN, WE USE THE RAY CALCULATED AT THE TOP ---

    if (window.handleRulerClick && window.handleRulerClick(ray)) return;

    if (textPlaceMode) {
         if (textGhost && textGhost.visible) {
            const bend = textGhost.userData.geoParams ? textGhost.userData.geoParams.bend : 0;
            createTextObject(textGhost.position, textGhost.quaternion, bend);
         }
         textPlaceMode = false;
         scene.remove(textGhost);
         textGhost = null;
         document.body.style.cursor = 'default';
         document.getElementById("auto-save-status").style.opacity = 0;
         return;
    }

    if (e.target.tagName === 'INPUT') return;
    if (tCtrl.dragging || tCtrl.axis) return;

    if (alignState !== 'none') {
        if(handleAlignClick(ray)) return;
    }

    // --- B. LOFT FACE SELECTION ---
    if (isFaceLoftMode) {
        const intersects = ray.intersectObjects(scene.children.filter(o => o.isMesh && o !== liftCone && !o.userData.isRuler && o.visible), false);
        if (intersects.length > 0) handleFaceSelection(intersects[0]);
        return;
    }

    // --- NEW: D. SHELL FACE SELECTION ---
    if (isShellSelectMode) {
        // Only allow clicking the selected object
        const targetObj = selectedObjects[0];
        const intersects = ray.intersectObject(targetObj, false);
        if (intersects.length > 0) {
            window.handleShellFaceClick(intersects[0]);
        }
        return;
    }
    // ------------------------------------

    // C. STANDARD SELECTION
    const intersects = ray.intersectObjects(scene.children, true);
    const validHits = intersects.filter(hit => {
        const o = hit.object;
        let p = o.parent;
        while(p) { if(p === schematicGroup || p === faceMarkerGroup) return false; p = p.parent; }
        return (o.isMesh || o.isLine) && o !== liftCone && o !== schematicGroup && o !== faceMarkerGroup && !o.userData.isGhost;
    });

    if (validHits.length > 0) {
        let hitObj = validHits[0].object;
        let parent = hitObj.parent;
        if(parent && parent.userData && parent.userData.isRuler) {
            selectObject(parent);
        }
        else if (hitObj.userData.name) {
            selectObject(hitObj, e.shiftKey);
        }
    } else {
        selectObject(null);
    }

    // --- NEW: D. SHELL FACE SELECTION (Toggle Logic) ---
    if (isShellSelectMode) {
        // 1. Check if we clicked an EXISTING MARKER (Deselect)
        const markerIntersects = ray.intersectObjects(shellMarkers, false);
        if (markerIntersects.length > 0) {
            // Remove the marker
            const marker = markerIntersects[0].object;
            scene.remove(marker);
            faceMarkerGroup.remove(marker); // Ensure removed from group
            
            // Remove from array
            shellMarkers = shellMarkers.filter(m => m !== marker);
            
            // Clean up memory
            marker.geometry.dispose();
            marker.material.dispose();

            updateShellStatus();
            return;
        }

        // 2. Check if we clicked the OBJECT (Select)
        const targetObj = selectedObjects[0];
        const intersects = ray.intersectObject(targetObj, false);
        if (intersects.length > 0) {
            window.handleShellFaceClick(intersects[0]);
        }
        return;
    }
    // ------------------------------------
};
function updateShellStatus() {
        const status = document.getElementById("auto-save-status");
        if (shellMarkers.length === 0) {
            status.innerText = "Select faces to open. (Click Green to Deselect)";
        } else {
            status.innerText = `${shellMarkers.length} Face(s) Selected. Click 'Shell' button to Finish.`;
        }
        status.style.opacity = 1;
    }
    
window.handleShellFaceClick = (hit) => {
        const mesh = hit.object;
        
        // 1. Use the "Smart" Flood Fill to get all connected coplanar faces
        // This is the same logic used by the Loft tool
        const surfaceData = getConnectedFlatSurface(mesh, hit.faceIndex, hit.face.normal);
        
        // 2. Build a Visual Marker for this entire surface
        const markerGeo = new THREE.BufferGeometry();
        const markerPositions = [];
        const posAttr = mesh.geometry.attributes.position;
        
        // Collect vertices
        for(let i = 0; i < surfaceData.indices.length; i++) {
            const idx = surfaceData.indices[i];
            markerPositions.push(posAttr.getX(idx), posAttr.getY(idx), posAttr.getZ(idx));
        }
        
        markerGeo.setAttribute('position', new THREE.Float32BufferAttribute(markerPositions, 3));
        
        // Calculate the average normal of this selection (for the cutout direction)
        const avgNormal = hit.face.normal.clone(); // Starting guess
        // (For perfectly flat surfaces, hit.normal is fine. For curved selections, 
        // the flood fill restricts variance, so hit.normal is usually sufficient direction)

        // Push marker slightly out along normal to prevent z-fighting
        markerGeo.translate(avgNormal.x * 0.2, avgNormal.y * 0.2, avgNormal.z * 0.2);

        const markerMat = new THREE.MeshBasicMaterial({ 
            color: 0x00ff00, 
            side: THREE.DoubleSide, 
            transparent: true, 
            opacity: 0.6, 
            depthTest: false 
        });

        const markerMesh = new THREE.Mesh(markerGeo, markerMat);
        
        // Sync transforms
        markerMesh.position.copy(mesh.position);
        markerMesh.rotation.copy(mesh.rotation);
        markerMesh.scale.copy(mesh.scale);
        
        // Store the normal in the mesh for later calculation
        // Transform normal to World Space
        const worldNormal = avgNormal.clone().applyQuaternion(mesh.quaternion).normalize();
        markerMesh.userData = { 
            isShellMarker: true,
            worldNormal: worldNormal 
        };

        scene.add(markerMesh); // Add to scene for raycasting
        faceMarkerGroup.add(markerMesh); // Add to group for cleanup
        shellMarkers.push(markerMesh); // Add to our list

        updateShellStatus();
    };
    function handleFaceSelection(hit) {
        const mesh = hit.object;
        const hitNormal = hit.face.normal.clone();
        const existingIdx = selectedFacesData.findIndex(f => f.meshUuid === mesh.uuid && f.normal.dot(hitNormal) > 0.99);

        if (existingIdx > -1) {
            selectedFacesData.splice(existingIdx, 1);
            const marker = faceMarkerGroup.children.find(m => m.userData.meshUuid === mesh.uuid && m.userData.normal.dot(hitNormal) > 0.99);
            if (marker) faceMarkerGroup.remove(marker);
        } else {
            const surfaceData = getConnectedFlatSurface(mesh, hit.faceIndex, hit.face.normal);
            const worldPoints = [];
            const posAttr = mesh.geometry.attributes.position;
            const uniqueIndices = [...new Set(surfaceData.indices)];
            uniqueIndices.forEach(idx => {
                const vec = new THREE.Vector3().fromBufferAttribute(posAttr, idx);
                vec.applyMatrix4(mesh.matrixWorld);
                worldPoints.push(vec);
            });
            selectedFacesData.push({ meshUuid: mesh.uuid, normal: hitNormal, points: worldPoints });
            const markerGeo = new THREE.BufferGeometry();
            const markerPositions = [];
            for(let i = 0; i < surfaceData.indices.length; i++) {
                const idx = surfaceData.indices[i];
                markerPositions.push(posAttr.getX(idx), posAttr.getY(idx), posAttr.getZ(idx));
            }
            markerGeo.setAttribute('position', new THREE.Float32BufferAttribute(markerPositions, 3));
            const markerMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide, transparent: true, opacity: 0.5, depthTest: false });
            const markerMesh = new THREE.Mesh(markerGeo, markerMat);
            markerMesh.position.copy(mesh.position);
            markerMesh.rotation.copy(mesh.rotation);
            markerMesh.scale.copy(mesh.scale);
            markerMesh.userData = { meshUuid: mesh.uuid, normal: hitNormal };
            faceMarkerGroup.add(markerMesh);
        }
    }

function getConnectedFlatSurface(mesh, startFaceIndex, targetNormal) {
        const geo = mesh.geometry;
        const posAttr = geo.attributes.position;
        const count = posAttr.count;

        // 1. Helper: Lower precision key to bridge CSG gaps
        // Using *10 instead of *100 allows vertices within ~0.1 to match
        const getVertKey = (idx) => {
            const x = posAttr.getX(idx);
            const y = posAttr.getY(idx);
            const z = posAttr.getZ(idx);
            return `${Math.round(x*10)},${Math.round(y*10)},${Math.round(z*10)}`;
        };

        const _vA = new THREE.Vector3(), _vB = new THREE.Vector3(), _vC = new THREE.Vector3();
        const _cb = new THREE.Vector3(), _ab = new THREE.Vector3();

        const getFaceNormal = (faceIdx, target) => {
            const a = faceIdx * 3;
            const b = faceIdx * 3 + 1;
            const c = faceIdx * 3 + 2;
            _vA.fromBufferAttribute(posAttr, a);
            _vB.fromBufferAttribute(posAttr, b);
            _vC.fromBufferAttribute(posAttr, c);
            _cb.subVectors(_vC, _vB);
            _ab.subVectors(_vA, _vB);
            _cb.cross(_ab).normalize();
            target.copy(_cb);
        };

        // 2. Build Adjacency Graph
        const vertToFaces = {};
        const totalFaces = count / 3;

        for (let f = 0; f < totalFaces; f++) {
            for (let v = 0; v < 3; v++) {
                const key = getVertKey(f * 3 + v);
                if (!vertToFaces[key]) vertToFaces[key] = [];
                vertToFaces[key].push(f);
            }
        }

        // 3. FLOOD FILL
        const selectedFaces = new Set();
        const queue = [startFaceIndex];
        selectedFaces.add(startFaceIndex);

        const tempNormal = new THREE.Vector3();

        while (queue.length > 0) {
            const currentFace = queue.pop();

            // Check all 3 vertices to find neighbors
            for (let v = 0; v < 3; v++) {
                const key = getVertKey(currentFace * 3 + v);
                const neighbors = vertToFaces[key];

                if (neighbors) {
                    for (let n of neighbors) {
                        if (selectedFaces.has(n)) continue;

                        // STRICT Normal Check: prevents jumping to side walls
                        getFaceNormal(n, tempNormal);
                        if (tempNormal.dot(targetNormal) > 0.999) { // Increased to 0.999 for safety

                            // RELAXED Connectivity Check:
                            // Just 1 shared vertex is enough if the normal is identical.
                            // This fixes the "Ring" issue.
                            let sharedVerts = 0;
                            for(let k=0; k<3; k++) {
                                const kKey = getVertKey(currentFace * 3 + k);
                                for(let j=0; j<3; j++) {
                                    if(kKey === getVertKey(n * 3 + j)) sharedVerts++;
                                }
                            }

                            if(sharedVerts >= 1) {
                                selectedFaces.add(n);
                                queue.push(n);
                            }
                        }
                    }
                }
            }
        }

        const indices = [];
        selectedFaces.forEach(f => {
            indices.push(f * 3, f * 3 + 1, f * 3 + 2);
        });

        return { indices };
    }


// 1. IMPROVED RULER CREATION
// We create a ruler that is a real object in the scene with a local matrix
window.createRuler = function() {
    if(rulerGroup) scene.remove(rulerGroup);

    rulerGroup = new THREE.Group();
    rulerGroup.userData = { isRuler: true };

    // A. Visual Lines (The L-Shape)
    const len = 200; // Longer ruler
    const material = new THREE.LineBasicMaterial({ color: 0x0d6efd, linewidth: 2, depthTest: false, transparent: true, opacity: 0.8 });

    // X Axis (Blue)
    const xGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(len,0,0)]);
    const xLine = new THREE.Line(xGeo, new THREE.LineBasicMaterial({ color: 0x0077ff, linewidth: 2, depthTest:false }));
    rulerGroup.add(xLine);

    // Y Axis (Green-ish)
    const yGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,len,0)]);
    const yLine = new THREE.Line(yGeo, new THREE.LineBasicMaterial({ color: 0x00cc44, linewidth: 2, depthTest:false }));
    rulerGroup.add(yLine);

    // Z Axis (Vertical Indicator)
    const zGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,50)]);
    const zLine = new THREE.Line(zGeo, new THREE.LineBasicMaterial({ color: 0x999999, linewidth: 1, transparent:true, opacity:0.3 }));
    rulerGroup.add(zLine);

    // Grid (The "Plane")
    const grid = new THREE.GridHelper(len*2, 20, 0x0077ff, 0xcccccc);
    grid.rotation.x = Math.PI/2; // Rotate to lie on XY plane
    grid.position.set(len/2, len/2, 0); // Offset center
    grid.material.opacity = 0.15;
    grid.material.transparent = true;
    grid.material.depthTest = false;
    rulerGroup.add(grid);

    // Protractor Arc (Visual)
    const arcCurve = new THREE.EllipseCurve(0, 0, 30, 30, 0, Math.PI/2, false, 0);
    const arcPts = arcCurve.getPoints(50);
    const arcGeo = new THREE.BufferGeometry().setFromPoints(arcPts);
    const arcLine = new THREE.Line(arcGeo, new THREE.LineBasicMaterial({ color: 0xffaa00, transparent:true, opacity:0.6 }));
    rulerGroup.add(arcLine);

    // Add Origin Sphere (Click target)
    const sphere = new THREE.Mesh(new THREE.SphereGeometry(2), new THREE.MeshBasicMaterial({ color: 0x0d6efd }));
    rulerGroup.add(sphere);

    // Default Position
    rulerGroup.position.set(-50, -50, 0);
    rulerGroup.visible = showRuler;
    rulerGroup.renderOrder = 999; // Draw on top
    scene.add(rulerGroup);
};

window.resetRuler = function() {
    rulerGroup.position.set(-50, -50, 0);
    rulerGroup.rotation.set(0,0,0);
    rulerGroup.scale.set(1,1,1);
    updateTinkerLabels();
    window.requestRender();
}

// 2. RULER INTERACTION LOGIC

window.startRulerSnap = function() {
    if(!showRuler) window.toggleRuler();

    // Step 1: Pick Origin
    rulerSnapState = 1;
    document.body.classList.add("cursor-cross");
    selectObject(null);

    const status = document.getElementById("auto-save-status");
    status.innerText = "Step 1: Click a CORNER to place Ruler Start";
    status.style.opacity = 1;

    // Visual feedback on button
    document.getElementById('btn-ruler-snap').classList.add('active-tool');
}

// Helper: Get Closest Vertex to Mouse Ray
function getClosestVertex(ray, object) {
    // 1. Raycast against mesh to find hit point
    const intersects = ray.intersectObject(object, false);
    if(intersects.length === 0) return null;

    const hit = intersects[0];
    const geo = object.geometry;
    const pos = geo.attributes.position;

    // 2. Iterate vertices to find closest to hit point
    let minD = Infinity;
    let closestWorldPt = new THREE.Vector3();
    const tempV = new THREE.Vector3();

    // Optimization: Only check vertices in the intersected face?
    // For snapping, checking whole object is safer for "corners"
    // To save perf, we only check if object has < 10k verts, else use face

    const indices = [hit.face.a, hit.face.b, hit.face.c];

    indices.forEach(idx => {
        tempV.fromBufferAttribute(pos, idx).applyMatrix4(object.matrixWorld);
        const d = tempV.distanceTo(hit.point);
        if(d < minD) {
            minD = d;
            closestWorldPt.copy(tempV);
        }
    });

    return { point: closestWorldPt, normal: hit.face.normal };
}

// Hook into existing Pointer Events (Inject this logic)
const originalPointerUp = window.onPointerUp || ((e)=>{}); // Backup if needed, though we rely on order

// We replace the logic inside the main event loop slightly, but to keep it simple,
// we will intercept the click in a new handler that runs *before* the main selection.

// 1. HELPER: Calculate Rotation (Guarantees Ghost & Real Ruler match)
function getRulerRotation(origin, targetPoint, surfaceNormal) {
    // X-Axis: Points from Origin to Mouse
    const xDir = new THREE.Vector3().subVectors(targetPoint, origin).normalize();

    // Z-Axis: Points OUT of the surface (Surface Normal)
    // We clone it to be safe
    let zDir = surfaceNormal.clone().normalize();

    // Safety: If X and Z are parallel (unlikely), force Z to World Up
    if(Math.abs(xDir.dot(zDir)) > 0.99) {
        zDir.set(0,0,1);
    }

    // Y-Axis: Perpendicular to Z and X (Right Hand Rule)
    const yDir = new THREE.Vector3().crossVectors(zDir, xDir).normalize();

    // Recalculate Z to ensure it's perfectly orthogonal
    // (This fixes the "tilted" or "180 off" look)
    const finalZ = new THREE.Vector3().crossVectors(xDir, yDir).normalize();

    const m = new THREE.Matrix4().makeBasis(xDir, yDir, finalZ);
    return new THREE.Quaternion().setFromRotationMatrix(m);
}

// 2. UPDATED CLICK HANDLER (Uses the helper)
window.handleRulerClick = function(ray) {
    if(rulerSnapState === 0) return false;

    // Filter targets
    const targets = scene.children.filter(o => o.isMesh && !o.userData.isRuler && o !== liftCone && o !== snapMarker && o !== snapEdgeLine);

    // STEP 1: PLACE ORIGIN
    if(rulerSnapState === 1) {
        const hitData = window.getSmartSnap(ray, targets);
        if(hitData) {
            rulerGroup.position.copy(hitData.point);
            rulerOriginVec.copy(hitData.point); // Store for step 2

            // Align Z to normal immediately for better visual
            const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), hitData.normal);
            rulerGroup.quaternion.copy(q);

            rulerSnapState = 2;
            document.getElementById("auto-save-status").innerText = "Step 2: Click to align X-Axis";
            return true;
        }
    }

    // STEP 2: ALIGN ROTATION
    else if(rulerSnapState === 2) {
        const hitData = window.getSmartSnap(ray, targets);
        if(hitData) {
            // Prevent zero-length error
            if(rulerOriginVec.distanceTo(hitData.point) < 0.1) return true;

            // Use the Helper Function
            const newQuat = getRulerRotation(rulerOriginVec, hitData.point, hitData.normal);
            rulerGroup.quaternion.copy(newQuat);

            // Finish
            rulerSnapState = 0;
            document.body.classList.remove("cursor-cross");
            document.getElementById('btn-ruler-snap').classList.remove('active-tool');
            document.getElementById("auto-save-status").innerText = "Ruler Set";
            setTimeout(() => document.getElementById("auto-save-status").style.opacity = 0, 1500);

            updateTinkerLabels();
            return true;
        }
    }
    return false;
}



// Helper for finding smart snap points (Vertices or Midpoints)
function getSmartSnap(ray, targets) {
    const intersects = ray.intersectObjects(targets, false);
    if(intersects.length === 0) return null;

    const hit = intersects[0];
    const mesh = hit.object;

    // 1. Try Vertex Snap (Distance threshold)
    const vert = getClosestVertex(ray, mesh);

    // Check distance from hit point to vertex
    if(vert && vert.point.distanceTo(hit.point) < 5.0) {
        return { point: vert.point, normal: hit.face.normal, obj: mesh };
    }

    // 2. Default to Hit Point (Surface Snap)
    return { point: hit.point, normal: hit.face.normal, obj: mesh };
}


// 3. UPDATED LABELS (Enables Negative Numbers)
// 3. UPDATED LABELS (Absolute Positive + Purple Height Label)
window.updateTinkerLabels = function() {
    // Cleanup old labels
    activeLabels.forEach(l => scene.remove(l));
    activeLabels.length = 0;
    while(schematicGroup.children.length > 0) schematicGroup.remove(schematicGroup.children[0]);

    if(selectedObjects.length !== 1) return;
    const obj = selectedObjects[0];
    if(obj.userData.isRuler) return;

    // --- A. SIZE LABELS (Grey) ---
    const box = new THREE.Box3().setFromObject(obj);
    const size = box.getSize(new THREE.Vector3());

    // X, Y, Z Size
    const sx = addDimensionLines(new THREE.Vector3(box.min.x, box.max.y, box.min.z), new THREE.Vector3(box.max.x, box.max.y, box.min.z), new THREE.Vector3(0, 5, 0), 0x444444);
    createInputLabel(sx, size.x, 'size', (v) => resizeObject(obj, 'x', v));

    const sy = addDimensionLines(new THREE.Vector3(box.min.x, box.min.y, box.min.z), new THREE.Vector3(box.min.x, box.max.y, box.min.z), new THREE.Vector3(-5, 0, 0), 0x444444);
    createInputLabel(sy, size.y, 'size', (v) => resizeObject(obj, 'y', v));

    const sz = addDimensionLines(new THREE.Vector3(box.max.x, box.min.y, box.min.z), new THREE.Vector3(box.max.x, box.min.y, box.max.z), new THREE.Vector3(10, 0, 0), 0x444444);
    createInputLabel(sz, size.z, 'size', (v) => resizeObject(obj, 'z', v));


    // --- B. RULER RELATIVE POSITION ---
    if(showRuler && rulerGroup) {
        const worldPos = obj.position.clone();
        const localPos = worldPos.clone().applyMatrix4(rulerGroup.matrixWorld.clone().invert());

        const rPos = rulerGroup.position;
        const rQuat = rulerGroup.quaternion;
        const vX = new THREE.Vector3(1,0,0).applyQuaternion(rQuat);
        const vY = new THREE.Vector3(0,1,0).applyQuaternion(rQuat);
        const vZ = new THREE.Vector3(0,0,1).applyQuaternion(rQuat);

        // --- X DISTANCE (Blue) ---
        const endX = rPos.clone().add(vX.clone().multiplyScalar(localPos.x));
        const offY = vY.clone().multiplyScalar(-15);

        addDimensionLines(rPos, endX, offY, 0x0d6efd);
        createInputLabel(
            rPos.clone().lerp(endX, 0.5).add(offY),
            Math.abs(localPos.x), // Force Positive
            'pos',
            (newVal) => {
                const sign = localPos.x < 0 ? -1 : 1;
                const diff = (newVal * sign) - localPos.x;
                obj.position.add(vX.clone().multiplyScalar(diff));
                updateTinkerLabels(); saveState();
            }
        );

        // --- Y DISTANCE (Green) ---
        const endY = rPos.clone().add(vY.clone().multiplyScalar(localPos.y));
        const offX = vX.clone().multiplyScalar(-15);

        addDimensionLines(rPos, endY, offX, 0x00cc44);
        createInputLabel(
            rPos.clone().lerp(endY, 0.5).add(offX),
            Math.abs(localPos.y), // Force Positive
            'pos',
            (newVal) => {
                const sign = localPos.y < 0 ? -1 : 1;
                const diff = (newVal * sign) - localPos.y;
                obj.position.add(vY.clone().multiplyScalar(diff));
                updateTinkerLabels(); saveState();
            }
        );

        // --- Z DISTANCE / UP-DOWN (Purple) ---
        const endZ = rPos.clone().add(vZ.clone().multiplyScalar(localPos.z));
        const offZ = new THREE.Vector3().addVectors(vX, vY).normalize().multiplyScalar(20);

        // We use a different color (Purple) for the line to verify the update
        addDimensionLines(rPos, endZ, offZ, 0x6f42c1); // Purple Line

        const zLabel = createInputLabel(
            rPos.clone().lerp(endZ, 0.5).add(offZ),
            Math.abs(localPos.z), // Force Positive
            'pos',
            (newVal) => {
                const sign = localPos.z < 0 ? -1 : 1;
                const diff = (newVal * sign) - localPos.z;
                obj.position.add(vZ.clone().multiplyScalar(diff));
                updateTinkerLabels();
                updateLiftConePos();
                saveState();
            }
        );
        // Turn the text box Purple too
        if(zLabel && zLabel.element && zLabel.element.children[0]) {
            zLabel.element.children[0].style.borderColor = '#6f42c1';
            zLabel.element.children[0].style.color = '#6f42c1';
        }

        // --- ANGLE ---
        const objForward = new THREE.Vector3(1,0,0).applyQuaternion(obj.quaternion).normalize();
        const rulerForward = vX.clone().normalize();
        let angleDeg = Math.round(rulerForward.angleTo(objForward) * (180/Math.PI));

        const div = document.createElement('div');
        div.className = 'rot-label';
        div.style.background = 'rgba(255, 165, 0, 0.8)'; div.style.color = 'white';
        div.innerText = angleDeg + "°";
        const angleLabel = new CSS2DObject(div);
        const boxZ = box.getSize(new THREE.Vector3()).z;
        angleLabel.position.copy(worldPos).add(new THREE.Vector3(0,0, boxZ/2 + 10));
        scene.add(angleLabel);
        activeLabels.push(angleLabel);
    }
};

// 1. Initialize Visuals
function initSmartVisuals() {
    if(ghostRulerGroup) return;

    // A. Vertex Marker (Yellow Sphere)
    snapMarker = new THREE.Mesh(
        new THREE.SphereGeometry(1.5, 16, 16),
        new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.9, depthTest: false })
    );
    snapMarker.renderOrder = 9999;
    // CRITICAL FIX: Disable raycasting so the mouse "sees through" this marker
    snapMarker.raycast = () => {};
    snapMarker.visible = false;
    scene.add(snapMarker);

    // B. Edge Highlight (Yellow Cylinder)
    snapEdgeLine = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5, 0.5, 1, 8),
        new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.8, depthTest: false })
    );
    snapEdgeLine.rotation.z = Math.PI / 2;
    snapEdgeLine.renderOrder = 9999;
    // CRITICAL FIX: Disable raycasting here too
    snapEdgeLine.raycast = () => {};
    snapEdgeLine.visible = false;
    scene.add(snapEdgeLine);

    // C. Ghost Ruler (Transparent Blue Preview)
    ghostRulerGroup = new THREE.Group();
    const ghostMat = new THREE.LineBasicMaterial({ color: 0x0d6efd, transparent: true, opacity: 0.3, depthTest: false });

    // Ghost Axes
    const xGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(50,0,0)]);
    const yGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,50,0)]);
    ghostRulerGroup.add(new THREE.Line(xGeo, ghostMat));
    ghostRulerGroup.add(new THREE.Line(yGeo, ghostMat));

    // Ghost Protractor
    const arcCurve = new THREE.EllipseCurve(0, 0, 20, 20, 0, Math.PI/2);
    const arcLine = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints(arcCurve.getPoints(32)),
        ghostMat
    );
    ghostRulerGroup.add(arcLine);

    ghostRulerGroup.visible = false;
    ghostRulerGroup.renderOrder = 9998;
    // CRITICAL FIX: Disable raycasting on the whole group
    ghostRulerGroup.traverse(c => { c.raycast = () => {}; });
    scene.add(ghostRulerGroup);
}

// 2. Logic to Find Closest Vertex or Edge
window.getSmartSnap = function(ray, targets) {
    const intersects = ray.intersectObjects(targets, false);
    if(intersects.length === 0) return null;

    const hit = intersects[0];
    const mesh = hit.object;
    const posAttr = mesh.geometry.attributes.position;

    // Calculate World Positions of the triangle vertices we hit
    const vA = new THREE.Vector3().fromBufferAttribute(posAttr, hit.face.a).applyMatrix4(mesh.matrixWorld);
    const vB = new THREE.Vector3().fromBufferAttribute(posAttr, hit.face.b).applyMatrix4(mesh.matrixWorld);
    const vC = new THREE.Vector3().fromBufferAttribute(posAttr, hit.face.c).applyMatrix4(mesh.matrixWorld);

    const snapDist = 2.5; // Tighter snap tolerance

    // Priority 1: Snap to VERTEX
    if(hit.point.distanceTo(vA) < snapDist) return { point: vA, normal: hit.face.normal, obj: mesh, type: 'vertex' };
    if(hit.point.distanceTo(vB) < snapDist) return { point: vB, normal: hit.face.normal, obj: mesh, type: 'vertex' };
    if(hit.point.distanceTo(vC) < snapDist) return { point: vC, normal: hit.face.normal, obj: mesh, type: 'vertex' };

    // Priority 2: Snap to EDGE
    const checkEdge = (start, end) => {
        const line = new THREE.Line3(start, end);
        const closest = new THREE.Vector3();
        line.closestPointToPoint(hit.point, true, closest);
        if(closest.distanceTo(hit.point) < snapDist) {
            return { pos: closest, start: start, end: end };
        }
        return null;
    }

    const e1 = checkEdge(vA, vB);
    const e2 = checkEdge(vB, vC);
    const e3 = checkEdge(vC, vA);
    const edge = e1 || e2 || e3;

    if(edge) {
        return {
            point: edge.pos,
            normal: hit.face.normal,
            obj: mesh,
            type: 'edge',
            edgeStart: edge.start,
            edgeEnd: edge.end
        };
    }

    // Default: Snap to SURFACE
    return { point: hit.point, normal: hit.face.normal, obj: mesh, type: 'face' };
}

// 3. UPDATED HOVER LISTENER (Visual Sync Fix)
const canvasEl = document.getElementById("designer-canvas");
canvasEl.addEventListener("pointermove", (e) => {
    if(!ren || !cam) return;
    window.requestRender();

    if(typeof rulerSnapState !== 'undefined' && rulerSnapState > 0) {
        initSmartVisuals();

        const rect = canvasEl.getBoundingClientRect();
        const mouse = new THREE.Vector2(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1);
        ray.setFromCamera(mouse, cam);

        const targets = scene.children.filter(o =>
            o.isMesh &&
            !o.userData.isRuler &&
            o !== liftCone &&
            o !== snapMarker &&
            o !== snapEdgeLine &&
            o.parent !== ghostRulerGroup
        );

        const hit = window.getSmartSnap(ray, targets);

        if(hit) {
            // Highlights (Same as before)
            if(hit.type === 'vertex') {
                snapMarker.position.copy(hit.point);
                snapMarker.visible = true; snapEdgeLine.visible = false;
            } else if(hit.type === 'edge') {
                snapMarker.visible = false; snapEdgeLine.visible = true;
                const center = new THREE.Vector3().addVectors(hit.edgeStart, hit.edgeEnd).multiplyScalar(0.5);
                snapEdgeLine.position.copy(center);
                const len = hit.edgeStart.distanceTo(hit.edgeEnd);
                snapEdgeLine.scale.set(1, len, 1);
                snapEdgeLine.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), new THREE.Vector3().subVectors(hit.edgeEnd, hit.edgeStart).normalize());
            } else {
                snapMarker.visible = false; snapEdgeLine.visible = false;
            }

            // GHOST LOGIC
            ghostRulerGroup.visible = true;

            if(rulerSnapState === 1) {
                // Step 1: Just place on point, align Z up
                ghostRulerGroup.position.copy(hit.point);
                const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), hit.normal);
                ghostRulerGroup.quaternion.copy(q);
            }
            else if(rulerSnapState === 2) {
                // Step 2: Use the SHARED HELPER to ensure visual match
                ghostRulerGroup.position.copy(rulerOriginVec);
                if(rulerOriginVec.distanceTo(hit.point) > 0.1) {
                    const q = getRulerRotation(rulerOriginVec, hit.point, hit.normal);
                    ghostRulerGroup.quaternion.copy(q);
                }
            }
        } else {
            ghostRulerGroup.visible = false; snapMarker.visible = false; snapEdgeLine.visible = false;
        }
    } else {
        if(ghostRulerGroup) ghostRulerGroup.visible = false;
        if(snapMarker) snapMarker.visible = false;
        if(snapEdgeLine) snapEdgeLine.visible = false;
    }
});

// 1. START PLACEMENT MODE
    window.dStartText = () => {
        if(!loadedFont) return alert("Font loading... try again in a second.");

        // Deselect everything
        selectObject(null);

        // Enter Mode
        textPlaceMode = true;
        document.body.style.cursor = 'crosshair';

        // Create Ghost
        const geo = new TextGeometry('Text', { font: loadedFont, size: 10, height: 2, curveSegments: 4 });
        geo.center();

        // Create a parent wrapper to handle the offset easily
        textGhost = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: 0x0d6efd, transparent: true, opacity: 0.5, wireframe: true }));
        textGhost.userData.isGhost = true;
        scene.add(textGhost);

        const status = document.getElementById("auto-save-status");
        status.innerText = "Click on a surface to place text";
        status.style.opacity = 1;
    };

    // 2. CREATE THE REAL TEXT
function createTextObject(pos, quat, bendValue) { // Added bendValue param
        const textString = "Text";

        // Use the new helper to generate the initial geometry with the correct bend
        const dummyMesh = {
            userData: { geoParams: { type: 'text', text: textString, bend: bendValue || 0 } },
            geometry: null
        };

        // We hijack the regenerate function to create our first geometry
        // Use a temp geometry to start
        dummyMesh.geometry = new TextGeometry(textString, { font: loadedFont, size: 10, height: 2, curveSegments: 4 });
        regenerateText(dummyMesh); // This applies the bend math immediately

        const mat = new THREE.MeshStandardMaterial({ color: 0x0d6efd });
        const mesh = new THREE.Mesh(dummyMesh.geometry, mat);

        mesh.position.copy(pos);
        mesh.quaternion.copy(quat);

        const nameCount = scene.children.filter(e => e.userData && e.userData.name && e.userData.name.startsWith("Text")).length + 1;
        mesh.userData = {
            name: `Text ${nameCount}`,
            isHole: false,
            geoParams: { type: 'text', text: textString, bend: bendValue || 0 }
        };

        mesh.castShadow = true;
        mesh.receiveShadow = true;

        scene.add(mesh);
        selectObject(mesh);
        saveState();
    }

    // 3. REGENERATE TEXT (When typing or bending)
function regenerateText(mesh) {
        // SAFETY CHECK
        if (!loadedFont) {
            console.warn("Font not loaded yet, skipping regeneration");
            return;
        }
        const p = mesh.userData.geoParams;
        if(!p || p.type !== 'text') return;

        // 1. Create Base Geometry
        let geo = new TextGeometry(p.text, {
            font: loadedFont,
            size: 10,
            height: 2, // This is the Z-thickness
            curveSegments: 4
        });

        // Center X/Y but keep Z at 0 (back of text) for easier bending
        geo.computeBoundingBox();
        const centerOffset = - 0.5 * ( geo.boundingBox.max.x - geo.boundingBox.min.x );
        const centerOffsetY = - 0.5 * ( geo.boundingBox.max.y - geo.boundingBox.min.y );
        geo.translate( centerOffset, centerOffsetY, 0 );

        // 2. APPLY BEND (The "Wrapping" Logic)
        // We use 'curvature' (1/radius). 0 = Flat. 0.1 = Radius 10.
        if (Math.abs(p.bend) > 0.001) {
            const posAttribute = geo.attributes.position;
            const vertex = new THREE.Vector3();

            // Calculate Radius from Curvature
            // p.bend is now "Curvature".
            // If bend is 0.05, Radius is 20.
            const radius = 1 / p.bend;

            for ( let i = 0; i < posAttribute.count; i ++ ) {
                vertex.fromBufferAttribute( posAttribute, i );

                // The "Depth" of this vertex (0 to 2)
                const zDepth = vertex.z;

                // The effective radius for THIS vertex (Thickness preservation)
                // We wrap around the cylinder. The back of text is at 'radius'.
                // The front of text is at 'radius + zDepth'.
                const effectiveR = radius + zDepth;

                // Calculate angle based on X position
                const angle = vertex.x / radius;

                // New positions (Cylindrical coordinates)
                // We subtract radius from Z at the end to bring the "back" of the text to Z=0
                const nx = effectiveR * Math.sin(angle);
                const nz = effectiveR * Math.cos(angle) - radius;

                posAttribute.setXYZ( i, nx, vertex.y, nz );
            }

            geo.computeVertexNormals();
        }

        // 3. Update Mesh
        mesh.geometry.dispose();
        mesh.geometry = geo;

        // IMPORTANT: Re-calculate bounds so the Selection Box / Gizmo matches the new curved shape
        mesh.geometry.computeBoundingBox();

        window.requestRender();
    }


window.reSnapText = () => {
        if(selectedObjects.length !== 1) return;
        const obj = selectedObjects[0];
        if(!obj.userData.geoParams || obj.userData.geoParams.type !== 'text') return;

        // 1. Setup Ray from Object Center, pointing "Inwards" (Local -Z)
        const origin = obj.position.clone();
        // The text's "back" is its local negative Z? Actually we oriented Z as Normal.
        // So we cast ray in direction of -Z (into the surface)
        const direction = new THREE.Vector3(0,0,-1).applyQuaternion(obj.quaternion).normalize();

        // Start ray slightly "above" text to ensure we hit the surface
        const startPt = origin.clone().sub(direction.clone().multiplyScalar(2)); // Back up 2 units

        ray.set(startPt, direction);

        // Filter out the text itself
        const targets = scene.children.filter(o => o.isMesh && o !== obj && !o.userData.isGhost && !o.userData.isRuler && o !== liftCone);
        const intersects = ray.intersectObjects(targets, false);

        if(intersects.length > 0) {
            const hit = intersects[0];
            // Reuse the math from onPointerMove...
            // Or simpler: Just calculate the curvature logic here.

            // ... Copy/Paste the "UNIVERSAL CURVATURE DETECTION" block from onPointerMove here ...
            // ... using 'hit' as the target ...

            // Simplified Logic for Re-Snap:
            const normal = hit.face.normal.clone().applyQuaternion(hit.object.quaternion).normalize();

            // Re-Align Rotation (Optional, maybe user likes their rotation?)
            // Let's just update the BEND for now to avoid flipping rotated text.

            const rightVec = new THREE.Vector3(1,0,0).applyQuaternion(obj.quaternion).normalize();
            const sampleDist = 5.0;
            const leftOrigin = hit.point.clone().sub(rightVec.clone().multiplyScalar(sampleDist)).add(normal.clone().multiplyScalar(2));
            const rightOrigin = hit.point.clone().add(rightVec.clone().multiplyScalar(sampleDist)).add(normal.clone().multiplyScalar(2));

            const rayDown = new THREE.Raycaster();
            const dir = normal.clone().negate();
            rayDown.set(leftOrigin, dir);
            const lHit = rayDown.intersectObject(hit.object, false);
            rayDown.set(rightOrigin, dir);
            const rHit = rayDown.intersectObject(hit.object, false);

            if(lHit.length>0 && rHit.length>0) {
                 const lNorm = lHit[0].face.normal.clone().applyQuaternion(hit.object.quaternion).normalize();
                 const rNorm = rHit[0].face.normal.clone().applyQuaternion(hit.object.quaternion).normalize();
                 const angle = lNorm.angleTo(rNorm);
                 if (angle > 0.001) {
                     const newBend = (angle / (sampleDist * 2)) * 1.0;
                     obj.userData.geoParams.bend = newBend;
                     regenerateText(obj);
                     updatePropertiesPanel(); // Refresh slider
                     saveState();
                 }
            }
        } else {
            alert("No surface found behind text to snap to.");
        }
    };

const onPointerMove = e => {
        // BUG FIX: Don't set isInteracting = true here.
        // We only want a single frame update for hovering, not a continuous loop.
        window.requestRender();
        if (typeof window.handleExtrudeHover === 'function') {
            // Pass the full event 'e' so we have X and Y
            window.handleExtrudeHover(null, e); 
        }
        // --- NEW: TEXT PLACEMENT GHOST ---
// --- ADVANCED TEXT PLACEMENT ---
        if (textPlaceMode && textGhost) {
            const rect = ren.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1);
            ray.setFromCamera(mouse, cam);

            // 1. Raycast Center
            const targets = scene.children.filter(o => o.isMesh && !o.userData.isGhost && !o.userData.isRuler && o !== liftCone);
            const intersects = ray.intersectObjects(targets, false);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const pt = hit.point;
                const normal = hit.face.normal.clone().applyQuaternion(hit.object.quaternion).normalize();

                // 2. STABLE ROTATION (No upside down flipping)
                // We want the text's "Up" (Local Y) to align with Surface Normal (Z in our text logic?)
                // Actually TextGeometry is created on XY plane.
                // So Local Z = Surface Normal.

                // Calculate a stable "Right" vector (Local X) that is parallel to the horizon
                const worldUp = new THREE.Vector3(0, 0, 1);
                let rightVec = new THREE.Vector3();

                // If surface is floor/ceiling, define arbitrary right
                if (Math.abs(normal.dot(worldUp)) > 0.99) {
                    rightVec.set(1, 0, 0);
                } else {
                    // Cross WorldUp with Normal to get a horizon line
                    rightVec.crossVectors(worldUp, normal).normalize();
                    // If looking "backwards", flip it to keep text readable left-to-right
                    // (Simple heuristic: assumes camera is somewhat upright)
                }

                // Create Basis Matrix
                const upVec = new THREE.Vector3().crossVectors(normal, rightVec).normalize();
                const basis = new THREE.Matrix4().makeBasis(rightVec, upVec, normal);
                textGhost.quaternion.setFromRotationMatrix(basis);

                // Position with nudge
                textGhost.position.copy(pt).add(normal.clone().multiplyScalar(0.5));
                textGhost.visible = true;

                // 3. UNIVERSAL CURVATURE DETECTION (Tri-Ray Sample)
                // We cast rays to the Left and Right of the hit point to measure surface angle
                const sampleDist = 5.0; // Check 5mm to the side
                const leftOrigin = pt.clone().sub(rightVec.clone().multiplyScalar(sampleDist)).add(normal.clone().multiplyScalar(2));
                const rightOrigin = pt.clone().add(rightVec.clone().multiplyScalar(sampleDist)).add(normal.clone().multiplyScalar(2));

                // Cast rays "Down" towards the surface (-Normal)
                const rayDown = new THREE.Raycaster();
                const dir = normal.clone().negate();

                rayDown.set(leftOrigin, dir);
                const leftHits = rayDown.intersectObject(hit.object, false);

                rayDown.set(rightOrigin, dir);
                const rightHits = rayDown.intersectObject(hit.object, false);

                let autoBend = 0;

                if (leftHits.length > 0 && rightHits.length > 0) {
                    const lNorm = leftHits[0].face.normal.clone().applyQuaternion(hit.object.quaternion).normalize();
                    const rNorm = rightHits[0].face.normal.clone().applyQuaternion(hit.object.quaternion).normalize();

                    // Angle between normals
                    let angle = lNorm.angleTo(rNorm);

                    // Convex or Concave? Check dot product with center normal
                    // Simple convex assumption for now (Curve wrap).
                    // Calculation: Curvature = Angle / ArcLength (approx Distance)
                    // Note: If normals point away, it's convex (+). If they point in, concave (-).
                    // We assume convex for external placement.

                    if (angle > 0.01) {
                         // Curvature K = 1/R.
                         // If we are placing on outside, we wrap positive.
                         // Using a dampener because the math for text bending is sensitive
                         autoBend = (angle / (sampleDist * 2)) * 1.0;
                    }
                }

                // Apply
                 if (!textGhost.userData.geoParams) textGhost.userData.geoParams = { type: 'text', text: 'Text', bend: 0 };
                 if (Math.abs(textGhost.userData.geoParams.bend - autoBend) > 0.005) {
                    textGhost.userData.geoParams.bend = autoBend;
                    regenerateText(textGhost);
                }

            } else {
                textGhost.visible = false;
            }
            return;
        }

        // 1. UPDATE GHOST IF IN ALIGN MODE
        if (alignState !== 'none' && e.buttons === 0) {
            const rect = ren.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1);
            ray.setFromCamera(mouse, cam);
            handleAlignHover(ray, mouse);
            return;
        }

        // ... Existing Lift Logic ...
        if (isLifting && selectedObjects.length === 1) {
            const deltaY = liftStartMouseY - e.clientY;
            selectedObjects[0].position.z = liftStartObjZ + (deltaY * 0.2);
            updateLiftConePos();
            updateTinkerLabels();
            updatePropertiesPanel();
        }
    };


    window.setMode = mode => { if(tCtrl) tCtrl.setMode(mode); document.querySelectorAll(".btn-tool").forEach(b => b.classList.remove("active-tool")); const btn = document.querySelector(`button[data-mode="${mode}"]`); if(btn) btn.classList.add("active-tool"); };

// --- GEOMETRY GENERATOR (FIXED AXIS) ---

    window.dAdd = type => {
        let geo, params = {};
        const nameCount = scene.children.filter(e => e.userData && e.userData.name).length + 1;
        let baseName = "Shape";
        const defaultChamfer = 0;

        switch (type) {
            case "cube":
                geo = new RoundedBoxGeometry(20, 20, 20, 4, defaultChamfer);
                baseName = "Cube";
                params = { type: 'box', w: 20, h: 20, d: 20, r: defaultChamfer };
                break;

            case "cyl":
                baseName = "Cylinder";
                // Standard Cylinder is Y-up. We rotate it to Z-up.
                geo = new THREE.CylinderGeometry(10, 10, 20, 32);
                geo.rotateX(Math.PI/2);
                params = { type: 'cylinder', rt: 10, rb: 10, h: 20, s: 32, chamfer: defaultChamfer };
                break;

            case "cone":
                baseName = "Cone";
                geo = new THREE.CylinderGeometry(0, 10, 20, 64);
                geo.rotateX(Math.PI/2);
                params = { type: 'cone', rt: 0, rb: 10, h: 20, s: 64, chamfer: defaultChamfer };
                break;

            case "wedge":
                baseName = "Wedge";
                geo = new THREE.CylinderGeometry(10, 10, 20, 3);
                geo.rotateZ(Math.PI / 6);
                geo.rotateX(Math.PI / 2); // Rotate Upright (Z-up)
                params = { type: 'wedge', rt: 10, rb: 10, h: 20, s: 3, chamfer: defaultChamfer };
                break;

            case "sph":
                geo = new THREE.SphereGeometry(10, 32, 32);
                baseName = "Sphere";
                params = { type: 'sphere', r: 10, wSeg: 32, hSeg: 32 };
                break;

            case "torus":
                geo = new THREE.TorusGeometry(10, 3, 16, 32);
                baseName = "Torus";
                params = { type: 'torus', r: 10, t: 3, rSeg: 16, tSeg: 32 };
                break;

            case "thread":
                baseName = "Thread";
                // Default to M10 x 20mm
                params = { type: 'thread', std: 'metric', name: 'M10', r: 5.0, p: 1.5, h: 20 };
                geo = generateThreadGeometry(params);
                break;
        }

        // Note: We no longer rotate the MESH. We rotated the GEOMETRY above.
        // This keeps Scale X=Width, Scale Y=Depth, Scale Z=Height consistent.
        buildAndAddMesh(geo, `${baseName} ${nameCount}`, params);
    };

    function generateExtrudedGeo(p) {
        const shape = new THREE.Shape();
        const bevel = p.chamfer || 0;

        // LOGIC: Adjust radius so adding chamfer doesn't make object wider
        // We subtract the bevel size from the base radius.

        if (p.type === 'cylinder' || p.type === 'cone') {
            if (Math.abs(p.rt - p.rb) > 0.1) {
                // Tapered: Fallback to Standard (Z-up)
                const g = new THREE.CylinderGeometry(p.rt, p.rb, p.h, p.s);
                g.rotateX(Math.PI/2);
                return g;
            } else {
                // Straight: Extrude (Naturally Z-up)
                const r = Math.max(0.1, p.rb - bevel); // Subtract bevel
                shape.absarc(0, 0, r, 0, Math.PI * 2, false);
            }
        }
        else if (p.type === 'wedge') {
            if (Math.abs(p.rt - p.rb) > 0.1) {
                const g = new THREE.CylinderGeometry(p.rt, p.rb, p.h, p.s);
                g.rotateZ(Math.PI / 6);
                g.rotateX(Math.PI / 2);
                return g;
            }
            const r = Math.max(0.1, p.rb - bevel);
            const step = (Math.PI * 2) / 3;
            // Draw triangle
            shape.moveTo(r * Math.cos(0), r * Math.sin(0));
            shape.lineTo(r * Math.cos(step), r * Math.sin(step));
            shape.lineTo(r * Math.cos(step*2), r * Math.sin(step*2));
            shape.lineTo(r * Math.cos(0), r * Math.sin(0));
        }

        const extrudeSettings = {
            depth: p.h - (bevel * 2), // Subtract bevel from height
            bevelEnabled: bevel > 0,
            bevelThickness: bevel,
            bevelSize: bevel,
            bevelSegments: 4,
            curveSegments: p.s
        };

        const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        geo.center();

        // ExtrudeGeometry is created in XY and extruded Z. It is ALREADY Z-up.
        // We do NOT need to rotate it.

        return geo;
    }

    function regenerateGeometry(mesh) {
        const p = mesh.userData.geoParams;
        if (!p) return;

        let newGeo;

        if (p.type === 'box') {
            newGeo = new RoundedBoxGeometry(p.w, p.h, p.d, 4, p.r || 0);
        }
        else if (p.type === 'cylinder' || p.type === 'cone') {
            newGeo = generateExtrudedGeo(p);
        }
        else if (p.type === 'wedge') {
            newGeo = generateExtrudedGeo(p);
        }
        else if (p.type === 'torus') {
            newGeo = new THREE.TorusGeometry(p.r, p.t, p.rSeg, p.tSeg);
        }
        else if (p.type === 'sphere') {
            newGeo = new THREE.SphereGeometry(p.r, p.wSeg, p.wSeg);
        }
        else if (p.type === 'thread') {
            newGeo = generateThreadGeometry(p);
        }

        if (newGeo) {
            newGeo.computeBoundingBox();
            if(p.type !== 'box') newGeo.center();
            mesh.geometry.dispose();
            mesh.geometry = newGeo;
            updateTinkerLabels();
            window.requestRender();
        }
    }

    // Function for Merged Objects (Fake Chamfer via Normals)
    window.updateSmoothness = (val) => {
        if(selectedObjects.length !== 1) return;
        const obj = selectedObjects[0];

        // Only for merged objects or non-parametric meshes
        if(obj.userData.geoParams) {
            // Parametric: Update the 'r' or 'chamfer' param
            obj.userData.geoParams.r = val; // For Box
            obj.userData.geoParams.chamfer = val; // For Extrusions
            regenerateGeometry(obj);
        } else {
            // Merged: Smooth Shading Logic
            const geo = obj.geometry;

            if (val > 0) {
                // Smooth: Merge vertices to allow normal smoothing
                if (!geo.userData.merged) {
                    const mergedGeo = mergeVertices(geo, 0.01);
                    obj.geometry.dispose();
                    obj.geometry = mergedGeo;
                    obj.geometry.userData.merged = true;
                }
                obj.geometry.computeVertexNormals();
                obj.material.flatShading = false;
            } else {
                // Sharp: Use flat shading
                obj.material.flatShading = true;
            }
            obj.material.needsUpdate = true;
        }
        window.requestRender();
        saveState();
    };

function buildAndAddMesh(geometry, name, geoParams = null, incomingMaterial = null) {
        // Ensure UVs exist (Critical for textures)
        if (!geometry.attributes.uv) {
            const count = geometry.attributes.position.count;
            geometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(count * 2), 2));
        }

        // Center the geometry for easier manipulation
        geometry.computeBoundingBox();
        geometry.center();

        let material;

        if (incomingMaterial) {
            // 1. USE IMPORTED MATERIAL (TEXTURES)
            // We clone it so if you import the same file twice, you can edit them independently
            material = incomingMaterial.clone();

            // Ensure wireframe toggle respects global settings
            material.wireframe = appSettings.wireframe;

            // Fix for some scanners exporting dark materials
            if(material.map) material.map.colorSpace = THREE.SRGBColorSpace;

            // Ensure we can see it (some imports come in with 0 opacity)
            material.transparent = false;
            material.opacity = 1.0;
        } else {
            // 2. DEFAULT BLUE MATERIAL
            material = new THREE.MeshStandardMaterial({
                color: 0x0d6efd,
                roughness: 0.4,
                metalness: 0.2,
                wireframe: appSettings.wireframe
            });
        }

        const mesh = new THREE.Mesh(geometry, material);
        const shadowsEnabled = (appSettings.shadows !== false); // Default true if undefined
        mesh.castShadow = shadowsEnabled;
        mesh.receiveShadow = shadowsEnabled;
        mesh.position.set(0, 0, 10);

        mesh.userData = { isHole: false, name: name, geoParams: geoParams };
        // Respect current shadow setting immediately
        mesh.castShadow = appSettings.shadows !== false;
        mesh.receiveShadow = appSettings.shadows !== false;

        scene.add(mesh);
        selectObject(mesh);
        updateObjectList();
        saveState();
        window.requestRender();

        return mesh;
    }
function updateParametricUI(obj) {
        const container = document.getElementById("shape-params");
        container.innerHTML = ""; // Clear previous

        if (!obj.userData.geoParams) {
            container.style.display = "none";
            return;
        }

        container.style.display = "block";
        const p = obj.userData.geoParams;

        // Helper to create slider
        const addSlider = (label, key, min, max, step) => {
            const div = document.createElement("div");
            div.className = "d-flex justify-content-between align-items-center mb-1";
            div.innerHTML = `
                <span class="small text-muted">${label}</span>
                <input type="range" class="form-range w-50" min="${min}" max="${max}" step="${step}" value="${p[key]}">
                <span class="small fw-bold" style="width:25px; text-align:right;">${p[key]}</span>
            `;
            const range = div.querySelector("input");
            const valSpan = div.querySelectorAll("span")[1];

            range.oninput = (e) => {
                valSpan.innerText = e.target.value;
                p[key] = parseFloat(e.target.value);
                regenerateGeometry(obj);
            };
            // Save state on release
            range.onchange = () => saveState();
            container.appendChild(div);
        };

        // 1. CONE / PYRAMID CONTROLS
        if (p.type === 'cone') {
            container.innerHTML += `<div class="small fw-bold mb-1"><i class="bi bi-cone-striped"></i> Shape Settings</div>`;
            addSlider("Sides", "s", 3, 64, 1);     // 3=Pyramid, 64=Cone
            addSlider("Top Width", "rt", 0, 20, 1);// 0=Pointy, >0=Truncated
            addSlider("Base Width", "rb", 1, 30, 1);
        }

        // 2. CYLINDER / WEDGE CONTROLS
        else if (p.type === 'cylinder') {
            container.innerHTML += `<div class="small fw-bold mb-1"><i class="bi bi-database"></i> Shape Settings</div>`;
            addSlider("Sides", "s", 3, 64, 1); // 3=Wedge, 32=Cylinder
            addSlider("Top Width", "rt", 1, 30, 1);
            addSlider("Bot Width", "rb", 1, 30, 1);
        }

        // 3. TORUS CONTROLS
        else if (p.type === 'torus') {
            container.innerHTML += `<div class="small fw-bold mb-1"><i class="bi bi-circle-half"></i> Torus Settings</div>`;
            addSlider("Radius", "r", 1, 50, 0.5);
            addSlider("Tube", "t", 0.1, 10, 0.1);
            addSlider("Resolution", "tSeg", 3, 64, 1);
        }

        // 4. SPHERE CONTROLS
        else if (p.type === 'sphere') {
             container.innerHTML += `<div class="small fw-bold mb-1"><i class="bi bi-circle"></i> Sphere Settings</div>`;
             addSlider("Detail", "wSeg", 4, 64, 1); // Only scaling one param for simplicity
        }

        else {
             container.style.display = "none";
        }
    }

    window.dRot = () => { if (selectedObjects.length!==1) return; const o=selectedObjects[0]; o.rotation.set(document.getElementById("opt-rot-x").value*(Math.PI/180), document.getElementById("opt-rot-y").value*(Math.PI/180), document.getElementById("opt-rot-z").value*(Math.PI/180)); updateTinkerLabels(); saveState(); };
window.dSz = () => {
    if (selectedObjects.length !== 1) return;

    const obj = selectedObjects[0];

    // 1. Capture ALL values immediately (before the UI gets updated/reset)
    const vX = parseFloat(document.getElementById("opt-sz-x").value);
    const vY = parseFloat(document.getElementById("opt-sz-y").value);
    const vZ = parseFloat(document.getElementById("opt-sz-z").value);

    // 2. Apply them using the CAPTURED values
    // Even if resizeObject resets the text box, we already have the value stored in vY/vZ
    if(!isNaN(vX)) resizeObject(obj, 'x', vX);
    if(!isNaN(vY)) resizeObject(obj, 'y', vY);
    if(!isNaN(vZ)) resizeObject(obj, 'z', vZ);
};
    window.dDrop = function() { if (selectedObjects.length === 0) return alert("Select object."); selectedObjects.forEach(obj => { const box = new THREE.Box3().setFromObject(obj); obj.position.z -= box.min.z; }); updateTinkerLabels(); updateLiftConePos(); saveState(); };

    function selectObject(obj, multi = false) {
            if (!multi) {
                selectedObjects.forEach(o => { if(o.material) o.material.emissive.setHex(0); });
                selectedObjects = [];
                document.querySelectorAll(".object-list-item").forEach(el => el.classList.remove("selected"));
            }
            if (obj) {
                if (selectedObjects.includes(obj)) {
                    if (multi) { selectedObjects = selectedObjects.filter(o => o !== obj); if(obj.material) obj.material.emissive.setHex(0); }
                } else {
                    selectedObjects.push(obj);
                    if(obj.material && !obj.userData.isRuler) obj.material.emissive.setHex(MESH_HIGHLIGHT_COLOR);
                    if(obj.userData.name) { const el = document.getElementById(obj.uuid); if(el) el.classList.add("selected"); }
                }
            }

            // Handle Gizmo
            if (selectedObjects.length === 1) {
                tCtrl.attach(selectedObjects[0]);
                if(selectedObjects[0].userData.isRuler) tCtrl.setMode('translate');
                updateLiftConePos(); updateTinkerLabels();
            } else {
                tCtrl.detach();
                updateLiftConePos();
                activeLabels.forEach(l => scene.remove(l)); activeLabels.length = 0;
                while(schematicGroup.children.length > 0){ schematicGroup.remove(schematicGroup.children[0]); }
            }

            updatePropertiesPanel();
            updateObjectList();

            // --- CRITICAL UPDATE ---
            // Force a re-render so the gizmo disappears immediately
            window.requestRender();
        }

const updatePropertiesPanel = () => {
        const panel = document.getElementById("prop-panel");
        const container = document.getElementById("shape-params");

        if (selectedObjects.length === 1 && !selectedObjects[0].userData.isRuler) {
            panel.style.display = "block";

            // Auto-Expand Logic
            if (!tCtrl.dragging) {
                 panel.classList.remove('minimized');
                 const icon = document.getElementById('icon-panel-props');
                 if(icon) { icon.classList.remove('bi-chevron-up'); icon.classList.add('bi-chevron-down'); }
            }

            const n = selectedObjects[0];

            // 1. Standard Properties (Name, Type, Color)
            document.getElementById("opt-obj-name").value = n.userData.name;
            document.getElementById("opt-d-type").value = n.userData.isHole ? "hole" : "solid";
            if(n.material) updateColorPicker(n.material.color);

            // =========================================================
            // 2. SHAPE SPECIFIC UI (SWITCH STATEMENT)
            // =========================================================

            // Clear container first
            container.innerHTML = "";

            if (n.userData.geoParams) {
                container.style.display = "block";

                switch (n.userData.geoParams.type) {

                    // --- CASE A: 3D TEXT ---
                    case 'text':
                        container.innerHTML += `
                            <div class="mb-2">
                                <label class="small fw-bold">Text Content</label>
                                <input type="text" class="form-control form-control-sm" value="${n.userData.geoParams.text}" id="prop-text-input">
                            </div>`;

                        container.innerHTML += `
                            <div class="d-flex justify-content-between align-items-center mb-1">
                                <span class="small text-muted">Bend (Auto)</span>
                                <input type="range" class="form-range w-50" min="-0.2" max="0.2" step="0.005" value="${n.userData.geoParams.bend}" id="prop-text-bend">
                            </div>`;

                        container.innerHTML += `
                            <div class="d-grid gap-2 mt-2">
                                <button class="btn btn-sm btn-outline-primary" onclick="window.reSnapText()">
                                    <i class="bi bi-arrow-repeat"></i> Auto-Wrap to Surface
                                </button>
                            </div>`;

                        setTimeout(() => {
                            const txtIn = document.getElementById('prop-text-input');
                            const bendIn = document.getElementById('prop-text-bend');
                            if(txtIn) {
                                txtIn.onchange = (e) => {
                                    n.userData.geoParams.text = e.target.value;
                                    regenerateText(n);
                                    saveState();
                                };
                            }
                            if(bendIn) {
                                bendIn.oninput = (e) => {
                                    n.userData.geoParams.bend = parseFloat(e.target.value);
                                    regenerateText(n);
                                };
                                bendIn.onchange = () => saveState();
                            }
                        }, 0);
                        break;

                    // --- CASE B: THREADS ---
                    case 'thread':
                        const p = n.userData.geoParams;

                        // 1. Standard Type Dropdown
                        container.innerHTML += `
                            <div class="mb-2">
                                <label class="small fw-bold">Standard</label>
                                <select id="th-std" class="form-select form-select-sm">
                                    <option value="metric" ${p.std==='metric'?'selected':''}>Metric (ISO)</option>
                                    <option value="imperial" ${p.std==='imperial'?'selected':''}>Imperial (UNC)</option>
                                </select>
                            </div>
                        `;

                        // 2. Dynamic Size Dropdown
                        let options = "";
                        if(typeof THREAD_SPECS !== 'undefined' && THREAD_SPECS[p.std]) {
                            const currentLib = THREAD_SPECS[p.std];
                            for(let key in currentLib) {
                                const sel = (key === p.name) ? "selected" : "";
                                options += `<option value="${key}" ${sel}>${key}</option>`;
                            }
                        }

                        container.innerHTML += `
                            <div class="mb-2">
                                <label class="small fw-bold">Size</label>
                                <select id="th-size" class="form-select form-select-sm">${options}</select>
                            </div>
                        `;

                        // 3. Length Slider
                        container.innerHTML += `
                            <div class="d-flex justify-content-between align-items-center mb-1">
                                <span class="small text-muted">Length</span>
                                <input type="range" id="th-len" class="form-range w-50" min="2" max="100" step="1" value="${p.h}">
                                <span class="small fw-bold">${p.h}mm</span>
                            </div>
                        `;

                        // Listeners
                        setTimeout(() => {
                            const stdSel = document.getElementById('th-std');
                            const sizeSel = document.getElementById('th-size');
                            const lenIn = document.getElementById('th-len');

                            if(stdSel && sizeSel && typeof THREAD_SPECS !== 'undefined') {
                                stdSel.onchange = (e) => {
                                    const newStd = e.target.value;
                                    const firstKey = Object.keys(THREAD_SPECS[newStd])[0];
                                    const specs = THREAD_SPECS[newStd][firstKey];
                                    n.userData.geoParams.std = newStd;
                                    n.userData.geoParams.name = firstKey;
                                    n.userData.geoParams.r = specs[0];
                                    n.userData.geoParams.p = specs[1];
                                    regenerateGeometry(n);
                                    updatePropertiesPanel();
                                    saveState();
                                };
                                sizeSel.onchange = (e) => {
                                    const key = e.target.value;
                                    const std = n.userData.geoParams.std;
                                    const specs = THREAD_SPECS[std][key];
                                    n.userData.geoParams.name = key;
                                    n.userData.geoParams.r = specs[0];
                                    n.userData.geoParams.p = specs[1];
                                    regenerateGeometry(n);
                                    saveState();
                                };
                            }

                            if(lenIn) {
                                lenIn.oninput = (e) => {
                                    n.userData.geoParams.h = parseFloat(e.target.value);
                                    e.target.nextElementSibling.innerText = e.target.value + "mm";
                                    regenerateGeometry(n);
                                };
                                lenIn.onchange = () => saveState();
                            }
                        }, 0);
                        break;

                    // --- CASE C: STANDARD SHAPES (Cube, Cylinder, etc) ---
                    default:
                        updateParametricUI(n);
                        break;
                }

                // --- ADDITION: BAKE BUTTON (For all parametric shapes) ---
                container.innerHTML += `
                <div class="border-top pt-2 mt-2">
                    <button class="btn btn-sm btn-outline-secondary w-100" onclick="window.subdivideObject()">
                        <i class="bi bi-grid-3x3"></i> Bake & Subdivide
                    </button>
                    <small class="text-muted" style="font-size:0.65rem">Converts shape to raw mesh</small>
                </div>`;

            } else {
                // --- ADDITION: RAW MESH UI (Imported/Merged) ---
                container.style.display = "block";
                const vertCount = n.geometry.attributes.position.count;
                
                container.innerHTML += `
                <div class="mb-2">
                    <div class="small fw-bold text-muted"><i class="bi bi-heptagon-half"></i> Mesh Data</div>
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <span class="small text-muted">Vertices:</span>
                        <span class="small fw-bold">${vertCount.toLocaleString()}</span>
                    </div>
                    
                    <label class="small fw-bold mb-1">Resolution</label>
                    <button class="btn btn-sm btn-primary w-100 mb-1" onclick="window.subdivideObject()">
                        <i class="bi bi-grid-3x3"></i> Increase (x4)
                    </button>
                    <small class="text-muted d-block lh-1" style="font-size:0.7rem">
                        Adds detail for Shrink Wrap / Molding.
                    </small>
                </div>`;
            }

            // =========================================================

            // 3. Add Chamfer / Smoothness Slider
            // (Shared logic for Box, Straight Extrusion, or Raw Mesh)
            const isParametric = !!n.userData.geoParams;
            const isBox = isParametric && n.userData.geoParams.type === 'box';
            const isStraightExtrusion = isParametric &&
                (n.userData.geoParams.type === 'cylinder' || n.userData.geoParams.type === 'wedge') &&
                Math.abs(n.userData.geoParams.rt - n.userData.geoParams.rb) < 0.1;
            const isMerged = !isParametric; // Raw mesh

            if (isBox || isStraightExtrusion || isMerged) {
                let currentVal = 0;
                if (isParametric) {
                    currentVal = n.userData.geoParams.r || n.userData.geoParams.chamfer || 0;
                } else {
                    currentVal = n.material.flatShading ? 0 : 1;
                }

                const maxVal = isParametric ? 5 : 1;
                const step = isParametric ? 0.1 : 1;
                const label = isParametric ? "Edge Rounding" : "Smooth Edges";

                const div = document.createElement("div");
                div.className = "d-flex justify-content-between align-items-center mb-1 mt-2 border-top pt-2";
                div.innerHTML = `
                    <span class="small fw-bold">${label}</span>
                    <input type="range" class="form-range w-50" min="0" max="${maxVal}" step="${step}" value="${currentVal}">
                `;

                div.querySelector("input").oninput = (e) => window.updateSmoothness(parseFloat(e.target.value));
                container.appendChild(div);
                container.style.display = "block";
            }

            // 4. Update Transform Inputs
            const box = new THREE.Box3().setFromObject(n);
            const size = box.getSize(new THREE.Vector3());

            document.getElementById("opt-sz-x").value = Math.round(size.x);
            document.getElementById("opt-sz-y").value = Math.round(size.y);
            document.getElementById("opt-sz-z").value = Math.round(size.z);

            const r = n.rotation;
            document.getElementById("opt-rot-x").value = Math.round(r.x * (180/Math.PI));
            document.getElementById("opt-rot-y").value = Math.round(r.y * (180/Math.PI));
            document.getElementById("opt-rot-z").value = Math.round(r.z * (180/Math.PI));

        } else {
            panel.style.display = "none";
        }
    };

    window.updateObjectName = e => { if(selectedObjects.length===1) { selectedObjects[0].userData.name = e; updateObjectList(); saveState(); } };
    window.dUpdMat = e => { const t = e==="hole"; selectedObjects.forEach(n => { n.userData.isHole = t; n.material.transparent = t; n.material.opacity = t ? 0.5 : 1; }); saveState(); };
    const buildColorPicker = () => { const e = ["#0d6efd", "#6c757d", "#198754", "#dc3545", "#ffc107", "#0dcaf0", "#212529", "#f8f9fa"]; document.getElementById("color-picker").innerHTML = e.map(c => `<div class="color-option" style="background:${c}" data-color="${c}" onclick="window.setObjectColor('${c}')"></div>`).join(''); };
    window.setObjectColor = c => { const col = new THREE.Color(c); selectedObjects.forEach(o => o.material.color = col); updateColorPicker(col); saveState(); };
    const updateColorPicker = e => { const t = e.getHexString().toLowerCase(); document.querySelectorAll(".color-option").forEach(el => el.classList.toggle("selected", el.dataset.color.includes(t))); };


    window.selectObject = (obj, multi = false) => {
        // 1. Clear previous selection if not multi-select
        if (!multi) {
            selectedObjects.forEach(o => { if(o.material) o.material.emissive.setHex(0); });
            selectedObjects = [];
            document.querySelectorAll(".object-list-item").forEach(el => el.classList.remove("selected"));
        }

        // 2. Add new object to selection
        if (obj) {
            if (selectedObjects.includes(obj)) {
                if (multi) {
                    // Toggle off if already selected
                    selectedObjects = selectedObjects.filter(o => o !== obj);
                    if(obj.material) obj.material.emissive.setHex(0);
                }
            } else {
                selectedObjects.push(obj);
                // Highlight
                if(obj.material && !obj.userData.isRuler) obj.material.emissive.setHex(MESH_HIGHLIGHT_COLOR);
                // Highlight in list
                if(obj.userData.name) {
                    const el = document.getElementById(obj.uuid);
                    if(el) el.classList.add("selected");
                }
            }
        }

        // 3. Attach/Detach Gizmo (TransformControls)
        if (selectedObjects.length === 1) {
            tCtrl.attach(selectedObjects[0]);
            // If selecting the ruler, default to move mode
            if(selectedObjects[0].userData.isRuler) tCtrl.setMode('translate');

            updateLiftConePos();
            updateTinkerLabels();
        } else {
            tCtrl.detach();
            updateLiftConePos();
            // Clear dimensions labels
            activeLabels.forEach(l => scene.remove(l));
            activeLabels.length = 0;
            while(schematicGroup.children.length > 0){ schematicGroup.remove(schematicGroup.children[0]); }
        }

        // 4. Update UI
        updatePropertiesPanel();
        updateObjectList();

        // 5. Force Render (Important for responsiveness)
        window.requestRender();
    };
// --- LIST INTERACTION FUNCTIONS ---

    // This function needs to be explicitly attached to 'window' so the HTML onclick can access it.
    window.selectObjectFromList = (uuid) => {
        const t = scene.getObjectByProperty("uuid", uuid);
        if(t) window.selectObject(t); // Also ensure selectObject is called with window prefix
    };

    // This one you already have correctly prefixed
    window.toggleMergeStatus = uuid => {
        const t = scene.getObjectByProperty("uuid", uuid);
        if(t) {
            t.userData.markForMerge = !t.userData.markForMerge;
            updateMergeButton();
        }
    };

    const updateObjectList = () => {
        const list = document.getElementById("object-list"); list.innerHTML = "";
        scene.children.filter(e => e.userData.name).forEach(t => {
            const li = document.createElement("li"); li.className = `object-list-item ${selectedObjects.includes(t)?'selected':''}`;
            // This is where you call the window-prefixed function
            li.onclick = () => window.selectObjectFromList(t.uuid);
            li.innerHTML = `<input type="checkbox" class="form-check-input me-2" ${t.userData.markForMerge?'checked':''} onclick="event.stopPropagation(); window.toggleMergeStatus('${t.uuid}')"> <span>${t.userData.name}</span>`;
            list.appendChild(li);
        });
        updateMergeButton();

        // Toggle Unmerge Button
        const unmergeBtn = document.getElementById('unmerge-btn');
        if (selectedObjects.length === 1 && selectedObjects[0].userData.mergeHistory) {
            unmergeBtn.style.display = 'inline-block';
        } else {
            unmergeBtn.style.display = 'none';
        }
    };

    const updateMergeButton = () => {
        document.getElementById("merge-btn").innerText = `Merge (${scene.children.filter(e => e.userData.markForMerge).length})`;
    };
function cleanObject(obj) {
        if (!obj) return;

        // Dispose Geometry
        if (obj.geometry) obj.geometry.dispose();

        // Dispose Material
        if (obj.material) {
            // Handle array of materials
            if (Array.isArray(obj.material)) {
                obj.material.forEach(m => m.dispose());
            } else {
                obj.material.dispose();
            }
        }

        // Recursively clean children
        if (obj.children) {
            obj.children.forEach(c => cleanObject(c));
        }
    }

    window.dDel = () => {
        selectedObjects.forEach(e => {
            scene.remove(e);
            cleanObject(e); // <--- CLEAN GPU MEMORY
        });
        selectObject(null);
        updateObjectList();
        saveState();
        window.requestRender(); // Request frame update
    };

    window.dDelAll = () => {
        const toRemove = scene.children.filter(e => e.isMesh && !e.userData.isRuler && e !== liftCone);
        toRemove.forEach(e => {
            scene.remove(e);
            cleanObject(e); // <--- CLEAN GPU MEMORY
        });
        selectObject(null);
        updateObjectList();
        saveState();
        window.requestRender();
    };
    window.dDuplicate = () => {
        let targets = selectedObjects.length > 0 ? selectedObjects : scene.children.filter(e => e.userData.markForMerge && e.isMesh);
        if(!targets.length) return alert("Select object(s).");
        const newSel = [];
        targets.forEach(obj => {
            const clone = obj.clone();
            if(clone.material) clone.material = obj.material.clone();
            clone.material.emissive.setHex(0);
            clone.position.add(new THREE.Vector3(10, 0, 0));
            clone.userData = JSON.parse(JSON.stringify(obj.userData));
            clone.userData.name = obj.userData.name + " (Copy)";
            clone.userData.markForMerge = false;
            // Clear history on copy to avoid giant files? No, keep it so copies are editable
            // clone.userData.mergeHistory = undefined;
            scene.add(clone); newSel.push(clone);
        });
        selectObject(null); newSel.forEach(o=>selectObject(o, true)); saveState();
    };

    // --- REVISED MERGE LOGIC WITH HISTORY ---
window.dMerge = () => {
        const marked = selectedObjects.length > 1 ? selectedObjects : scene.children.filter(e => e.userData.markForMerge && e.isMesh && !e.userData.isRuler);
        if (marked.length < 2) return alert("Check 2+ boxes or Select 2+ objects.");
        const solids = marked.filter(e => !e.userData.isHole);
        if (!solids.length) return alert("Need 1 solid.");

        // 1. Serialize Ingredients (SAFE MODE)
        // We must apply the same "Swap to Box" logic here, or unmerging will crash
        const historyData = marked.map(obj => {
            if (obj.userData.geoParams && obj.userData.geoParams.type === 'text') {
                const clone = obj.clone();
                clone.geometry = new THREE.BoxGeometry(1, 1, 1);
                return clone.toJSON();
            }
            return obj.toJSON();
        });

        const ev = new Evaluator();
        const brush = mesh => {
            const b = new Brush(prepareCSG(mesh.geometry));
            b.position.copy(mesh.position); b.rotation.copy(mesh.rotation); b.scale.copy(mesh.scale);
            b.updateMatrixWorld(); return b;
        };
        let res = brush(solids[0]);
        for (let i = 1; i < solids.length; i++) res = ev.evaluate(res, brush(solids[i]), ADDITION);
        marked.filter(e => e.userData.isHole).forEach(h => res = ev.evaluate(res, brush(h), SUBTRACTION));

        const geo = res.geometry; geo.computeBoundingBox(); const c = geo.boundingBox.getCenter(new THREE.Vector3()); geo.translate(-c.x, -c.y, -c.z);

        const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: 0x0d6efd }));
        mesh.position.copy(c);

        // 2. Store Ingredients in UserData
        mesh.userData = {
            name: "Merged Part",
            isHole: false,
            mergeHistory: historyData
        };

        // Remove old objects
        marked.forEach(e => scene.remove(e));
        scene.add(mesh);
        selectObject(mesh);
        saveState();
    };

    // --- NEW UNMERGE LOGIC ---
window.dUnmerge = () => {
        if (selectedObjects.length !== 1) return;
        const obj = selectedObjects[0];

        if (!obj.userData.mergeHistory) return alert("This object has no merge history.");

        const loader = new THREE.ObjectLoader();
        const newObjects = [];

        obj.userData.mergeHistory.forEach(jsonData => {
            const restoredMesh = loader.parse(jsonData);

            // FIX: Ensure boolean value for transparency
            const isHole = !!restoredMesh.userData.isHole;

            restoredMesh.material = new THREE.MeshStandardMaterial({
                color: restoredMesh.material.color,
                roughness: 0.4, metalness: 0.2,
                transparent: isHole,
                opacity: isHole ? 0.5 : 1.0,
                wireframe: appSettings.wireframe
            });

            if (restoredMesh.userData.geoParams) {
                if (restoredMesh.userData.geoParams.type === 'text') {
                    regenerateText(restoredMesh);
                } else {
                    regenerateGeometry(restoredMesh);
                }
            }

            scene.add(restoredMesh);
            newObjects.push(restoredMesh);
        });

        scene.remove(obj);
        cleanObject(obj);

        selectObject(null);
        newObjects.forEach(o => selectObject(o, true));
        saveState();
    };
// --- HELPER: Fixes Crash by ensuring UVs and Normals exist ---
    function ensureCSGCompatible(geometry) {
        // 1. Merge to ensure watertightness (needed for ConvexGeometry)
        let geo = mergeVertices(geometry, 0.001);
        
        // 2. Compute Normals if missing
        geo.computeVertexNormals();
        
        // 3. Add Dummy UVs if missing (Fixes 'aAttr is undefined' crash)
        if (!geo.attributes.uv) {
            const count = geo.attributes.position.count;
            const uvs = new Float32Array(count * 2);
            // Just fill with 0, we don't need textures on the cut surface usually
            geo.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
        }
        
        return geo;
    }

window.dShell = () => {
        if (selectedObjects.length !== 1) return alert("Select exactly 1 object.");
        const obj = selectedObjects[0];

        // --- STEP 1: MODE CHECK ---
        if (!isShellSelectMode) {
            const useFaceMode = confirm(
                "Hollow / Shell Options:\n\n" +
                "OK = Select Custom Faces (Multi-Select, Toggle)\n" +
                "CANCEL = Standard Z-Axis (Auto Tube or Closed Hollow)"
            );

            if (useFaceMode) {
                isShellSelectMode = true;
                shellMarkers = [];
                document.body.style.cursor = "crosshair";
                const btn = document.querySelector('button[onclick="window.dShell()"]');
                if(btn) btn.classList.add('active-tool');
                updateShellStatus();
                return; 
            }
        }

        // --- STEP 2: GATHER PARAMETERS ---
        if (isShellSelectMode && shellMarkers.length === 0) {
             isShellSelectMode = false;
             document.body.style.cursor = "default";
             const btn = document.querySelector('button[onclick="window.dShell()"]');
             if(btn) btn.classList.remove('active-tool');
             document.getElementById("auto-save-status").style.opacity = 0;
             return;
        }
        
        // Bounds for validation
        if (!obj.geometry.boundingBox) obj.geometry.computeBoundingBox();
        const gBox = obj.geometry.boundingBox;
        const minDim = Math.min(
            (gBox.max.x - gBox.min.x) * obj.scale.x,
            (gBox.max.y - gBox.min.y) * obj.scale.y,
            (gBox.max.z - gBox.min.z) * obj.scale.z
        );

        // Customize Prompt
        const isAlreadyShell = !!obj.userData.isShell;
        const promptText = isAlreadyShell 
            ? "Cut Depth (Match your Wall Thickness):" 
            : "Wall Thickness (mm):";
            
        const input = prompt(promptText, obj.userData.lastThickness || "2");
        if (input === null) return; 
        
        const mm = parseFloat(input);
        if (isNaN(mm) || mm <= 0) return alert("Invalid thickness.");
        
        if (!isAlreadyShell && mm * 2 >= minDim) return alert(`Too thick! Max thickness is ${(minDim/2) - 0.1}mm`);

        const status = document.getElementById("auto-save-status");
        status.innerText = "Processing... (Please Wait)";
        status.style.opacity = 1;
        
        setTimeout(() => {
            const ev = new Evaluator();
            
            // Outer Brush
            const bOut = new Brush(prepareCSG(obj.geometry));
            bOut.position.copy(obj.position);
            bOut.rotation.copy(obj.rotation);
            bOut.scale.copy(obj.scale);
            bOut.updateMatrixWorld();

            let result;

            // --- FUNCTION TO GENERATE PLUGS (The Cutters) ---
            const createPlugs = () => {
                let combinedPlug = null;
                shellMarkers.forEach(marker => {
                    // 1. Get Original Vertices
                    const rawVerts = [];
                    const posAttr = marker.geometry.attributes.position;
                    for(let i=0; i<posAttr.count; i++) {
                        rawVerts.push(new THREE.Vector3().fromBufferAttribute(posAttr, i));
                    }

                    // --- NEW: INFLATE THE FACE ---
                    // Calculate center of face
                    const center = new THREE.Vector3();
                    rawVerts.forEach(v => center.add(v));
                    center.divideScalar(rawVerts.length);

                    // Expand vertices outward from center by 5% to clean up edges
                    const expandedVerts = rawVerts.map(v => {
                        const dir = new THREE.Vector3().subVectors(v, center);
                        // Multiply by 1.05 to overcut edges by 5%
                        return center.clone().add(dir.multiplyScalar(1.05));
                    });

                    // 2. Create Inner Vertices (Project inward from the EXPANDED vertices)
                    const innerVerts = expandedVerts.map(v => {
                        const shift = marker.userData.worldNormal.clone().negate().multiplyScalar(mm + 0.5);
                        const localShift = shift.applyQuaternion(obj.quaternion.clone().invert());
                        return v.clone().add(localShift);
                    });

                    // 3. Convex Hull using expanded + inner
                    let plugGeo = new ConvexGeometry([...expandedVerts, ...innerVerts]);
                    
                    // 4. Ensure UVs/Normals exist
                    plugGeo = ensureCSGCompatible(plugGeo);

                    const plugBrush = new Brush(plugGeo);
                    plugBrush.position.copy(obj.position);
                    plugBrush.rotation.copy(obj.rotation);
                    plugBrush.scale.copy(obj.scale);
                    plugBrush.updateMatrixWorld();

                    combinedPlug = combinedPlug ? ev.evaluate(combinedPlug, plugBrush, ADDITION) : plugBrush;
                });
                return combinedPlug;
            };

            // =========================================================
            // SCENARIO A: ALREADY A SHELL -> JUST CUT FACES
            // =========================================================
            if (isShellSelectMode && isAlreadyShell) {
                const plugs = createPlugs();
                if(plugs) {
                    result = ev.evaluate(bOut, plugs, SUBTRACTION);
                } else {
                    result = bOut;
                }
            }
            
            // =========================================================
            // SCENARIO B: SOLID -> HOLLOW + CUT FACES (or Standard Tube)
            // =========================================================
            else {
                // 1. Create Inner Void Brush
                const bIn = new Brush(prepareCSG(obj.geometry));
                bIn.position.copy(obj.position);
                bIn.rotation.copy(obj.rotation);
                
                const dimX = (gBox.max.x - gBox.min.x) * obj.scale.x;
                const dimY = (gBox.max.y - gBox.min.y) * obj.scale.y;
                const dimZ = (gBox.max.z - gBox.min.z) * obj.scale.z;
                
                const ratX = (dimX - (mm * 2)) / dimX;
                const ratY = (dimY - (mm * 2)) / dimY;
                const ratZ = (dimZ - (mm * 2)) / dimZ;

                if (isShellSelectMode) {
                    // CUSTOM FACES
                    bIn.scale.set(obj.scale.x * ratX, obj.scale.y * ratY, obj.scale.z * ratZ);
                    bIn.updateMatrixWorld();
                    
                    const boxOut = new THREE.Box3().setFromObject(bOut);
                    const boxIn = new THREE.Box3().setFromObject(bIn);
                    const shift = new THREE.Vector3().subVectors(boxOut.getCenter(new THREE.Vector3()), boxIn.getCenter(new THREE.Vector3()));
                    bIn.position.add(shift);
                    bIn.updateMatrixWorld();

                    const plugs = createPlugs();
                    
                    let tempRes = ev.evaluate(bOut, bIn, SUBTRACTION);
                    if(plugs) result = ev.evaluate(tempRes, plugs, SUBTRACTION);
                    else result = tempRes;

                } else {
                    // STANDARD TUBE
                    const isTube = confirm("Make it a Tube (Open Ends on Z-Axis)?\n\nOK = Yes (Tube)\nCancel = No (Hollow Inside)");
                    const finalRatZ = isTube ? (dimZ + 1.0) / dimZ : ratZ;

                    bIn.scale.set(obj.scale.x * ratX, obj.scale.y * ratY, obj.scale.z * finalRatZ);
                    bIn.updateMatrixWorld();

                    const boxOut = new THREE.Box3().setFromObject(bOut);
                    const boxIn = new THREE.Box3().setFromObject(bIn);
                    const shift = new THREE.Vector3().subVectors(boxOut.getCenter(new THREE.Vector3()), boxIn.getCenter(new THREE.Vector3()));
                    bIn.position.add(shift);
                    bIn.updateMatrixWorld();

                    result = ev.evaluate(bOut, bIn, SUBTRACTION);
                }
            }

            // --- FINALIZATION ---
            if (result && result.geometry) {
                const newMesh = new THREE.Mesh(result.geometry, obj.material.clone());
                newMesh.position.set(0,0,0);
                newMesh.rotation.set(0,0,0);
                newMesh.scale.set(1,1,1);
                newMesh.castShadow = true;
                newMesh.receiveShadow = true;

                newMesh.userData = {
                    ...obj.userData,
                    name: obj.userData.name + " (Shell)",
                    geoParams: null,
                    isShell: true,
                    lastThickness: mm
                };

                scene.remove(obj);
                scene.add(newMesh);
                selectObject(newMesh);
            }

            // Cleanup
            isShellSelectMode = false;
            shellMarkers.forEach(m => { scene.remove(m); m.geometry.dispose(); });
            shellMarkers = [];
            while(faceMarkerGroup.children.length > 0) faceMarkerGroup.remove(faceMarkerGroup.children[0]);
            
            document.body.style.cursor = "default";
            const btn = document.querySelector('button[onclick="window.dShell()"]');
            if(btn) btn.classList.remove('active-tool');
            
            document.getElementById("auto-save-status").style.opacity = 0;
            saveState();
        }, 50);
    };

window.toggleRulerMode = () => {
    // Toggle State
    rulerMode = (rulerMode === 'endpoint') ? 'midpoint' : 'endpoint';

    // Update UI Button
    const btn = document.getElementById('btn-ruler-mode');
    const icon = btn.querySelector('i');

    if(rulerMode === 'midpoint') {
        btn.title = "Mode: Midpoint";
        icon.className = "bi bi-align-center"; // Bootstrap icon for center
        btn.classList.add("text-primary");
    } else {
        btn.title = "Mode: Endpoint";
        icon.className = "bi bi-arrows-collapse"; // Bootstrap icon for edges
        btn.classList.remove("text-primary");
    }

    // Refresh View
    updateTinkerLabels();
    window.requestRender();
};
// --- UPDATED LOFT FUNCTION ---
    window.dLoft = () => {
        // 1. STANDARD LOFT (Between 2+ whole objects)
        if (selectedObjects.length >= 2) {
            const points = [];
            selectedObjects.forEach(obj => {
                obj.updateMatrixWorld();
                const posAttr = obj.geometry.attributes.position;
                for(let i=0; i < posAttr.count; i++){
                    const vec = new THREE.Vector3().fromBufferAttribute(posAttr, i).applyMatrix4(obj.matrixWorld);
                    points.push(vec);
                }
            });

            if(points.length < 4) return alert("Not enough points to generate a solid.");

            // Calculate Center to normalize coordinates (helps accuracy)
            const centerBox = new THREE.Box3().setFromPoints(points);
            const center = centerBox.getCenter(new THREE.Vector3());
            const localPoints = points.map(p => p.clone().sub(center));

            // Generate Hull
            let geo = new ConvexGeometry(localPoints);

            // --- CRITICAL FIX FOR TUBE/SHELL ---
            // 1. Merge vertices to make it watertight (CSG requires this)
            geo = mergeVertices(geo, 0.001);
            // 2. Recompute normals for smooth shading and correct inside/outside detection
            geo.computeVertexNormals();
            // ------------------------------------

            const material = new THREE.MeshStandardMaterial({
                color: 0x0d6efd,
                roughness: 0.4,
                metalness: 0.2,
                wireframe: appSettings.wireframe
            });

            const mesh = new THREE.Mesh(geo, material);
            mesh.position.copy(center);
            mesh.userData = { isHole: false, name: "Loft Object" };

            // Ensure shadow capability
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            scene.add(mesh);
            selectObject(mesh);
            updateObjectList();
            saveState();
            return;
        }

        // 2. FACE LOFT MODE (Specific faces)
        if (!isFaceLoftMode) {
            // Enter Face Selection Mode
            isFaceLoftMode = true;
            selectObject(null);
            document.body.style.cursor = "crosshair";

            // Highlight button
            const btn = document.querySelector('button[onclick="window.dLoft()"]');
            if(btn) btn.classList.add('active-tool');

            // Notification
            const status = document.getElementById("auto-save-status");
            status.innerText = "Select 2 Faces, then click Loft again";
            status.style.opacity = 1;

        } else {
            // Execute Loft
            if (selectedFacesData.length < 2) {
                alert("Please select at least 2 faces to connect.");
                return;
            }

            let allPoints = [];
            selectedFacesData.forEach(data => allPoints.push(...data.points));

            try {
                // Center calculations
                const centerBox = new THREE.Box3().setFromPoints(allPoints);
                const center = centerBox.getCenter(new THREE.Vector3());
                const localPoints = allPoints.map(p => p.clone().sub(center));

                let geo = new ConvexGeometry(localPoints);

                // --- CRITICAL FIX FOR TUBE/SHELL ---
                // ConvexGeometry creates flat shading with split vertices.
                // We must merge them to allow the Shell algorithm to work.
                geo.deleteAttribute('normal'); // Remove old flat normals
                geo.deleteAttribute('uv');     // Remove bad UVs

                geo = mergeVertices(geo, 0.001); // Weld vertices
                geo.computeVertexNormals();      // Smooth normals
                // ------------------------------------

                // Add basic UVs so textures don't crash
                if (!geo.attributes.uv) {
                    const count = geo.attributes.position.count;
                    geo.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(count * 2), 2));
                }

                const material = new THREE.MeshStandardMaterial({
                    color: 0x0d6efd,
                    roughness: 0.4,
                    metalness: 0.2,
                    wireframe: appSettings.wireframe
                });

                const mesh = new THREE.Mesh(geo, material);
                mesh.position.copy(center);
                mesh.userData = { isHole: false, name: "Face Loft" };

                mesh.castShadow = true;
                mesh.receiveShadow = true;

                scene.add(mesh);
                selectObject(mesh);
                updateObjectList();

            } catch (e) {
                console.error(e);
                alert("Could not generate geometry. Try faces that face each other.");
            }

            // Cleanup Mode
            isFaceLoftMode = false;
            selectedFacesData = [];
            while(faceMarkerGroup.children.length > 0){
                faceMarkerGroup.remove(faceMarkerGroup.children[0]);
            }
            document.body.style.cursor = "default";
            const btn = document.querySelector('button[onclick="window.dLoft()"]');
            if(btn) btn.classList.remove('active-tool');

            const status = document.getElementById("auto-save-status");
            status.innerText = "Saved";
            status.style.opacity = 0;

            saveState();
        }
    };

window.dImportFile = function(input) {
        if (!input.files || input.files.length === 0) return;

        const files = Array.from(input.files);
        const fileMap = {};

        // 1. Create Blob URLs for every file and map them by name
        files.forEach(f => {
            fileMap[f.name] = URL.createObjectURL(f);
        });

        // 2. Setup the Loading Manager to redirect network requests to our Blobs
        const manager = new THREE.LoadingManager();
        manager.setURLModifier((url) => {
            // If Three.js asks for "folder/texture.jpg", we strip path and look for "texture.jpg" in our list
            const fileName = url.replace(/^.*[\\\/]/, '');
            return fileMap[fileName] || url;
        });

        // 3. Helper for Scaling (Same as before)
        const checkAndFixScale = (geometry) => {
            geometry.computeBoundingBox();
            const size = new THREE.Vector3();
            geometry.boundingBox.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            if (maxDim < 2.0 && maxDim > 0.0001) {
                console.log("Detected AR Scale. Fixing...");
                geometry.scale(1000, 1000, 1000);
            }
            return geometry;
        };

        // 4. Find the Main Model File
        const mainFile = files.find(f => /\.(obj|stl|gltf|glb|usdz)$/i.test(f.name));
        if (!mainFile) return alert("No model file (.obj, .stl, .glb) found in selection.");

        const ext = mainFile.name.split('.').pop().toLowerCase();
        const url = fileMap[mainFile.name]; // Get the blob URL for the main file

        // 5. Load based on extension
        if (ext === 'obj') {
            // Check if there is a matching MTL file in the selection
            const mtlFile = files.find(f => f.name.endsWith('.mtl'));

            const loadObj = (materials = null) => {
                const loader = new OBJLoader(manager);
                if(materials) {
                    loader.setMaterials(materials);
                }
                loader.load(url, (objGroup) => {
                    objGroup.traverse(child => {
                        if (child.isMesh) buildAndAddMesh(checkAndFixScale(child.geometry), mainFile.name, null, child.material);
                    });
                });
            };

            if (mtlFile) {
                // Load MTL first, then OBJ
                const mtlLoader = new MTLLoader(manager);
                mtlLoader.load(fileMap[mtlFile.name], (materials) => {
                    materials.preload();
                    loadObj(materials);
                });
            } else {
                // Just load OBJ
                loadObj();
            }
        }
        else if (ext === 'stl') {
            new STLLoader(manager).load(url, (geo) => {
                buildAndAddMesh(checkAndFixScale(geo), mainFile.name, null, null);
            });
        }
        else if (ext === 'gltf' || ext === 'glb') {
            new GLTFLoader(manager).load(url, (gltf) => {
                gltf.scene.traverse(child => {
                    if (child.isMesh) buildAndAddMesh(checkAndFixScale(child.geometry), mainFile.name, null, child.material);
                });
            });
        }
        else if (ext === 'usdz') {
            // USDZ usually self-contained, logic remains similar but uses the Blob URL
            // Note: USDZLoader doesn't fully support LoadingManager in all versions,
            // but usually works fine for textures embedded in the archive.
            const reader = new FileReader();
            reader.onload = (e) => {
                const group = new USDZLoader().parse(e.target.result);
                group.traverse(child => {
                    if (child.isMesh) buildAndAddMesh(checkAndFixScale(child.geometry), mainFile.name, null, child.material);
                });
            };
            reader.readAsArrayBuffer(mainFile);
        }

        // Cleanup: Reset input so you can select the same file again
        input.value = '';
    };

    window.triggerExport = () => window.downloadExport(document.getElementById("export-format").value);

    window.downloadExport = async fmt => {
            // 0. Project File Export
            if (fmt === 'json') {
                const rawData = createSnapshot(); // This is the compressed state
                // We download it as a raw file
                const blob = new Blob([rawData], { type: "application/octet-stream" });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = (document.getElementById("d-name").value || "Project") + ".tinker";
                a.click();
                return;
            }

            // 1. Collect Objects
            const l = selectedObjects.length ? selectedObjects : scene.children.filter(c => c.isMesh && !c.userData.isRuler && c !== liftCone && c.parent !== faceMarkerGroup);
            if(!l.length) return alert("Nothing to export");

            const g = new THREE.Group();
            l.forEach(o => g.add(o.clone()));

            // --- AR SCALE LOGIC ---
            // Scale GLB and USDZ to Meters (0.001).
            // Keep STL, OBJ, and standard GLTF in Millimeters (1.0).
            if (fmt === 'usdz' || fmt === 'glb') {
                g.scale.set(0.001, 0.001, 0.001);
                g.updateMatrixWorld(true);
            }
            // ----------------------

            const name = (document.getElementById("d-name").value || "Design") + "." + fmt;
            const saveData = (b,n) => { const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download=n; a.click(); };

            if(fmt==='stl') saveData(new Blob([new STLExporter().parse(g, {binary:true})]), name);
            if(fmt==='obj') saveData(new Blob([new OBJExporter().parse(g)]), name);

            // GLTF (Text based JSON)
            if(fmt==='gltf') new GLTFExporter().parse(g, r=>saveData(new Blob([JSON.stringify(r)]), name));

            // GLB (Binary) - THE FIX IS HERE
            // Note the 3rd argument is an error handler, 4th is options
            if(fmt==='glb') {
                new GLTFExporter().parse(
                    g,
                    r => saveData(new Blob([r]), name),
                    (err) => console.error(err),
                    { binary: true }
                );
            }

            if(fmt==='usdz') { const e = new USDZExporter(); const u = await e.parse(g, { quickLookAR: true }); saveData(new Blob([u], { type: 'model/vnd.usdz+zip' }), name); }
        };

    // --- NEW: PROJECT LOADING ---
    window.loadProjectFile = function(input) {
        if (!input.files || input.files.length === 0) return;
        const file = input.files[0];

        const reader = new FileReader();
        reader.onload = function(e) {
            const buffer = new Uint8Array(e.target.result);
            try {
                loadSnapshot(buffer);
                // Reset history stack
                historyStack = [buffer];
                historyStep = 0;
                saveState();
                alert("Project Loaded Successfully!");
            } catch (err) {
                console.error(err);
                alert("Failed to load project file.");
            }
        };
        reader.readAsArrayBuffer(file);
        input.value = '';
    };

    function createRuler() {
        if(rulerGroup) scene.remove(rulerGroup);
        rulerGroup = new THREE.Group();
        rulerGroup.userData = { isRuler: true };

        // The L-Shape axes
        const len = 100;
        const matMain = new THREE.LineBasicMaterial({ color: 0x444444, linewidth: 2 });

        // X Axis line
        const xPts = [new THREE.Vector3(0,0,0), new THREE.Vector3(len,0,0)];
        rulerGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(xPts), matMain));

        // Y Axis line
        const yPts = [new THREE.Vector3(0,0,0), new THREE.Vector3(0,len,0)];
        rulerGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(yPts), matMain));

        // Ticks
        const matTick = new THREE.LineBasicMaterial({ color: 0x888888, transparent:true, opacity:0.5 });
        const ticksPts = [];
        for(let i=0; i<=len; i+=10) {
            // X-Axis Ticks
            ticksPts.push(new THREE.Vector3(i, 0, 0), new THREE.Vector3(i, -2, 0));
            // Y-Axis Ticks
            ticksPts.push(new THREE.Vector3(0, i, 0), new THREE.Vector3(-2, i, 0));
        }
        rulerGroup.add(new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(ticksPts), matTick));

        // Default Position (Bottom Left area)
        rulerGroup.position.set(-50, -50, 0.1);
        rulerGroup.visible = showRuler; // Sync with state
        scene.add(rulerGroup);
    }

    function updateLiftConePos() { if(selectedObjects.length===1 && !selectedObjects[0].userData.isRuler) { const b=new THREE.Box3().setFromObject(selectedObjects[0]); liftCone.position.set((b.min.x+b.max.x)/2, (b.min.y+b.max.y)/2, b.max.z+50); liftCone.visible=true; } else liftCone.visible=false; }
    function createLiftCone() { const g=new THREE.ConeGeometry(3,6,16); g.rotateX(Math.PI/2); liftCone=new THREE.Mesh(g,new THREE.MeshBasicMaterial({color:0x222222,transparent:true,opacity:0.8})); liftCone.visible=false; scene.add(liftCone); }
    function createRotationLabel() { rotLabelDiv=document.createElement('div'); rotLabelDiv.className='rot-label'; rotLabelObj=new CSS2DObject(rotLabelDiv); scene.add(rotLabelObj); }
    function updateRotationFeedback() { if(selectedObjects.length===1 && tCtrl.mode==='rotate' && tCtrl.dragging) { const r=selectedObjects[0].rotation; rotLabelDiv.innerText=`X:${Math.round(r.x*57.3)} Y:${Math.round(r.y*57.3)} Z:${Math.round(r.z*57.3)}`; rotLabelDiv.style.visibility='visible'; rotLabelObj.position.copy(selectedObjects[0].position); } else rotLabelDiv.style.visibility='hidden'; }
window.dMirror = (axis) => {
        if (selectedObjects.length === 0) return alert("Select an object to mirror.");

        const keepOriginal = document.getElementById('mirror-copy').checked;

        // Create a list of objects to process so we don't mess up the loop if we add new ones
        const targets = [...selectedObjects];

        // Deselect everything first so we can select the result later
        selectObject(null);

        const newSelection = [];

        targets.forEach(obj => {
            let targetObj = obj;

            // 1. DUPLICATE LOGIC
            if (keepOriginal) {
                targetObj = obj.clone();
                if (targetObj.material) targetObj.material = obj.material.clone();
                targetObj.material.emissive.setHex(0); // Reset highlight

                targetObj.userData = JSON.parse(JSON.stringify(obj.userData));
                targetObj.userData.name = obj.userData.name + " (Mirror)";
                targetObj.userData.markForMerge = false;

                scene.add(targetObj);
            }

            // 2. FLIP LOGIC (Invert Scale)
            // We use scale because rotating 180 is not a true mirror for asymmetric objects.
            if (axis === 'x') targetObj.scale.x *= -1;
            if (axis === 'y') targetObj.scale.y *= -1;
            if (axis === 'z') targetObj.scale.z *= -1;

            // 3. FLIP POSITION (If mirroring a group or offset object)
            // If we are keeping original, we usually want the mirror to appear "Next to" it.
            // But simple scale inversion happens in place.
            // If user wants to separate them, they can move the new one.

            // However, Three.js caches matrices. We must update.
            targetObj.updateMatrixWorld(true);

            // 4. FIX NORMALS (Optional but good practice)
            // Negative scale can sometimes invert face winding (making it look inside out).
            // Three.js handles this well usually, but if materials look weird, we set side to DoubleSide.
            if(targetObj.material) targetObj.material.side = THREE.DoubleSide;

            newSelection.push(targetObj);
        });

        // Select the result
        newSelection.forEach(o => selectObject(o, true));

        saveState();
        window.requestRender();
    };
    // --- UNDO / REDO / SAVE SYSTEM ---

// --- VACUUM MOLD TOOL ---
    window.dVacuum = () => {
        if (selectedObjects.length !== 1) return alert("Select the object (e.g., Headset) to mold over.");
        
        const targetObj = selectedObjects[0];
        
        // 1. Get Bounds of target
        const box = new THREE.Box3().setFromObject(targetObj);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());
        
        // 2. Define resolution (Higher = smoother curve, but slower)
        const segsX = 64; 
        const segsY = 64; 
        
        // 3. Create the "Clay" Block
        // We make it slightly larger (10%) than the object so it covers edges
        const clayGeo = new THREE.BoxGeometry(size.x * 1.1, size.y * 1.1, 20, segsX, segsY, 1);
        
        // 4. Position Clay Block ABOVE the object
        // We place the bottom of the block at the top of the object
        const clayMat = new THREE.MeshStandardMaterial({ 
            color: 0x0dcaf0, 
            roughness: 0.5,
            wireframe: appSettings.wireframe
        });
        const clayMesh = new THREE.Mesh(clayGeo, clayMat);
        
        // Align centers, but move Z up
        clayMesh.position.set(center.x, center.y, box.max.z + 10); // +10 is half height of block (20/2)
        
        // Update matrix to handle raycasting in world space
        clayMesh.updateMatrixWorld();
        targetObj.updateMatrixWorld();
        
        // 5. THE MOLDING PROCESS (Raycasting)
        const posAttr = clayGeo.attributes.position;
        const vertex = new THREE.Vector3();
        const raycaster = new THREE.Raycaster();
        const downDir = new THREE.Vector3(0, 0, -1);
        
        // Tolerance/Clearance (0.5mm gap so it fits easily)
        const clearance = 0.5; 
        
        let hitCount = 0;

        for (let i = 0; i < posAttr.count; i++) {
            vertex.fromBufferAttribute(posAttr, i);
            
            // Convert local vertex to world space
            vertex.applyMatrix4(clayMesh.matrixWorld);
            
            // Only modify the BOTTOM face of the block
            // Local Z of BoxGeometry bottom face is -height/2 (-10 in this case)
            // But we are in world space now.
            // Easier check: Is this vertex below the centerline of the block?
            const localZ = posAttr.getZ(i);
            
            if (localZ < -9.0) { // If it's a bottom vertex
                // Cast ray DOWN from this vertex position
                // Start ray slightly above vertex to ensure no self-intersection issues
                raycaster.set(new THREE.Vector3(vertex.x, vertex.y, box.max.z + 1), downDir);
                
                const intersects = raycaster.intersectObject(targetObj, true); // True = recursive check
                
                if (intersects.length > 0) {
                    // We hit the headset!
                    const hit = intersects[0];
                    
                    // Move the vertex to the hit point (+ clearance)
                    // We need to convert the Hit Point (World) back to Local Space of Clay
                    const localHit = clayMesh.worldToLocal(hit.point.clone());
                    
                    // Apply clearance (move up slightly)
                    posAttr.setZ(i, localHit.z + clearance);
                    hitCount++;
                } else {
                    // Missed the object (part of the box overhanging the void)
                    // Drop it down to the object's bottom level to create a "wall"
                    // Or keep it flat? Let's drop it slightly below the hit plane for a skirt effect
                    const floorLevel = clayMesh.worldToLocal(new THREE.Vector3(0,0, box.min.z)).z;
                    posAttr.setZ(i, floorLevel);
                }
            }
        }
        
        if(hitCount === 0) return alert("Mold failed. Ensure object is directly below the mold area.");

        // 6. Finish Up
        clayGeo.computeVertexNormals(); // Recalculate lighting
        
        clayMesh.userData = { 
            name: targetObj.userData.name + " (Mold)",
            isHole: false 
        };
        
        clayMesh.castShadow = true;
        clayMesh.receiveShadow = true;
        
        scene.add(clayMesh);
        selectObject(clayMesh);
        saveState();
        
        // Optional: Hide original to show result
        // targetObj.visible = false; 
    };

// --- SHRINK WRAP (SNAP TO SURFACE) ---
    window.dShrinkWrap = () => {
        // 1. Validation
        if (selectedObjects.length !== 2) {
            return alert("Select 2 objects:\n1. The Strap/Shape (to be deformed)\n2. The Headset (Target surface)");
        }

        // We assume the last selected object is the Target (Headset), 
        // and the first one is the Strap (Source).
        // (Based on typical click order: Click Strap, Shift+Click Headset)
        const targetObj = selectedObjects[1]; // The Headset
        const sourceObj = selectedObjects[0]; // The Strap

        // Safety check: Don't deform the complex headset by accident
        if (targetObj.geometry.attributes.position.count < sourceObj.geometry.attributes.position.count) {
             const confirmSwap = confirm("Warning: You are shrinking the complex object onto the simple one.\n\nSwap target and source?");
             if(confirmSwap) {
                 // Swap them
                 window.selectObject(null);
                 window.selectObject(targetObj, true); // Select Strap 
                 window.selectObject(sourceObj, true); // Select Headset
                 window.dShrinkWrap();
                 return;
             }
        }
        
        // 2. Settings
        const offsetInput = prompt("Offset distance (mm)?\n(Gap between headset and strap)", "0.5");
        if(offsetInput === null) return;
        const offset = parseFloat(offsetInput);

        // 3. Prepare Geometry
        // We need to make sure the Source (Strap) has enough vertices to bend.
        // If it's a simple box, it won't curve. 
        // Let's verify or auto-subdivide (simplified approach: just warn/proceed).
        const sourceGeo = sourceObj.geometry.clone();
        // Convert to world space to match target
        sourceGeo.applyMatrix4(sourceObj.matrixWorld);

        // 4. Build BVH for Target (High Speed Geometry Search)
        // This creates a spatial index of the headset so we can find closest points instantly.
        const targetGeo = targetObj.geometry.clone();
        targetGeo.applyMatrix4(targetObj.matrixWorld);
        const bvh = new MeshBVH(targetGeo);

        // 5. The Algorithm
        const posAttr = sourceGeo.attributes.position;
        const tempVec = new THREE.Vector3();
        const targetPoint = new THREE.Vector3();
        const targetNormal = new THREE.Vector3();
        const matrixWorldInv = sourceObj.matrixWorld.clone().invert();

        for (let i = 0; i < posAttr.count; i++) {
            // Get current vertex of strap (in World Space)
            tempVec.fromBufferAttribute(posAttr, i);

            // Find the closest point on the Headset
            const hit = bvh.closestPointToPoint(tempVec);

            if (hit) {
                // Get the point and the normal at that point
                targetPoint.copy(hit.point);
                
                // If the target has normals, use them to push outward
                // (Note: BVH hit gives us point and distance, getting interpolated normal is harder)
                // Simpler approach: Calculate vector from Target Center to Hit Point? 
                // No, complex shapes need face normals.
                
                // Let's approximate normal by vector from Hit -> Old Source Position?
                // Or better: Use the target geometry normal if available?
                // BVH return structure depends on version. Let's use a simpler offset method:
                // Move vertex to Hit Point.
                
                // apply offset: We move it slightly *away* from the surface.
                // We can approximate the "Out" direction by (SourcePos - HitPos) normalized.
                // If the strap was "outside" the headset, this vector points out.
                const normal = new THREE.Vector3().subVectors(tempVec, targetPoint).normalize();
                
                // If they were overlapping, normal might be zero or weird. 
                // Fallback: Use Z-up or verify distance.
                if(normal.lengthSq() < 0.001) normal.set(0,0,1);

                // New Position = Hit Point + (Normal * Offset)
                tempVec.copy(targetPoint).add(normal.multiplyScalar(offset));

                // Write back
                posAttr.setXYZ(i, tempVec.x, tempVec.y, tempVec.z);
            }
        }

        // 6. Finish
        // Convert back to Local Space of the Source Object
        sourceGeo.applyMatrix4(matrixWorldInv);
        sourceGeo.computeVertexNormals();

        // Update the mesh
        sourceObj.geometry.dispose();
        sourceObj.geometry = sourceGeo;

        window.requestRender();
        saveState();
        alert("Shrink wrap complete! Note: If the shape looks jagged, try starting with a shape that has more 'Segments' (Resolution).");
    };
function createSnapshot() {
        const l = [];
        scene.children.forEach(c => {
            // FIX: Added !c.userData.isGhost so we don't save the placement tool
            if (c.isMesh && !c.userData.isRuler && c !== liftCone && c.userData.name !== "FaceMarker" && !c.userData.isGhost) {
                l.push(c);
            }
        });

        const d = { metadata: { type: 'Save' }, scene: new THREE.Scene().toJSON() };

        const childrenJSON = l.map(c => {
            // Swap Text for Box during save to prevent crash
            if (c.userData.geoParams && c.userData.geoParams.type === 'text') {
                const clone = c.clone();
                clone.geometry = new THREE.BoxGeometry(1, 1, 1);
                return clone.toJSON();
            }
            return c.toJSON();
        });

        d.scene.object = { children: childrenJSON };
        const jsonStr = JSON.stringify(d);

        const encoder = new TextEncoder();
        const data = encoder.encode(jsonStr);

        if (zstdReady) {
            return compress(data, 10);
        } else {
            return data;
        }
    }
// --- INCREASE MESH RESOLUTION (FIXED SMOOTHING) ---
    window.subdivideObject = () => {
        if (selectedObjects.length !== 1) return;
        const obj = selectedObjects[0];
        
        const count = obj.geometry.attributes.position.count;
        if (count > 100000) {
            if (!confirm(`This mesh already has ${count} vertices. Subdividing might freeze your browser. Continue?`)) return;
        }

        // 1. Prepare Geometry
        let geo = obj.geometry.clone();
        if (geo.index) geo = geo.toNonIndexed();
        
        const pos = geo.attributes.position;
        const newPos = [];
        const newUVs = []; 
        const uvs = geo.attributes.uv;

        // 2. Split Triangles (1 -> 4)
        for (let i = 0; i < pos.count; i += 3) {
            const v1 = new THREE.Vector3().fromBufferAttribute(pos, i);
            const v2 = new THREE.Vector3().fromBufferAttribute(pos, i+1);
            const v3 = new THREE.Vector3().fromBufferAttribute(pos, i+2);
            
            const m1 = new THREE.Vector3().addVectors(v1, v2).multiplyScalar(0.5);
            const m2 = new THREE.Vector3().addVectors(v2, v3).multiplyScalar(0.5);
            const m3 = new THREE.Vector3().addVectors(v3, v1).multiplyScalar(0.5);
            
            const pushTri = (a, b, c) => {
                newPos.push(a.x, a.y, a.z);
                newPos.push(b.x, b.y, b.z);
                newPos.push(c.x, c.y, c.z);
            };

            pushTri(v1, m1, m3);
            pushTri(m1, v2, m2);
            pushTri(m3, m2, v3);
            pushTri(m1, m2, m3);
            
            if (uvs) {
                 const uv1 = new THREE.Vector2().fromBufferAttribute(uvs, i);
                 const uv2 = new THREE.Vector2().fromBufferAttribute(uvs, i+1);
                 const uv3 = new THREE.Vector2().fromBufferAttribute(uvs, i+2);
                 const um1 = new THREE.Vector2().addVectors(uv1, uv2).multiplyScalar(0.5);
                 const um2 = new THREE.Vector2().addVectors(uv2, uv3).multiplyScalar(0.5);
                 const um3 = new THREE.Vector2().addVectors(uv3, uv1).multiplyScalar(0.5);
                 const pushUV = (a, b, c) => { newUVs.push(a.x, a.y, b.x, b.y, c.x, c.y); };
                 pushUV(uv1, um1, um3);
                 pushUV(um1, uv2, um2);
                 pushUV(um3, um2, uv3);
                 pushUV(um1, um2, um3);
            }
        }

        let newGeo = new THREE.BufferGeometry();
        newGeo.setAttribute('position', new THREE.Float32BufferAttribute(newPos, 3));
        if (newUVs.length > 0) newGeo.setAttribute('uv', new THREE.Float32BufferAttribute(newUVs, 2));
        
        // --- THE FIX: WELD VERTICES ---
        // This connects the split triangles back together so they share edges.
        // This allows 'computeVertexNormals' to smooth the shading.
        
        // Use the utility already imported at the top
        newGeo = mergeVertices(newGeo, 0.001); 
        newGeo.computeVertexNormals();

        // Update Object
        obj.geometry.dispose();
        obj.geometry = newGeo;
        
        // Ensure material is set to smooth
        if(obj.material) obj.material.flatShading = false;
        if(obj.material) obj.material.needsUpdate = true;

        if(obj.userData.geoParams) delete obj.userData.geoParams;

        window.requestRender();
        saveState();
        updatePropertiesPanel(); 
    };
function saveState() {
        // 1. Always update view when state changes (Fixes UI lag)
        window.requestRender();

        // 2. Stop immediately if we already know storage is full
        if (isStorageFull) {
            const status = document.getElementById("auto-save-status");
            status.innerText = "Storage Full - Auto-save Disabled";
            status.style.opacity = 1;
            status.style.background = "rgba(255, 0, 0, 0.6)"; // Red alert
            return;
        }

        if(!isUndoRedoAction) {
            if (historyStep < historyStack.length - 1) {
                historyStack = historyStack.slice(0, historyStep + 1);
            }
            const snapshot = createSnapshot();
            historyStack.push(snapshot);
            if(historyStack.length > MAX_HISTORY) { historyStack.shift(); } else { historyStep++; }
        }

        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(()=>{
            // Double check flag inside timeout
            if (isStorageFull) return;

            const currentSnapshot = historyStack[historyStep];
            if(!currentSnapshot) return;

            const b64 = uint8ToBase64(currentSnapshot);

            try {
                // TRY TO SAVE
                localStorage.setItem("3d_save", b64);

                // If successful:
                const el = document.getElementById("auto-save-status");
                el.innerText = "Saved";
                el.style.background = "rgba(0,0,0,0.6)";
                el.style.opacity = 1;
                setTimeout(()=>el.style.opacity=0, 2000);
                window.updateStorageUI();

            } catch (e) {
                // CATCH QUOTA ERROR
                if (e.name === 'QuotaExceededError' || e.code === 22) {
                    console.warn("Local Storage Full! Disabling Auto-save.");
                    isStorageFull = true; // <--- Disable future attempts

                    const el = document.getElementById("auto-save-status");
                    el.innerText = "Scene too big to Auto-save";
                    el.style.background = "rgba(220, 53, 69, 0.8)"; // Red
                    el.style.opacity = 1;
                    // Don't fade out immediately so user sees it
                    setTimeout(()=>el.style.opacity=0, 5000);

                    window.updateStorageUI(); // Update bar to show full
                }
            }
        }, 1000);
    }

function loadSnapshot(compressedData) {
        if (!compressedData) return;

        let jsonStr;
        if (zstdReady) {
            try {
                const decompressed = decompress(compressedData);
                const decoder = new TextDecoder();
                jsonStr = decoder.decode(decompressed);
            } catch (e) {
                try {
                    const decoder = new TextDecoder();
                    jsonStr = decoder.decode(compressedData);
                    JSON.parse(jsonStr);
                } catch (e2) {
                    console.error("Decompression failed", e);
                    return;
                }
            }
        } else {
            const decoder = new TextDecoder();
            jsonStr = decoder.decode(compressedData);
        }

        let data;
        try { data = JSON.parse(jsonStr); } catch (e) { return; }

        selectObject(null);
        scene.children.filter(c => c.isMesh && !c.userData.isRuler && c !== liftCone).forEach(c => scene.remove(c));

        const loader = new THREE.ObjectLoader();

        if (data.scene && data.scene.object && data.scene.object.children) {
            data.scene.object.children.forEach(childData => {
                try {
                    // Check if this is a ghost data before even parsing
                    if(childData.userData && childData.userData.isGhost) return;

                    const mesh = loader.parse(childData);

                    if (mesh.isMesh) {
                        // FIX: Ensure transparent is strictly true/false
                        const isHole = !!mesh.userData.isHole;

                        mesh.material = new THREE.MeshStandardMaterial({
                            color: mesh.material.color,
                            roughness: 0.5, metalness: 0.1,
                            transparent: isHole,
                            opacity: isHole ? 0.5 : 1,
                            wireframe: appSettings.wireframe
                        });

                        if (mesh.userData.geoParams && mesh.userData.geoParams.type === 'text') {
                            regenerateText(mesh);
                        }
                        else if (mesh.userData.geoParams) {
                            regenerateGeometry(mesh);
                        }

                        scene.add(mesh);
                    }
                } catch (err) {
                    console.warn("Skipping corrupted object:", err);
                }
            });
        }
        updateObjectList();
        window.requestRender();
    }

    // --- FIX: Robust Load Logic ---
    function loadFromStorage() {
        const rawData = localStorage.getItem("3d_save");
        if (!rawData) {
            // First time run
            window.dAdd('cube');
            return;
        }

        try {
            // 1. Try treating it as the NEW format (Base64 -> Binary -> Zstd)
            // base64ToUint8 throws immediately if string has invalid chars (like old JSON)
            const u8 = base64ToUint8(rawData);
            historyStack.push(u8);
            historyStep = 0;
            loadSnapshot(u8);
        } catch (e) {
            console.warn("Could not load as Zstd/Base64. Trying legacy JSON...", e);

            // 2. Fallback: Treat as OLD format (Plain JSON string)
            try {
                const legacyData = JSON.parse(rawData);
                // Convert to new format immediately so Undo stack works
                const jsonStr = JSON.stringify(legacyData);
                const encoder = new TextEncoder();
                const bytes = encoder.encode(jsonStr);

                // Compress if Zstd is ready, else use raw bytes
                const compressed = zstdReady ? compress(bytes, 10) : bytes;

                historyStack.push(compressed);
                historyStep = 0;

                // Load using the new binary data we just created
                loadSnapshot(compressed);

            } catch (jsonErr) {
                console.error("Total load failure. Clearing storage.", jsonErr);
                localStorage.removeItem("3d_save");
                window.dAdd('cube');
            }
        }
    }

    window.undo = () => {
        if(historyStep > 0) {
            isUndoRedoAction = true;
            historyStep--;
            loadSnapshot(historyStack[historyStep]);
            isUndoRedoAction = false;
            saveState();
        }
    };

    window.redo = () => {
        if(historyStep < historyStack.length - 1) {
            isUndoRedoAction = true;
            historyStep++;
            loadSnapshot(historyStack[historyStep]);
            isUndoRedoAction = false;
            saveState();
        }
    };
    window.toggleRuler = () => {
        showRuler = !showRuler;

        // Toggle Visuals
        if(rulerGroup) rulerGroup.visible = showRuler;

        // Toggle UI Button State
        const btn = document.getElementById('btn-ruler');
        if(btn) {
            if(showRuler) {
                btn.classList.remove('btn-outline-dark');
                btn.classList.add('btn-primary');
            } else {
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-outline-dark');
            }
        }

        // Update labels immediately
        updateTinkerLabels();
    };
// --- EXTRUDE (PUSH/PULL) TOOL ---


// --- EXTRUDE (PUSH/PULL) TOOL (IMPROVED) ---


// --- EXTRUDE TOOL: HEIGHT -> TAPER -> SKEW (DIRECTION) ---


window.dExtrude = () => {
    if(selectedObjects.length > 0) selectObject(null);
    extrudeState = 0;
    extrudeData = null;

    document.body.style.cursor = 'crosshair';
    document.querySelectorAll(".btn-tool").forEach(b => b.classList.remove("active-tool"));
    const btn = document.querySelector('button[onclick="window.dExtrude()"]');
    if(btn) btn.classList.add('active-tool');

    const status = document.getElementById("auto-save-status");
    status.innerText = "Step 1: Click a FACE to extrude";
    status.style.opacity = 1;
};

// HELPER: Create Extrusion with Taper AND Skew (Offset)
// HELPER: Create Extrusion (Supports Height, Taper, Skew, and Start Offset)
// startOffset allows the shape to start "in the air" to ensure clean cuts.
// HELPER: Create Extrusion (Position-Based Topology)
// Fixes "Spikes" and "Internal Walls" on complex shapes
function createExtrusionGeo(mesh, indices, height, localNormal, taperScale = 1.0, skewOffset = new THREE.Vector3(0,0,0), startOffset = 0) {
    const posAttr = mesh.geometry.attributes.position;
    
    // 1. Gather Vertices & Map Indices to Positions
    // We convert the index array into a direct array of Vector3s to make logic easier
    const triVerts = []; 
    for(let i=0; i<indices.length; i++) {
        triVerts.push(new THREE.Vector3().fromBufferAttribute(posAttr, indices[i]));
    }

    // 2. Calculate Centroid (Using Unique Positions Only)
    // This prevents the taper from leaning towards corners with more triangles
    const uniquePosMap = new Set();
    const center = new THREE.Vector3();
    let uniqueCount = 0;
    
    // Helper to round positions to merge splits
    const getPosKey = (v) => `${v.x.toFixed(4)}_${v.y.toFixed(4)}_${v.z.toFixed(4)}`;

    triVerts.forEach(v => {
        const k = getPosKey(v);
        if(!uniquePosMap.has(k)) {
            uniquePosMap.add(k);
            center.add(v);
            uniqueCount++;
        }
    });
    if(uniqueCount > 0) center.divideScalar(uniqueCount);

    // 3. Identify Boundary Edges (Position Based)
    // If an edge (A->B) appears once, it's a border.
    // If it appears twice (A->B and B->A), it's internal.
    const boundaryEdges = new Map(); 

    for (let i = 0; i < triVerts.length; i += 3) {
        const vA = triVerts[i];
        const vB = triVerts[i+1];
        const vC = triVerts[i+2];

        const processEdge = (v1, v2) => {
            const k1 = getPosKey(v1);
            const k2 = getPosKey(v2);
            const key = `${k1}|${k2}`;
            const revKey = `${k2}|${k1}`;

            if (boundaryEdges.has(revKey)) {
                boundaryEdges.delete(revKey); // Shared internal edge -> Remove
            } else {
                boundaryEdges.set(key, { start: v1, end: v2 }); // Candidate border
            }
        };

        processEdge(vA, vB);
        processEdge(vB, vC);
        processEdge(vC, vA);
    }

    // 4. Build Geometry
    const newPos = [];
    const shiftVector = localNormal.clone().multiplyScalar(height);
    const startVector = localNormal.clone().multiplyScalar(startOffset);

    // Helper: Calculate Top Position (Deep End)
    const getTopPos = (baseVec) => {
        const dir = new THREE.Vector3().subVectors(baseVec, center);
        return center.clone()
            .add(dir.multiplyScalar(taperScale)) // Taper
            .add(shiftVector)                    // Height
            .add(skewOffset);                    // Skew
    };

    // Helper: Calculate Bottom Position (Surface End + StartOffset)
    const getBottomPos = (baseVec) => {
        return baseVec.clone().add(startVector);
    };

    // A. Top Cap (Tapered)
    // We iterate the original triangles to maintain the surface mesh structure
    for (let i = 0; i < triVerts.length; i++) {
        const v = getTopPos(triVerts[i]);
        newPos.push(v.x, v.y, v.z);
    }

    // B. Bottom Cap (Original Surface, Reversed)
    for (let i = 0; i < triVerts.length; i += 3) {
        const v1 = getBottomPos(triVerts[i]);
        const v2 = getBottomPos(triVerts[i+1]);
        const v3 = getBottomPos(triVerts[i+2]);
        newPos.push(v3.x, v3.y, v3.z);
        newPos.push(v2.x, v2.y, v2.z);
        newPos.push(v1.x, v1.y, v1.z);
    }

    // C. Walls (Based on the clean outer boundary)
    boundaryEdges.forEach(edge => {
        const vA = getBottomPos(edge.start);
        const vB = getBottomPos(edge.end);
        const vA_Top = getTopPos(edge.start);
        const vB_Top = getTopPos(edge.end);

        // Quad 1
        newPos.push(vA.x, vA.y, vA.z);
        newPos.push(vB.x, vB.y, vB.z);
        newPos.push(vB_Top.x, vB_Top.y, vB_Top.z);
        // Quad 2
        newPos.push(vB_Top.x, vB_Top.y, vB_Top.z);
        newPos.push(vA_Top.x, vA_Top.y, vA_Top.z);
        newPos.push(vA.x, vA.y, vA.z);
    });

    let geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.Float32BufferAttribute(newPos, 3));
    geo = mergeVertices(geo, 0.001); // Weld the new shape together
    geo.computeVertexNormals();
    return geo;
}

// Helper: Get Screen Vector
function getScreenDirection(position, worldNormal, camera, renderer) {
    const p1 = position.clone();
    const p2 = position.clone().add(worldNormal.clone().multiplyScalar(10));
    p1.project(camera); p2.project(camera);
    const x1 = (p1.x * .5 + .5) * renderer.domElement.clientWidth;
    const y1 = (p1.y * -.5 + .5) * renderer.domElement.clientHeight;
    const x2 = (p2.x * .5 + .5) * renderer.domElement.clientWidth;
    const y2 = (p2.y * -.5 + .5) * renderer.domElement.clientHeight;
    return new THREE.Vector2(x2 - x1, y2 - y1).normalize();
}

// Helper: Calculate Tangent Basis for Skewing
function getTangentBasis(normal) {
    // Arbitrary consistent tangent vectors on the surface plane
    const c1 = new THREE.Vector3().crossVectors(normal, new THREE.Vector3(0,0,1));
    const c2 = new THREE.Vector3().crossVectors(normal, new THREE.Vector3(0,1,0));
    const tangent = (c1.lengthSq() > c2.lengthSq()) ? c1 : c2;
    tangent.normalize();
    const bitangent = new THREE.Vector3().crossVectors(normal, tangent).normalize();
    return { u: tangent, v: bitangent };
}

window.handleExtrudeClick = (ray) => {
    if (typeof extrudeState === 'undefined' || extrudeState === -1) return false;
    
    // --- STAGE 3: COMMIT (Finish Skew) ---
    if (extrudeState === 3) {
        finishExtrude();
        return true;
    }

    // --- STAGE 2: LOCK TAPER (Start Skew) ---
    if (extrudeState === 2) {
        extrudeState = 3;
        extrudeData.startMouseSkew = null;
        document.getElementById("auto-save-status").innerText = "Step 4: Drag to change ANGLE/SKEW (Click to Finish)";
        return true;
    }

    // --- STAGE 1: LOCK HEIGHT (Start Taper) ---
    if (extrudeState === 1) {
        extrudeState = 2; 
        extrudeData.startMouseTaper = null;
        document.getElementById("auto-save-status").innerText = "Step 3: Drag LEFT/RIGHT to Taper";
        return true;
    }

    // --- STAGE 0: SELECT FACE ---
    if (extrudeState === 0) {
        const targets = scene.children.filter(o => o.isMesh && !o.userData.isRuler && o !== liftCone && !o.userData.isGhost);
        const intersects = ray.intersectObjects(targets, false);

        if (intersects.length > 0) {
            const hit = intersects[0];
            const mesh = hit.object;

            const surfaceData = getConnectedFlatSurface(mesh, hit.faceIndex, hit.face.normal);
            const worldNormal = hit.face.normal.clone().applyQuaternion(mesh.quaternion).normalize();
            const localNormal = hit.face.normal.clone().normalize(); 
            const screenDir = getScreenDirection(hit.point, worldNormal, cam, ren);
            const basis = getTangentBasis(localNormal); // For Skewing

            extrudeData = {
                mesh: mesh,
                localNormal: localNormal,
                worldNormal: worldNormal,
                screenDir: screenDir,
                basis: basis,
                indices: surfaceData.indices,
                startMouse: null,
                startMouseTaper: null,
                startMouseSkew: null,
                currentHeight: 0,
                currentScale: 1.0,
                currentSkew: new THREE.Vector3(0,0,0),
                ghost: null
            };

            const geo = createExtrusionGeo(mesh, surfaceData.indices, 0.1, localNormal);
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0xffff00, transparent: true, opacity: 0.8, roughness: 0.2 
            });
            
            const ghost = new THREE.Mesh(geo, mat);
            ghost.position.copy(mesh.position);
            ghost.rotation.copy(mesh.rotation);
            ghost.scale.copy(mesh.scale);
            ghost.userData = { isGhost: true };
            
            scene.add(ghost);
            extrudeData.ghost = ghost;

            extrudeState = 1;
            document.getElementById("auto-save-status").innerText = "Step 2: Drag ALONG arrow for Height";
            
            return true;
        }
    }
    
    return false;
};

window.handleExtrudeHover = (ray, e) => {
    if (!extrudeData || !extrudeData.ghost) return;
    const currentMouse = new THREE.Vector2(e.clientX, e.clientY);

    // --- STAGE 1: HEIGHT ---
    if (extrudeState === 1) {
        if(!extrudeData.startMouse) { extrudeData.startMouse = currentMouse.clone(); return; }
        const delta = new THREE.Vector2().subVectors(currentMouse, extrudeData.startMouse);
        let projection = delta.dot(extrudeData.screenDir);
        let height = projection * 0.5; 
        if(Math.abs(height) < 0.1) height = 0.1;
        
        extrudeData.currentHeight = height;
        updateExtrudeGhost();
        
        const type = height > 0 ? "Add" : "Cut";
        document.getElementById("auto-save-status").innerText = `Height: ${height.toFixed(1)}mm (${type})`;
    }

    // --- STAGE 2: TAPER ---
    else if (extrudeState === 2) {
        if(!extrudeData.startMouseTaper) { extrudeData.startMouseTaper = currentMouse.clone(); return; }
        const deltaX = (currentMouse.x - extrudeData.startMouseTaper.x) * 0.01;
        let scale = 1.0 + deltaX;
        if(scale < 0.1) scale = 0.1;
        
        extrudeData.currentScale = scale;
        updateExtrudeGhost();
        document.getElementById("auto-save-status").innerText = `Taper: ${(scale*100).toFixed(0)}%`;
    }

    // --- STAGE 3: SKEW (ANGLE) ---
    else if (extrudeState === 3) {
        if(!extrudeData.startMouseSkew) { extrudeData.startMouseSkew = currentMouse.clone(); return; }
        const dx = (currentMouse.x - extrudeData.startMouseSkew.x) * 0.2; // Sensitivity
        const dy = (currentMouse.y - extrudeData.startMouseSkew.y) * -0.2; // Invert Y

        // Map 2D mouse to 3D surface plane (Tangent/Bitangent)
        const skew = new THREE.Vector3()
            .add(extrudeData.basis.u.clone().multiplyScalar(dx))
            .add(extrudeData.basis.v.clone().multiplyScalar(dy));
            
        extrudeData.currentSkew = skew;
        updateExtrudeGhost();
        document.getElementById("auto-save-status").innerText = `Skew: X:${dx.toFixed(1)} Y:${dy.toFixed(1)}`;
    }
};

function updateExtrudeGhost() {
    const { mesh, indices, currentHeight, localNormal, currentScale, currentSkew, ghost } = extrudeData;
    
    let color = 0xffff00; // Yellow (Add)
    let startOffset = 0;

    if (currentHeight < 0) {
        color = 0xff0000; // Red (Cut)
        startOffset = 0.5; // Visually show it sticking out
    }
    
    const newGeo = createExtrusionGeo(mesh, indices, currentHeight, localNormal, currentScale, currentSkew, startOffset);
    ghost.geometry.dispose();
    ghost.geometry = newGeo;
    ghost.material.color.setHex(color);
}

function finishExtrude() {
    const status = document.getElementById("auto-save-status");
    status.innerText = "Computing Boolean...";
    
    setTimeout(() => {
        try {
            const { mesh, ghost, currentHeight } = extrudeData;
            const ev = new Evaluator();
            const mat = mesh.material;

            const bBase = new Brush(prepareCSG(mesh.geometry));
            bBase.position.copy(mesh.position);
            bBase.rotation.copy(mesh.rotation);
            bBase.scale.copy(mesh.scale);
            bBase.updateMatrixWorld();

            // --- THE FIX ---
            let finalGeo;
            
            if (currentHeight < 0) {
                // CUT MODE: 
                // Generate geometry that starts +1.0mm OUTSIDE the object (startOffset)
                // and goes to the desired depth. 
                // We don't change 'currentHeight' logic, just where it starts.
                
                finalGeo = createExtrusionGeo(
                    mesh, 
                    extrudeData.indices, 
                    currentHeight, // Target depth (e.g. -10)
                    extrudeData.localNormal,
                    extrudeData.currentScale,
                    extrudeData.currentSkew,
                    1.0 // <--- START OFFSET: Start 1mm "in the air"
                );
            } else {
                // ADD MODE: Start exactly at 0
                finalGeo = ghost.geometry;
            }

            const bExtrude = new Brush(prepareCSG(finalGeo));
            // IMPORTANT: Use the ghost's transform, as the geometry is built in Local Space
            bExtrude.position.copy(ghost.position);
            bExtrude.rotation.copy(ghost.rotation);
            bExtrude.scale.copy(ghost.scale);
            bExtrude.updateMatrixWorld();

            let result;
            if (currentHeight >= 0) {
                 result = ev.evaluate(bBase, bExtrude, ADDITION);
            } else {
                 result = ev.evaluate(bBase, bExtrude, SUBTRACTION);
            }

            mesh.updateMatrixWorld();
            const inverseMat = mesh.matrixWorld.clone().invert();
            result.geometry.applyMatrix4(inverseMat);

            mesh.geometry.dispose();
            mesh.geometry = result.geometry;
            mesh.geometry.computeVertexNormals();
            mesh.material = mat;

            if(mesh.userData.geoParams) delete mesh.userData.geoParams;
            mesh.userData.name = mesh.userData.name + (currentHeight<0?"(Cut)":"(Ext)");

        } catch (e) {
            console.error("Extrude Failed", e);
            alert("Boolean failed. Try checking the browser console for errors.");
        }

        scene.remove(extrudeData.ghost);
        extrudeData = null;
        extrudeState = -1;
        isExtrudeMode = false;
        
        document.body.style.cursor = 'default';
        document.querySelectorAll(".btn-tool").forEach(b => b.classList.remove("active-tool"));
        window.setMode('translate');
        
        status.innerText = "Done";
        setTimeout(() => status.style.opacity = 0, 1000);
        
        saveState();
        window.requestRender();
    }, 50);
}
    // Initialize
    init3D();

</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
