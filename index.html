<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<title>3D Creator - Project History & Unmerge</title>

<!-- 1. CSS STYLES -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">

<style>
    body, html { margin: 0; padding: 0; overflow: hidden; height: 100%; background: #e0e0e0; font-family: 'Segoe UI', sans-serif; }
    /* FPS Counter Styling */
    #fps-display {
        position: absolute;
        top: 10px;
        left: 80px; /* Offset to not cover the toolbar */
        background: rgba(0, 0, 0, 0.7);
        color: #00ff00;
        font-family: monospace;
        font-size: 14px;
        font-weight: bold;
        padding: 4px 8px;
        border-radius: 4px;
        pointer-events: none; /* Let clicks pass through */
        z-index: 1000;
        display: none; /* Hidden by default */
    }
        /* Full Screen Editor */
    #designer-area {
        position: absolute; top: 0; left: 0;
        width: 100vw; height: 100vh;
        z-index: 1;
        background: radial-gradient(circle at center, #f0f0f0 0%, #d0d0d0 100%);
    }
    #designer-canvas { width: 100%; height: 100%; display: block; outline: none; }

    /* UI Panels (Floating) */
    .float-panel {
        position: absolute;
        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(5px);
        border: 1px solid rgba(0,0,0,0.1);
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        padding: 8px;
        z-index: 100;
        pointer-events: auto;
    }

    /* Toolbar (Left) */
    .float-toolbar { top: 20px; left: 20px; width: 50px; display: flex; flex-direction: column; gap: 6px; align-items: center; }

    /* Top Header */
    .float-header { top: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; padding: 8px 15px; align-items: center;}


    /* Object List (Bottom Right) - Fixed Layout */
    .float-list {
        bottom: 20px;
        right: 20px;
        width: 220px;

        /* Constraint: Never grow taller than 40% of screen */
        max-height: 40vh;
        height: auto;

        display: flex;
        flex-direction: column;
        overflow: hidden; /* Prevent outer scroll */
    }

    /* The Header (Objects label) */
    .float-list > .panel-header {
        flex-shrink: 0; /* Never squash header */
    }

    /* The Wrapper for List + Buttons */
    #content-list {
        display: flex;
        flex-direction: column;
        flex: 1;          /* Take up all remaining height */
        min-height: 0;    /* Critical Fix for Flexbox scrolling */
        padding-top: 5px;
    }

    /* The Scrollable List */
    #object-list {
        flex: 1;          /* Grow to fill space between header and buttons */
        overflow-y: auto; /* Scroll ONLY this area */
        margin-bottom: 10px; /* Space above buttons */
        border-bottom: 1px solid #ddd;
        list-style: none;
        padding: 0;
    }

    /* The Buttons */
    #content-list .btn-group {
        flex-shrink: 0;   /* Never squash buttons */
        width: 100%;
        margin-bottom: 5px;
    }
    /* Properties (Top Right) */
    .float-props { top: 20px; right: 20px; width: 240px; display: none; }

    /* Export Modal */
    .float-export { top: 50%; left: 50%; transform: translate(-50%, -50%); width: 300px; display: none; padding: 20px; }

    /* UI Elements */
    .btn-tool { width: 36px; height: 36px; padding: 0; display: flex; align-items: center; justify-content: center; border-radius: 6px; }
    .active-tool { background-color: #0d6efd !important; color: white !important; border-color: #0b5ed7 !important; }
    .divider { width: 80%; height: 1px; background: #ddd; margin: 2px 0; }

    /* Measurement Labels */
    .label-overlay { pointer-events: none; z-index: 50; font-family: sans-serif; overflow: hidden; }
    .tinker-label-container { pointer-events: auto; padding: 2px; }
    .tinker-input {
        pointer-events: auto; background: rgba(255, 255, 255, 0.95);
        border: 1px solid #0d6efd; border-radius: 4px; padding: 2px 0;
        font-size: 13px; font-weight: bold; color: #000; width: 55px;
        text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .dim-pos { color: #0d6efd; border-color: #0d6efd; }
    .dim-size { color: #212529; border-color: #6c757d; }
    .rot-label { background:rgba(0,0,0,0.8); color:#ffc107; padding:4px; border-radius:4px; font-weight:bold; font-size:12px; }

    /* List Items */
    .object-list-item { font-size: 0.85rem; padding: 8px; border-bottom: 1px solid #eee; cursor: pointer; display: flex; align-items: center; background:white; }
    .object-list-item:hover { background: #f8f9fa; }
    .object-list-item.selected { background: #e7f1ff; border-left: 3px solid #0d6efd; font-weight: 600; }

    .color-picker { display:flex; flex-wrap:wrap; gap:4px; margin-top: 5px; }
    .color-option { width:20px; height:20px; border-radius:3px; cursor:pointer; border:1px solid rgba(0,0,0,0.1); }
    .color-option.selected { border:2px solid #000; transform:scale(1.2); }

/* --- MOBILE & LANDSCAPE OPTIMIZATIONS --- */
    @media (max-width: 950px) {
        /* General Scaling for Touch */
        .btn-tool { width: 40px; height: 40px; } /* Larger touch targets */

        /* 1. TOP HEADER: Allow horizontal scroll if buttons overflow */
        .float-header {
            top: 10px;
            width: 90%;
            max-width: 100%;
            overflow-x: auto;
            white-space: nowrap;
            justify-content: flex-start;
            padding: 5px 10px;
            /* Hide Scrollbar */
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .float-header::-webkit-scrollbar { display: none; }

        /* 2. LEFT TOOLBAR: Scrollable & Collapsible */
        .float-toolbar {
            top: 60px; /* Push down below header */
            left: 10px;
            bottom: 10px; /* Stretch to bottom */
            height: auto;
            max-height: calc(100vh - 80px);
            overflow-y: auto; /* Enable Scroll */
            -webkit-overflow-scrolling: touch;
            transition: transform 0.3s ease;
        }

        /* 3. PROPERTIES PANEL: Scale Down & Reposition */
        .float-props {
            top: 60px;
            right: 10px;
            width: 200px; /* Slimmer */
            font-size: 0.8rem;
            max-height: 80vh;
            overflow-y: auto;
            transition: height 0.3s ease;
        }
        .float-props input, .float-props select { font-size: 0.8rem; }
        .float-props .row { --bs-gutter-x: 0.5rem; } /* Tighten grid */

        /* 4. OBJECT LIST: Minimize Logic */
        .float-list {
            bottom: 10px;
            right: 10px;
            width: 180px; /* Slimmer */
            max-height: 40vh; /* Don't cover too much vertical space */
            transition: height 0.3s ease;
        }
        /* When minimized class is added */
        .float-list.minimized {
            height: 40px !important; /* Header height only */
            overflow: hidden !important;
        }
        .float-list.minimized #object-list,
        .float-list.minimized .btn-group {
            display: none;
        }
        .float-props.minimized #content-props {
            display: none; /* Hide the innards */
        }
        /* --- PREVENT IPHONE TEXT SELECTION --- */
        #auto-save-status,
        #fps-display,
        .float-header,
        .float-list,
        .float-props,
        .float-toolbar {
            -webkit-touch-callout: none !important; /* Disable magnifying glass */
            -webkit-user-select: none !important;   /* Disable text selection */
            user-select: none !important;
        }

        /* Re-enable for inputs only */
        input {
            -webkit-user-select: text !important;
            user-select: text !important;
        }

        /* iPhone Safe Areas (Notch/Home Bar) */
        body {
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }
    }
</style>

<!-- 2. IMPORT MAP -->
<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
        "three-mesh-bvh": "https://unpkg.com/three-mesh-bvh@0.7.3/build/index.module.js",
        "three-bvh-csg": "https://unpkg.com/three-bvh-csg@0.0.16/build/index.module.js",
        "zstd-wasm": "https://unpkg.com/@bokuweb/zstd-wasm@0.0.27/dist/web/index.web.js",
        "three-rounded-box": "https://unpkg.com/three@0.160.0/examples/jsm/geometries/RoundedBoxGeometry.js",
        "three/addons/loaders/FontLoader.js": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/FontLoader.js",
        "three/addons/geometries/TextGeometry.js": "https://unpkg.com/three@0.160.0/examples/jsm/geometries/TextGeometry.js",
        "three/addons/loaders/MTLLoader.js": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/MTLLoader.js"
    }
}
</script>

<!-- 3. Polyfills -->
<script async src="https://ga.jspm.io/npm:es-module-shims@1.8.0/dist/es-module-shims.js"></script>
</head>
<body>

<div id="designer-area">
    <canvas id="designer-canvas"></canvas>
<div id="fps-display">FPS: 0</div>
    <!-- Auto Save Indicator -->
    <div id="auto-save-status" style="position:absolute; bottom:20px; left:50%; transform:translateX(-50%); color:white; background:rgba(0,0,0,0.6); padding:4px 12px; border-radius:20px; opacity:0; pointer-events:none; transition: opacity 0.5s; font-size: 0.8rem;">Saved</div>

    <!-- Header Controls -->
    <div class="float-panel float-header">
        <button class="btn btn-sm btn-outline-dark border-0" onclick="window.undo()" title="Undo (Ctrl+Z)">
            <i class="bi bi-arrow-counterclockwise"></i>
        </button>
        <button class="btn btn-sm btn-outline-dark border-0" onclick="window.redo()" title="Redo (Ctrl+Y)">
            <i class="bi bi-arrow-clockwise"></i>
        </button>

        <div style="border-left:1px solid #ccc; margin:0 5px; height:20px;"></div>

        <!-- Settings Button -->
        <button class="btn btn-sm btn-outline-dark border-0"
        onclick="document.getElementById('settings-panel').style.display='block'; window.updateStorageUI()"
        title="Settings">
            <i class="bi bi-gear"></i>
        </button>
        <div style="border-left:1px solid #ccc; margin:0 5px; height:20px;"></div>

        <button class="btn btn-sm btn-outline-dark border-0 fw-bold" onclick="document.getElementById('export-panel').style.display='block'">
            <i class="bi bi-download me-1"></i> Export
        </button>
        <div style="border-left:1px solid #ccc; margin:0 5px; height:20px;"></div>
        <button class="btn btn-sm btn-outline-danger border-0" onclick="if(confirm('Clear Scene?')) window.dDelAll()" title="Clear Scene">
            <i class="bi bi-trash"></i>
        </button>
        <div style="border-left:1px solid #ccc; margin:0 5px; height:20px;"></div>
        <button id="btn-ruler" class="btn btn-sm btn-outline-dark border-0" onclick="window.toggleRuler()" title="Toggle Ruler (M)">
            <i class="bi bi-ruler"></i>
        </button>
        <!-- NEW: Ruler Mode Toggle -->
        <button id="btn-ruler-mode" class="btn btn-sm btn-outline-dark border-0" onclick="window.toggleRulerMode()" title="Mode: Endpoint">
            <i class="bi bi-arrows-collapse"></i>
        </button>
        <div style="border-left:1px solid #ccc; margin:0 5px; height:20px;"></div>
    </div>

<!-- Toolbar (Left) -->
    <div class="float-panel float-toolbar" id="main-toolbar">
        <!-- New Mobile Toggle Icon -->
        <div class="d-md-none mb-2" onclick="window.toggleToolbar()" style="cursor:pointer">
            <i class="bi bi-three-dots-vertical"></i>
        </div>
        <div class="small fw-bold text-muted" style="font-size:0.6rem">ADD</div>
        <button class="btn btn-light border btn-tool" onclick="window.dAdd('cube')" title="Cube"><i class="bi bi-box"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.dAdd('cyl')" title="Cylinder"><i class="bi bi-database"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.dAdd('sph')" title="Sphere"><i class="bi bi-circle"></i></button>

        <button class="btn btn-light border btn-tool" onclick="window.dAdd('cone')" title="Cone / Pyramid"><i class="bi bi-cone-striped"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.dAdd('torus')" title="Torus (Donut)"><i class="bi bi-circle-half"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.dAdd('wedge')" title="Wedge / Ramp"><i class="bi bi-caret-up-fill"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.dStartText()" title="3D Text"><i class="bi bi-type"></i></button>
        <div class="divider"></div>

        <div class="small fw-bold text-muted" style="font-size:0.6rem">EDIT</div>
        <button class="btn btn-light border btn-tool" onclick="window.setMode('translate')" data-mode="translate" title="Move"><i class="bi bi-arrows-move"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.setMode('rotate')" data-mode="rotate" title="Rotate"><i class="bi bi-arrow-repeat"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.setMode('scale')" data-mode="scale" title="Scale"><i class="bi bi-arrows-angle-expand"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.startAlignTool()" title="Snap Face to Face"><i class="bi bi-magnet"></i></button>
        <div class="divider"></div>

        <div class="small fw-bold text-muted" style="font-size:0.6rem">ACT</div>
        <button class="btn btn-light border btn-tool" onclick="window.dDuplicate()" title="Duplicate"><i class="bi bi-files"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.dLoft()" title="Loft / Hull"><i class="bi bi-bezier2"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.dShell()" title="Hollow / Shell"><i class="bi bi-nut"></i></button>
        <button class="btn btn-light border btn-tool" onclick="window.dDrop()" title="Drop to Floor"><i class="bi bi-arrow-bar-down"></i></button>

        <div class="divider"></div>

        <button class="btn btn-primary border btn-tool" onclick="document.getElementById('file-upload').click()" title="Import File"><i class="bi bi-upload"></i></button>
        <input type="file" id="file-upload" multiple accept=".stl,.obj,.mtl,.jpg,.png,.glb,.gltf,.usdz" style="display:none" onchange="window.dImportFile(this)">
    </div>

    <!-- Object List (Bottom Right) -->
    <div class="float-panel float-list" id="panel-list">
        <!-- Header: Added class 'panel-header' for CSS targeting -->
        <div class="d-flex justify-content-between align-items-center mb-1 border-bottom pb-1 panel-header"
            onclick="window.togglePanel('panel-list')" style="cursor:pointer">
            <span class="fw-bold small"><i class="bi bi-list-ul"></i> Objects</span>
            <i class="bi bi-chevron-down small" id="icon-panel-list"></i>
        </div>

        <!-- Content Container -->
        <div id="content-list">
            <!-- The List -->
            <ul id="object-list"></ul>

            <!-- The Buttons -->
            <div class="btn-group">
                <button class="btn btn-sm btn-warning" id="merge-btn" onclick="window.dMerge()">Merge (0)</button>
                <button class="btn btn-sm btn-outline-dark" id="unmerge-btn" onclick="window.dUnmerge()" style="display:none;">Unmerge</button>
                <button class="btn btn-sm btn-danger" onclick="window.dDel()">Delete</button>
            </div>
        </div>
    </div>

<!-- Properties (Top Right) -->
    <div class="float-panel float-props" id="prop-panel" style="overflow-y: auto; max-height: 70vh;">
        <!-- Header: Clicking this minimizes the panel but KEEPS selection -->
        <div class="d-flex justify-content-between border-bottom pb-1 mb-2"
             onclick="window.togglePanel('prop-panel')" style="cursor:pointer">
            <span class="fw-bold small">Properties</span>
            <div>
                <!-- Toggle Icon -->
                <i class="bi bi-chevron-down small me-2" id="icon-panel-props"></i>
                <!-- Deselect (X) Button -->
                <button class="btn-close btn-sm" onclick="event.stopPropagation(); window.selectObject(null)"></button>
            </div>
        </div>

        <!-- Inner Content (Hidden when minimized) -->
        <div id="content-props">
            <div class="mb-2">
                <input type="text" id="opt-obj-name" class="form-control form-control-sm mb-1" placeholder="Name" onchange="window.updateObjectName(this.value)">
                <div class="d-flex justify-content-between align-items-center">
                     <select id="opt-d-type" class="form-select form-select-sm w-50" onchange="window.dUpdMat(this.value)">
                        <option value="solid">Solid</option>
                        <option value="hole">Hole (Sub)</option>
                     </select>
                     <div class="color-picker" id="color-picker"></div>
                </div>
            </div>
            <!-- DYNAMIC SHAPE PARAMETERS -->
            <div id="shape-params" class="mb-2 pt-2 border-top" style="display:none; background:#f8f9fa; padding:5px; border-radius:4px;"></div>

            <div class="row g-1 mb-2">
                <label class="small text-muted col-12 mb-0">Size (mm)</label>
                <div class="col-4"><input type="number" id="opt-sz-x" class="form-control form-control-sm" placeholder="W" onchange="window.dSz()"></div>
                <div class="col-4"><input type="number" id="opt-sz-y" class="form-control form-control-sm" placeholder="L" onchange="window.dSz()"></div>
                <div class="col-4"><input type="number" id="opt-sz-z" class="form-control form-control-sm" placeholder="H" onchange="window.dSz()"></div>
            </div>
            <div class="row g-1">
                <label class="small text-muted col-12 mb-0">Rotation (Deg)</label>
                <div class="col-4"><input type="number" id="opt-rot-x" class="form-control form-control-sm" placeholder="X" onchange="window.dRot()"></div>
                <div class="col-4"><input type="number" id="opt-rot-y" class="form-control form-control-sm" placeholder="Y" onchange="window.dRot()"></div>
                <div class="col-4"><input type="number" id="opt-rot-z" class="form-control form-control-sm" placeholder="Z" onchange="window.dRot()"></div>
            </div>
        </div>
    </div>

    <!-- Export Panel -->
    <div class="float-panel float-export" id="export-panel">
        <div class="d-flex justify-content-between mb-3">
            <strong><i class="bi bi-box-seam"></i> Export Design</strong>
            <button class="btn-close" onclick="document.getElementById('export-panel').style.display='none'"></button>
        </div>
        <div class="mb-3">
            <label class="small fw-bold">File Name</label>
            <input id="d-name" class="form-control form-control-sm" placeholder="My Design">
        </div>
        <div class="mb-3">
            <label class="small fw-bold">Format</label>
            <select id="export-format" class="form-select form-select-sm">
                <!-- NEW PROJECT OPTION -->
                <option value="json" style="font-weight:bold; color:#0d6efd;">â˜… Project (Editable, With History)</option>
                <option value="stl">STL (3D Printing)</option>
                <option value="obj">OBJ (Standard)</option>
                <option value="gltf">GLTF (Web/Unity)</option>
                <option value="glb">GLB (Android AR)</option>
                <option value="usdz">USDZ (Apple AR)</option>
            </select>
        </div>
        <div class="d-grid gap-2">
            <button class="btn btn-primary" onclick="window.triggerExport()">
                <i class="bi bi-download"></i> Download File
            </button>
            <div class="divider my-1"></div>
             <!-- NEW IMPORT PROJECT BUTTON -->
            <button class="btn btn-sm btn-secondary" onclick="document.getElementById('project-upload').click()">
                <i class="bi bi-folder2-open"></i> Open Project File
            </button>
            <input type="file" id="project-upload" accept=".json,.tinker" style="display:none" onchange="window.loadProjectFile(this)">
        </div>
    </div>
    <!-- Settings Panel -->
    <div class="float-panel float-export" id="settings-panel" style="display:none; width: 320px;">
        <div class="d-flex justify-content-between mb-3 border-bottom pb-2">
            <strong><i class="bi bi-sliders"></i> Scene Settings</strong>
            <button class="btn-close" onclick="document.getElementById('settings-panel').style.display='none'"></button>
        </div>

        <!-- Lighting -->
        <div class="mb-3">
            <label class="small fw-bold text-muted">Lighting & Shadows</label>

            <div class="d-flex justify-content-between align-items-center mt-2">
                <span class="small">Shadow Darkness (Ambient)</span>
                <input type="range" class="form-range w-50" min="0" max="2" step="0.1" id="set-ambient" oninput="window.updateSettings('ambient', this.value)">
            </div>

            <div class="d-flex justify-content-between align-items-center">
                <span class="small">Sun Brightness</span>
                <input type="range" class="form-range w-50" min="0" max="3" step="0.1" id="set-direct" oninput="window.updateSettings('direct', this.value)">
            </div>
        </div>

        <!-- Visuals -->
        <div class="mb-3">
            <label class="small fw-bold text-muted">Visual Style</label>

            <div class="form-check form-switch mt-2">
                <input class="form-check-input" type="checkbox" id="set-shadows" onchange="window.updateSettings('shadows', this.checked)">
                <label class="form-check-label small">Cast Shadows</label>
            </div>

            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" id="set-grid" onchange="window.updateSettings('grid', this.checked)">
                <label class="form-check-label small">Show Grid</label>
            </div>

            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" id="set-wireframe" onchange="window.updateSettings('wireframe', this.checked)">
                <label class="form-check-label small">Wireframe Mode</label>
            </div>
        </div>
        <!-- Performance Settings -->
        <div class="mb-3">
            <label class="small fw-bold text-muted">Performance</label>
            <div class="d-flex justify-content-between align-items-center mt-2">
                <span class="small">Frame Rate Limit</span>
                <select id="set-fps" class="form-select form-select-sm w-50" onchange="window.updateSettings('fps', this.value)">
                    <option value="30">30 FPS (Save Battery)</option>
                    <option value="60">60 FPS (Standard)</option>
                    <option value="unlocked">Unlocked (Max)</option>
                </select>
            </div>
        </div>

        <div class="form-check form-switch mt-2">
            <input class="form-check-input" type="checkbox" id="set-show-fps" onchange="window.updateSettings('showFps', this.checked)">
            <label class="form-check-label small">Show FPS Counter</label>
        </div>

        <!-- NEW: Storage Meter -->
        <div class="mb-3 border-top pt-3">
            <label class="small fw-bold text-muted mb-1">Local Storage Usage</label>
            <div class="progress" style="height: 8px; background-color: #e9ecef;">
                <div id="storage-bar" class="progress-bar" role="progressbar" style="width: 0%"></div>
            </div>
            <div class="d-flex justify-content-between mt-1">
                <span id="storage-text" class="small text-muted" style="font-size: 0.75rem;">Calculating...</span>
                <span class="small text-muted" style="font-size: 0.75rem;">5.0 MB Limit</span>
            </div>
        </div>

        <div class="text-end">
            <button class="btn btn-sm btn-outline-secondary" onclick="window.resetSettings()">Reset Defaults</button>
        </div>
    </div>
</div>

<!-- 4. MAIN LOGIC -->
<script type="module">
import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { TransformControls } from "three/addons/controls/TransformControls.js";
    import { CSS2DRenderer, CSS2DObject } from "three/addons/renderers/CSS2DRenderer.js";
    import { ConvexGeometry } from "three/addons/geometries/ConvexGeometry.js";
    import { RoundedBoxGeometry } from "three-rounded-box"; // NEW IMPORT
    import { mergeVertices } from "three/addons/utils/BufferGeometryUtils.js";
    import { OBJExporter } from "three/addons/exporters/OBJExporter.js";
    import { STLExporter } from "three/addons/exporters/STLExporter.js";
    import { GLTFExporter } from "three/addons/exporters/GLTFExporter.js";
    import { USDZExporter } from "three/addons/exporters/USDZExporter.js";

    import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
    import { STLLoader } from "three/addons/loaders/STLLoader.js";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { USDZLoader } from "three/addons/loaders/USDZLoader.js";
    import { MTLLoader } from "three/addons/loaders/MTLLoader.js";

    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

    import { SUBTRACTION, ADDITION, Brush, Evaluator } from "three-bvh-csg";

    // IMPORT ZSTD
    import { init as initZstd, compress, decompress } from "zstd-wasm";

    // --- GLOBALS ---
    let scene, cam, ren, labelRen, ctrl, tCtrl, ray;
    let selectedObjects = [];
    let liftCone, isLifting = false, liftStartMouseY = 0, liftStartObjZ = 0;
    let rotLabelDiv, rotLabelObj;
    let rulerGroup, rulerMode = 'endpoint';
    let schematicGroup;
    const activeLabels = [];
    const MESH_HIGHLIGHT_COLOR = 0xff0000;
    let isInteracting = false;
    let needsRender = true;

    // --- ALIGN / SNAP FACE TOOL ---
    let alignState = 'none'; // 'none', 'pick-source', 'pick-target'
    let alignSourceInfo = null;
    let alignGhost = null;
    const invisibleFloor = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // Z-up floor

    // Saving & History
    let saveTimeout;
    let zstdReady = false;
    let historyStack = [];
    let historyStep = -1;
    const MAX_HISTORY = 30;
    let isUndoRedoAction = false;
    let isStorageFull = false;
    // --- TEXT GLOBALS ---
    let loadedFont = null;
    let textPlaceMode = false;
    let textGhost = null;


    // --- OPTIMIZATION GLOBALS ---
    let fpsInterval, now, then, elapsed;
    let isFpsLocked = false;
    let fpsFrames = 0;
    let fpsLastTime = 0;
    let frameId;

    let isFaceLoftMode = false;
    let selectedFacesData = [];
    let faceMarkerGroup;
    let showRuler = true; // Default off
    let toolbarExpanded = true;
    let ambientLight, dirLight, gridHelper; // References to update them
    let appSettings = {
        ambient: 0.8,
        direct: 1.0,
        shadows: true,
        grid: true,
        wireframe: false,
        fps: 'unlocked', // Default to unlocked
        showFps: false
    };
    // Load font immediately on startup
    const fLoader = new FontLoader();
    fLoader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json', (font) => {
        loadedFont = font;
        console.log("Font Loaded");
    });

    window.startAlignTool = () => {
        if (selectedObjects.length !== 1) {
            alert("Select 1 object to align.");
            return;
        }

        // 1. Enter Mode
        alignState = 'pick-source';
        document.body.style.cursor = 'crosshair';

        // UI Feedback
        const status = document.getElementById("auto-save-status");
        status.innerText = "Step 1: Click a FACE on the selected object";
        status.style.opacity = 1;

        // Highlight button
        document.querySelectorAll(".btn-tool").forEach(b => b.classList.remove("active-tool"));
        document.querySelector('button[onclick="window.startAlignTool()"]').classList.add("active-tool");
    };

// --- MOBILE UI LOGIC ---
    window.togglePanel = (id) => {
            // 1. Toggle class
            const el = document.getElementById(id);
            el.classList.toggle('minimized');

            // 2. Handle Icon Flipping
            // We look for an icon with ID "icon-" + panelID
            // e.g. "icon-panel-list" or "icon-panel-props"
            const icon = document.getElementById('icon-' + id);

            // Note: For properties panel, the ID is 'prop-panel', so icon is 'icon-panel-props'
            // Let's normalize it.
            let targetIcon = icon;
            if(id === 'prop-panel') targetIcon = document.getElementById('icon-panel-props');
            if(id === 'panel-list') targetIcon = document.getElementById('icon-panel-list');

            if(targetIcon) {
                if(el.classList.contains('minimized')) {
                    targetIcon.classList.remove('bi-chevron-down');
                    targetIcon.classList.add('bi-chevron-up');
                } else {
                    targetIcon.classList.remove('bi-chevron-up');
                    targetIcon.classList.add('bi-chevron-down');
                }
            }
        };


    window.toggleToolbar = () => {
        toolbarExpanded = !toolbarExpanded;
        const bar = document.getElementById('main-toolbar');
        if(toolbarExpanded) {
            bar.style.height = 'auto';
            bar.style.overflowY = 'auto';
        } else {
            bar.style.height = '50px'; // Just enough to show the dots
            bar.style.overflowY = 'hidden';
        }
    };
    function handleAlignHover(ray, mouse) {
        // STEP 2: MOVING THE GHOST
        if (alignState === 'pick-target' && alignGhost) {
            // Raycast against everything EXCEPT the ghost and the source object
            const targets = scene.children.filter(o =>
                o.isMesh &&
                o !== alignGhost &&
                o !== selectedObjects[0] &&
                !o.userData.isRuler &&
                o !== liftCone
            );

            const intersects = ray.intersectObjects(targets, false);
            let targetPoint = null;
            let targetNormal = null;

            // Did we hit an object?
            if (intersects.length > 0) {
                targetPoint = intersects[0].point;
                // Transform normal to world space
                targetNormal = intersects[0].face.normal.clone().applyQuaternion(intersects[0].object.quaternion).normalize();
            } else {
                // Did we hit the floor?
                const target = new THREE.Vector3();
                const hit = ray.ray.intersectPlane(invisibleFloor, target);
                if (hit) {
                    targetPoint = target;
                    targetNormal = new THREE.Vector3(0, 0, 1); // Floor points up
                }
            }

            if (targetPoint && targetNormal) {
                alignGhost.visible = true;

                // MATH: Align Source Normal to NEGATIVE Target Normal (faces touching)
                // 1. Calculate rotation needed to turn World Up (0,1,0) or Object Up into Target direction?
                // Actually, simpler: Rotate 'alignSourceInfo.normal' to '-targetNormal'

                // Get the quaternion that rotates the Source Normal to match the Target Normal (inverted)
                const alignQuat = new THREE.Quaternion().setFromUnitVectors(alignSourceInfo.normal, targetNormal.clone().negate());

                // Apply this rotation to the object's original rotation
                const targetRotation = alignQuat.clone().multiply(selectedObjects[0].quaternion);
                alignGhost.quaternion.copy(targetRotation);

                // POSITIONING:
                // We need the point on the ghost that corresponds to the clicked source point
                // to match the target hit point.

                // 1. Get the vector from Object Center to Source Click Point (Rotated by new orientation)
                const offsetVec = alignSourceInfo.localPoint.clone().applyQuaternion(alignGhost.quaternion);

                // 2. Subtract that offset from the target point to place center correctly
                alignGhost.position.copy(targetPoint).sub(offsetVec);
            } else {
                alignGhost.visible = false;
            }
        }
    }

function handleAlignClick(ray) {
        if (alignState === 'pick-source') {
            // User clicking their own object to pick the face
            const intersects = ray.intersectObject(selectedObjects[0], false);
            if (intersects.length > 0) {
                const hit = intersects[0];

                // Store World Normal of the face
                const worldNormal = hit.face.normal.clone().applyQuaternion(hit.object.quaternion).normalize();

                // Store the point clicked relative to the center
                const localPoint = hit.point.clone().sub(hit.object.position).applyQuaternion(hit.object.quaternion.clone().invert());

                alignSourceInfo = {
                    normal: worldNormal,
                    localPoint: localPoint
                };

                // Create Ghost
                const original = selectedObjects[0];
                alignGhost = original.clone();
                alignGhost.material = new THREE.MeshBasicMaterial({
                    color: 0x0d6efd,
                    transparent: true,
                    opacity: 0.5,
                    wireframe: true
                });
                alignGhost.userData = { isGhost: true };
                scene.add(alignGhost);

                // Hide real object temporarily
                original.visible = false;

                // Next Step
                alignState = 'pick-target';
                const status = document.getElementById("auto-save-status");
                status.innerText = "Step 2: Click anywhere to place";
            }
            return true; // Stop other click events
        }

        if (alignState === 'pick-target') {
            // --- CRITICAL FIX FOR MOBILE ---
            // On touch, we didn't "hover" first, so the ghost doesn't know where to go.
            // We FORCE the calculation right now using the click ray.
            handleAlignHover(ray, null);
            // -------------------------------

            if (alignGhost && alignGhost.visible) {
                // APPLY TRANSFORM
                const obj = selectedObjects[0];
                obj.position.copy(alignGhost.position);
                obj.quaternion.copy(alignGhost.quaternion);
                obj.visible = true;
                obj.updateMatrixWorld();

                // Cleanup
                scene.remove(alignGhost);
                alignGhost = null;
                alignState = 'none';
                alignSourceInfo = null;
                document.body.style.cursor = 'default';

                // Reset UI
                document.querySelectorAll(".btn-tool").forEach(b => b.classList.remove("active-tool"));
                window.setMode('translate');

                const status = document.getElementById("auto-save-status");
                status.innerText = "Aligned";
                setTimeout(() => status.style.opacity = 0, 1000);

                updateTinkerLabels();
                updatePropertiesPanel();
                saveState();
                window.requestRender();
            }
            return true;
        }

        return false;
    }






















    // --- UTILS ---
    function prepareCSG(geometry) {
        if (!geometry) return null;
        const geo = geometry.clone();
        if (geo.attributes.color) geo.deleteAttribute('color');
        if (!geo.attributes.normal) geo.computeVertexNormals();
        if (!geo.attributes.uv) {
            const count = geo.attributes.position.count;
            geo.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(count * 2), 2));
        }
        return geo;
    }

    // Binary <-> Base64 helpers
    function uint8ToBase64(u8Arr) {
        const CHUNK_SIZE = 0x8000;
        let index = 0;
        let length = u8Arr.length;
        let result = '';
        while (index < length) {
            const slice = u8Arr.subarray(index, Math.min(index + CHUNK_SIZE, length));
            result += String.fromCharCode.apply(null, slice);
            index += CHUNK_SIZE;
        }
        return btoa(result);
    }

    function base64ToUint8(b64) {
        const binStr = atob(b64);
        const len = binStr.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binStr.charCodeAt(i);
        }
        return bytes;
    }

    // --- INIT ---
    async function init3D() {
        // Init ZSTD
        try {
            await initZstd('https://unpkg.com/@bokuweb/zstd-wasm@0.0.27/dist/web/zstd.wasm');
            zstdReady = true;
            console.log("Zstd Compression Ready");
        } catch(e) {
            console.warn("Zstd failed to load, saving will be uncompressed", e);
        }
        // --- NEW FONT LOADER LOGIC ---
        const fLoader = new FontLoader();
        fLoader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json', (font) => {
            loadedFont = font;
            console.log("Font Loaded - Starting App");

            // ONLY LOAD DATA AFTER FONT IS READY
            loadFromStorage();
        });
        const canvas = document.getElementById("designer-canvas");
        const container = document.getElementById("designer-area");

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xd0d0d0);

        // 1. IMPROVED LIGHTING SETUP
        // Hemisphere light creates a soft gradient (Sky vs Ground) filling the shadows
        ambientLight = new THREE.HemisphereLight(0xffffff, 0x444444, appSettings.ambient);
        scene.add(ambientLight);

        // Main Directional Light (The Sun)
        dirLight = new THREE.DirectionalLight(0xffffff, appSettings.direct);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;

        // Optimize Shadow Map (Cleaner edges)
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.bias = -0.0001;
        scene.add(dirLight);

        // 2. RENDERER UPGRADE
        ren = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
        ren.setPixelRatio(window.devicePixelRatio);
        ren.setSize(window.innerWidth, window.innerHeight);

        // Enable PCFSoftShadowMap for smoother shadow edges
        ren.shadowMap.enabled = true;
        ren.shadowMap.type = THREE.PCFSoftShadowMap;

        cam = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 5000);
        cam.position.set(60, -60, 60);
        cam.up.set(0, 0, 1);
        cam.lookAt(0, 0, 0);

        ren = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
        ren.setPixelRatio(window.devicePixelRatio);
        ren.setSize(window.innerWidth, window.innerHeight);

        labelRen = new CSS2DRenderer();
        labelRen.setSize(window.innerWidth, window.innerHeight);
        labelRen.domElement.style.position = 'absolute';
        labelRen.domElement.style.top = '0px';
        labelRen.domElement.className = 'label-overlay';
        container.appendChild(labelRen.domElement);

        ctrl = new OrbitControls(cam, ren.domElement);
        ctrl.enableDamping = true;
            // --- OPTIMIZATION: ADAPTIVE RESOLUTION ---
    // When user drags scene, drop pixel ratio to 1 (Low res)
    // When user stops, restore device pixel ratio (High res / Retina)
        ctrl.addEventListener('start', () => {
            ren.setPixelRatio(1);
        });

        ctrl.addEventListener('end', () => {
            ren.setPixelRatio(window.devicePixelRatio);
        });
          // --- OPTIMIZATION: ADAPTIVE RESOLUTION DONE---
        tCtrl = new TransformControls(cam, ren.domElement);
        tCtrl.addEventListener("dragging-changed", e => { ctrl.enabled = !e.value });
        tCtrl.addEventListener("change", () => {
            updateTinkerLabels();
            updateLiftConePos();
            updateRotationFeedback();
            updatePropertiesPanel();
        });
        tCtrl.addEventListener("mouseUp", () => {
            saveState();
        });
        scene.add(tCtrl);
        // 3. GRID REFERENCE
        gridHelper = new THREE.GridHelper(200, 20);
        gridHelper.rotateX(Math.PI / 2);
        gridHelper.material.opacity = 0.4;
        gridHelper.material.transparent = true;
        scene.add(gridHelper);



        ray = new THREE.Raycaster();
        createLiftCone(); createRotationLabel(); createRuler();

        schematicGroup = new THREE.Group(); scene.add(schematicGroup);
        faceMarkerGroup = new THREE.Group(); scene.add(faceMarkerGroup);

        ren.domElement.addEventListener("pointerdown", onPointerDown);
        ren.domElement.addEventListener("pointermove", onPointerMove);
        ren.domElement.addEventListener("pointerup", onPointerUp);
        window.addEventListener('resize', onWindowResize);

        window.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); window.undo(); }
            if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); window.redo(); }
        });

        document.querySelectorAll('.float-panel').forEach(panel => {
            panel.addEventListener('pointerdown', e => e.stopPropagation());
            panel.addEventListener('mousedown', e => e.stopPropagation());
            panel.addEventListener('touchstart', e => e.stopPropagation());
        });

        // Initialize time for optimization
        then = window.performance.now();
        fpsLastTime = then; // Initialize counter time

// --- OPTIMIZATION GLOBALS ---


    // Call this whenever you change something (move object, change color, add shape)
    window.requestRender = () => { needsRender = true; };

    // Hook into controls to wake up renderer
    ctrl.addEventListener('change', () => { needsRender = true; });
    tCtrl.addEventListener('change', () => { needsRender = true; });

    // Hook into UI interactions
    document.addEventListener('pointerdown', () => { isInteracting = true; needsRender = true; });
    document.addEventListener('pointerup', () => { isInteracting = false; });

    function dLoop(newTime) {
        requestAnimationFrame(dLoop);

        // Always update controls for damping
        ctrl.update();

        // LOGIC:
        // 1. If FPS is locked and too fast, skip.
        // 2. IF nothing has changed AND controls are still, skip render (Save Battery).

        if (isFpsLocked) {
            now = newTime;
            elapsed = now - then;
            if (elapsed < fpsInterval) return;
            then = now - (elapsed % fpsInterval);
        }

        // Only render if something changed or we are interacting
        // We also check 'ctrl.getAzimuthalAngle' indirectly via change listener above
        if (needsRender || isInteracting) {
            ren.render(scene, cam);
            labelRen.render(scene, cam);

            // FPS Counter Logic
            if (appSettings.showFps) {
                fpsFrames++;
                if (newTime >= fpsLastTime + 1000) {
                    const delta = newTime - fpsLastTime;
                    const fps = Math.round((fpsFrames * 1000) / delta);
                    const div = document.getElementById('fps-display');
                    if (div) div.innerText = `FPS: ${fps}`;
                    fpsLastTime = newTime;
                    fpsFrames = 0;
                }
            }

            // If we are not interacting, we can eventually set needsRender to false
            // But because of damping (inertia), we keep it true slightly longer
            // For simple implementation, we assume we need to render if controls change.
            needsRender = false;
        }
    }
        dLoop();

        buildColorPicker();
        window.setMode("translate");

        // Load data safely
        loadFromStorage();
    }

window.updateSettings = (key, value) => {
    // 1. Update State
    if (key === 'ambient' || key === 'direct') value = parseFloat(value);
    appSettings[key] = value;

    // 2. Apply to Scene
    if (key === 'ambient' && ambientLight) ambientLight.intensity = value;
    if (key === 'direct' && dirLight) dirLight.intensity = value;
    if (key === 'grid' && gridHelper) gridHelper.visible = value;

    // 3. Apply FPS Settings
    if (key === 'fps') {
        if (value === 'unlocked') {
            isFpsLocked = false;
        } else {
            isFpsLocked = true;
            fpsInterval = 1000 / parseInt(value);
            then = window.performance.now();
        }
    }
    if (key === 'showFps') {
        const div = document.getElementById('fps-display');
        if (div) div.style.display = value ? 'block' : 'none';

        // Reset counter to avoid immediate jump
        fpsFrames = 0;
        fpsLastTime = performance.now();
    }

    if (key === 'shadows' && dirLight) {
        dirLight.castShadow = value;
        scene.traverse(o => { if(o.material) o.material.needsUpdate = true; });
    }

    if (key === 'wireframe') {
        scene.traverse(child => {
            if (child.isMesh && !child.userData.isRuler && child !== liftCone && child.parent !== faceMarkerGroup) {
                if (child.material) child.material.wireframe = value;
            }
        });
    }

    // 4. Save to LocalStorage
    localStorage.setItem('3d_app_settings', JSON.stringify(appSettings));
};

window.updateStorageUI = () => {
        const bar = document.getElementById('storage-bar');
        const txt = document.getElementById('storage-text');
        if(!bar || !txt) return;

        // If explicitly flagged as full
        if (isStorageFull) {
            bar.style.width = "100%";
            bar.className = 'progress-bar bg-danger';
            txt.innerText = "STORAGE FULL (Limit Reached)";
            return;
        }

        // Standard Calculation
        let total = 0;
        for (let x in localStorage) {
            if (localStorage.hasOwnProperty(x)) {
                total += localStorage[x].length;
            }
        }

        const max = 5 * 1024 * 1024;
        const pct = Math.min((total / max) * 100, 100);

        const usedKB = (total / 1024).toFixed(2);
        const usedMB = (total / (1024 * 1024)).toFixed(2);
        const displayTxt = total > 1024 * 1024 ? `${usedMB} MB` : `${usedKB} KB`;

        bar.style.width = `${pct}%`;
        txt.innerText = `${displayTxt} Used`;

        bar.className = 'progress-bar';
        if(pct < 50) bar.classList.add('bg-success');
        else if(pct < 90) bar.classList.add('bg-warning');
        else bar.classList.add('bg-danger');
    };

    function loadSettings() {
        const saved = localStorage.getItem('3d_app_settings');
        if (saved) {
            try {
                const parsed = JSON.parse(saved);
                appSettings = { ...appSettings, ...parsed };
            } catch (e) { console.warn("Settings corrupted"); }
        }

        // Apply UI values
        document.getElementById('set-ambient').value = appSettings.ambient;
        document.getElementById('set-direct').value = appSettings.direct;
        document.getElementById('set-shadows').checked = appSettings.shadows;
        document.getElementById('set-grid').checked = appSettings.grid;
        document.getElementById('set-wireframe').checked = appSettings.wireframe;

        // Apply FPS UI
        const fpsSelect = document.getElementById('set-fps');
        if(fpsSelect) fpsSelect.value = appSettings.fps;
        // Apply UI for FPS Toggle
        const fpsToggle = document.getElementById('set-show-fps');
        if(fpsToggle) fpsToggle.checked = appSettings.showFps;

        // Apply to Scene
        if(ambientLight) ambientLight.intensity = appSettings.ambient;
        if(dirLight) {
            dirLight.intensity = appSettings.direct;
            dirLight.castShadow = appSettings.shadows;
        }
        if(gridHelper) gridHelper.visible = appSettings.grid;

        // Trigger FPS setup
        window.updateSettings('fps', appSettings.fps);
        // Trigger update to set visibility
        window.updateSettings('showFps', appSettings.showFps);
        setTimeout(() => {
            window.updateSettings('wireframe', appSettings.wireframe);
        }, 100);
    }

    window.resetSettings = () => {
        appSettings = { ambient: 0.8, direct: 1.0, shadows: true, grid: true, wireframe: false };
        localStorage.removeItem('3d_app_settings');
        loadSettings(); // Reloads UI and Scene
    };
    function onWindowResize() {
        cam.aspect = window.innerWidth / window.innerHeight;
        cam.updateProjectionMatrix();
        ren.setSize(window.innerWidth, window.innerHeight);
        if(labelRen) labelRen.setSize(window.innerWidth, window.innerHeight);
    }

    // --- DIMENSION LABELS ---
    function addDimensionLines(start, end, offset, color = 0x000000) {
        // Material for the faint extension lines
        const extMaterial = new THREE.LineBasicMaterial({ color: 0x888888, linewidth: 1, opacity: 0.4, transparent: true });
        // Material for the main dimension line
        const connMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: 2, depthTest: false, depthWrite: false });

        // Calculate start/end points with the offset applied
        const offS = start.clone().add(offset);
        const offE = end.clone().add(offset);

        // Draw Extension Lines (From object to measurement point)
        schematicGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([start, offS]), extMaterial));
        schematicGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([end, offE]), extMaterial));

        // Draw Connector Line (The main line between measurements)
        const connLine = new THREE.Line(new THREE.BufferGeometry().setFromPoints([offS, offE]), connMaterial);
        connLine.renderOrder = 999;
        schematicGroup.add(connLine);

        // Return the midpoint (where the text label goes)
        return offS.clone().lerp(offE, 0.5);
    }

    function createInputLabel(pos, value, type, callback) {
        const div = document.createElement('div');
        div.className = 'tinker-label-container';
        const input = document.createElement('input');
        input.type = 'text';
        input.className = `tinker-input ${type === 'size' ? 'dim-size' : 'dim-pos'}`;
        const displayVal = Math.round(value * 10) / 10;
        input.value = displayVal;
        input.setAttribute('value', displayVal);
        input.addEventListener('pointerdown', e => e.stopPropagation());
        input.addEventListener('mousedown', e => e.stopPropagation());
        input.addEventListener('keydown', e => { if(e.key === 'Enter') input.blur(); });
        input.addEventListener('change', () => {
            const val = parseFloat(input.value);
            if(!isNaN(val)) { callback(val); saveState(); }
        });
        div.appendChild(input);
        const label = new CSS2DObject(div);
        label.position.copy(pos);
        scene.add(label);
        activeLabels.push(label);
        return label;
    }

function updateTinkerLabels() {
        // 1. Cleanup Old Labels
        activeLabels.forEach(l => scene.remove(l));
        activeLabels.length = 0;
        while(schematicGroup.children.length > 0){ schematicGroup.remove(schematicGroup.children[0]); }

        // 2. Validate Selection
        if(selectedObjects.length !== 1 || isFaceLoftMode) return;
        const obj = selectedObjects[0];
        if(obj.userData.isRuler) return;

        const box = new THREE.Box3().setFromObject(obj);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3()); // NEW: Get Center

        // ============================================
        // PART A: OBJECT SIZE (Always On - Gray/Black)
        // ============================================
        // (This remains unchanged - measures total size)

        // Width (X Size)
        const sizeXPos = addDimensionLines(
            new THREE.Vector3(box.min.x, box.max.y, box.min.z),
            new THREE.Vector3(box.max.x, box.max.y, box.min.z),
            new THREE.Vector3(0, 5, 0), 0x444444
        );
        createInputLabel(sizeXPos, size.x, 'size', (v) => resizeObject(obj, 'x', v));

        // Length (Y Size)
        const sizeYPos = addDimensionLines(
            new THREE.Vector3(box.min.x, box.min.y, box.min.z),
            new THREE.Vector3(box.min.x, box.max.y, box.min.z),
            new THREE.Vector3(-5, 0, 0), 0x444444
        );
        createInputLabel(sizeYPos, size.y, 'size', (v) => resizeObject(obj, 'y', v));

        // Height (Z Size)
        const sizeZPos = addDimensionLines(
            new THREE.Vector3(box.max.x, box.min.y, box.min.z),
            new THREE.Vector3(box.max.x, box.min.y, box.max.z),
            new THREE.Vector3(10, 0, 0), 0x444444
        );
        createInputLabel(sizeZPos, size.z, 'size', (v) => resizeObject(obj, 'z', v));


        // ============================================
        // PART B: RULER RELATIVE (Toggle - Blue)
        // ============================================
        if (showRuler && rulerGroup) {
            const rPos = rulerGroup.position;

            // --- 1. X DISTANCE ---
            let valX, startPtX, endPtX;

            if (rulerMode === 'midpoint') {
                // Measure to Center X
                valX = center.x - rPos.x;
                startPtX = new THREE.Vector3(rPos.x, box.min.y, 0);
                endPtX = new THREE.Vector3(center.x, box.min.y, 0); // To Center
            } else {
                // Measure to Left Edge (Min X)
                valX = box.min.x - rPos.x;
                startPtX = new THREE.Vector3(rPos.x, box.min.y, 0);
                endPtX = new THREE.Vector3(box.min.x, box.min.y, 0); // To Edge
            }

            const labelPosX = addDimensionLines(startPtX, endPtX, new THREE.Vector3(0, -25, 0), 0x0d6efd);
            createInputLabel(labelPosX, valX, 'pos', (newVal) => {
                const diff = newVal - valX;
                obj.position.x += diff;
                obj.updateMatrixWorld();
                updateTinkerLabels();
                saveState();
                window.requestRender();
            });


            // --- 2. Y DISTANCE ---
            let valY, startPtY, endPtY;

            if (rulerMode === 'midpoint') {
                // Measure to Center Y
                valY = center.y - rPos.y;
                startPtY = new THREE.Vector3(box.min.x, rPos.y, 0);
                endPtY = new THREE.Vector3(box.min.x, center.y, 0); // To Center
            } else {
                // Measure to Bottom Edge (Min Y)
                valY = box.min.y - rPos.y;
                startPtY = new THREE.Vector3(box.min.x, rPos.y, 0);
                endPtY = new THREE.Vector3(box.min.x, box.min.y, 0); // To Edge
            }

            const labelPosY = addDimensionLines(startPtY, endPtY, new THREE.Vector3(-25, 0, 0), 0x0d6efd);
            createInputLabel(labelPosY, valY, 'pos', (newVal) => {
                const diff = newVal - valY;
                obj.position.y += diff;
                obj.updateMatrixWorld();
                updateTinkerLabels();
                saveState();
                window.requestRender();
            });


            // --- 3. Z DISTANCE (LIFT) ---
            // Note: Usually "Lift" is always measured from the bottom, even in midpoint mode.
            // But we keep the line visually consistent.
            const currentDistZ = box.min.z - rPos.z;
            const rulerFloorPt = new THREE.Vector3(box.max.x, box.min.y, rPos.z);
            const objectBottomPt = new THREE.Vector3(box.max.x, box.min.y, box.min.z);

            const labelPosZ = addDimensionLines(rulerFloorPt, objectBottomPt, new THREE.Vector3(25, 0, 0), 0x0d6efd);
            createInputLabel(labelPosZ, currentDistZ, 'pos', (newVal) => {
                const diff = newVal - currentDistZ;
                obj.position.z += diff;
                obj.updateMatrixWorld();
                updateTinkerLabels();
                updateLiftConePos();
                saveState();
                window.requestRender();
            });
        }
    }

    // Updated Resize to handle scale limits better prevents inverting shapes
    function resizeObject(mesh, axis, targetSize) {
        if(targetSize <= 0.1) return;

        // Ensure matrix is up to date before measuring
        mesh.updateMatrixWorld();

        const box = new THREE.Box3().setFromObject(mesh);
        const currentSize = box.getSize(new THREE.Vector3());

        // Prevent division by zero
        if(Math.abs(currentSize[axis]) < 0.01) return;

        const scaleFactor = targetSize / currentSize[axis];

        // Apply scale
        mesh.scale[axis] *= scaleFactor;

        mesh.updateMatrixWorld();
        updateTinkerLabels();
        updatePropertiesPanel();
        saveState();
    }

    // --- INTERACTION ---
// --- IMPROVED INTERACTION LOGIC ---

    // 1. Variables to track "Click vs Drag"
    let pointerStartX = 0;
    let pointerStartY = 0;

    // 2. UPDATED POINTER DOWN
    const onPointerDown = e => {
        // Just record position, don't trigger logic yet
        pointerStartX = e.clientX;
        pointerStartY = e.clientY;

        // Handle Lift Tool (Exceptions)
        if (liftCone.visible) {
            const rect = ren.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1);
            ray.setFromCamera(mouse, cam);
            const coneHit = ray.intersectObject(liftCone);
            if (coneHit.length > 0) {
                isLifting = true;
                ctrl.enabled = false;
                liftStartMouseY = e.clientY;
                liftStartObjZ = selectedObjects[0].position.z;
                liftCone.material.color.setHex(0xffff00);
            }
        }

        // Mark interaction for render loop
        isInteracting = true;
        window.requestRender();
    };

    // 3. UPDATED POINTER UP (The Brains)
    const onPointerUp = e => {
        isInteracting = false; // Stop high-refresh rendering

        // Check for Lift Tool
        if (isLifting) {
            isLifting = false;
            ctrl.enabled = true;
            liftCone.material.color.setHex(0x222222);
            saveState();
            return;
        }

        // --- CALCULATE DRAG DISTANCE ---
        const dist = Math.sqrt(Math.pow(e.clientX - pointerStartX, 2) + Math.pow(e.clientY - pointerStartY, 2));

        // If moved more than 5 pixels, it was a Camera Rotation/Zoom. Ignore click.
        if (dist > 5) return;

        // --- NEW: CLICK TO PLACE TEXT ---
        if (textPlaceMode) {
             if (textGhost && textGhost.visible) {
                // PASS THE CALCULATED BEND
                const bend = textGhost.userData.geoParams ? textGhost.userData.geoParams.bend : 0;
                createTextObject(textGhost.position, textGhost.quaternion, bend);
             }

             // Cleanup
             textPlaceMode = false;
             scene.remove(textGhost);
             textGhost = null;
             document.body.style.cursor = 'default';
             const status = document.getElementById("auto-save-status");
             status.style.opacity = 0;
             return;
        }
        // --- CLICK LOGIC BELOW ---
        if (e.target.tagName === 'INPUT') return;
        if (tCtrl.dragging || tCtrl.axis) return;

        const rect = ren.domElement.getBoundingClientRect();
        const mouse = new THREE.Vector2(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1);
        ray.setFromCamera(mouse, cam);

        // A. ALIGN TOOL
        if (alignState !== 'none') {
            if(handleAlignClick(ray)) return;
        }

        // B. LOFT FACE SELECTION
        if (isFaceLoftMode) {
            const intersects = ray.intersectObjects(scene.children.filter(o => o.isMesh && o !== liftCone && !o.userData.isRuler && o.visible), false);
            if (intersects.length > 0) handleFaceSelection(intersects[0]);
            return;
        }

        // C. STANDARD SELECTION
        const intersects = ray.intersectObjects(scene.children, true);
        const validHits = intersects.filter(hit => {
            const o = hit.object;
            let p = o.parent;
            while(p) { if(p === schematicGroup || p === faceMarkerGroup) return false; p = p.parent; }
            return (o.isMesh || o.isLine) && o !== liftCone && o !== schematicGroup && o !== faceMarkerGroup;
        });

        if (validHits.length > 0) {
            let hitObj = validHits[0].object;
            let parent = hitObj.parent;
            if(parent && parent.userData && parent.userData.isRuler) selectObject(parent);
            else if (hitObj.userData.name) selectObject(hitObj, e.shiftKey);
        } else {
            selectObject(null);
        }
    };

    function handleFaceSelection(hit) {
        const mesh = hit.object;
        const hitNormal = hit.face.normal.clone();
        const existingIdx = selectedFacesData.findIndex(f => f.meshUuid === mesh.uuid && f.normal.dot(hitNormal) > 0.99);

        if (existingIdx > -1) {
            selectedFacesData.splice(existingIdx, 1);
            const marker = faceMarkerGroup.children.find(m => m.userData.meshUuid === mesh.uuid && m.userData.normal.dot(hitNormal) > 0.99);
            if (marker) faceMarkerGroup.remove(marker);
        } else {
            const surfaceData = getConnectedFlatSurface(mesh, hit.faceIndex, hit.face.normal);
            const worldPoints = [];
            const posAttr = mesh.geometry.attributes.position;
            const uniqueIndices = [...new Set(surfaceData.indices)];
            uniqueIndices.forEach(idx => {
                const vec = new THREE.Vector3().fromBufferAttribute(posAttr, idx);
                vec.applyMatrix4(mesh.matrixWorld);
                worldPoints.push(vec);
            });
            selectedFacesData.push({ meshUuid: mesh.uuid, normal: hitNormal, points: worldPoints });
            const markerGeo = new THREE.BufferGeometry();
            const markerPositions = [];
            for(let i = 0; i < surfaceData.indices.length; i++) {
                const idx = surfaceData.indices[i];
                markerPositions.push(posAttr.getX(idx), posAttr.getY(idx), posAttr.getZ(idx));
            }
            markerGeo.setAttribute('position', new THREE.Float32BufferAttribute(markerPositions, 3));
            const markerMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide, transparent: true, opacity: 0.5, depthTest: false });
            const markerMesh = new THREE.Mesh(markerGeo, markerMat);
            markerMesh.position.copy(mesh.position);
            markerMesh.rotation.copy(mesh.rotation);
            markerMesh.scale.copy(mesh.scale);
            markerMesh.userData = { meshUuid: mesh.uuid, normal: hitNormal };
            faceMarkerGroup.add(markerMesh);
        }
    }

function getConnectedFlatSurface(mesh, startFaceIndex, targetNormal) {
        const geo = mesh.geometry;
        const posAttr = geo.attributes.position;
        const count = posAttr.count;

        // 1. Helper: Lower precision key to bridge CSG gaps
        // Using *10 instead of *100 allows vertices within ~0.1 to match
        const getVertKey = (idx) => {
            const x = posAttr.getX(idx);
            const y = posAttr.getY(idx);
            const z = posAttr.getZ(idx);
            return `${Math.round(x*10)},${Math.round(y*10)},${Math.round(z*10)}`;
        };

        const _vA = new THREE.Vector3(), _vB = new THREE.Vector3(), _vC = new THREE.Vector3();
        const _cb = new THREE.Vector3(), _ab = new THREE.Vector3();

        const getFaceNormal = (faceIdx, target) => {
            const a = faceIdx * 3;
            const b = faceIdx * 3 + 1;
            const c = faceIdx * 3 + 2;
            _vA.fromBufferAttribute(posAttr, a);
            _vB.fromBufferAttribute(posAttr, b);
            _vC.fromBufferAttribute(posAttr, c);
            _cb.subVectors(_vC, _vB);
            _ab.subVectors(_vA, _vB);
            _cb.cross(_ab).normalize();
            target.copy(_cb);
        };

        // 2. Build Adjacency Graph
        const vertToFaces = {};
        const totalFaces = count / 3;

        for (let f = 0; f < totalFaces; f++) {
            for (let v = 0; v < 3; v++) {
                const key = getVertKey(f * 3 + v);
                if (!vertToFaces[key]) vertToFaces[key] = [];
                vertToFaces[key].push(f);
            }
        }

        // 3. FLOOD FILL
        const selectedFaces = new Set();
        const queue = [startFaceIndex];
        selectedFaces.add(startFaceIndex);

        const tempNormal = new THREE.Vector3();

        while (queue.length > 0) {
            const currentFace = queue.pop();

            // Check all 3 vertices to find neighbors
            for (let v = 0; v < 3; v++) {
                const key = getVertKey(currentFace * 3 + v);
                const neighbors = vertToFaces[key];

                if (neighbors) {
                    for (let n of neighbors) {
                        if (selectedFaces.has(n)) continue;

                        // STRICT Normal Check: prevents jumping to side walls
                        getFaceNormal(n, tempNormal);
                        if (tempNormal.dot(targetNormal) > 0.999) { // Increased to 0.999 for safety

                            // RELAXED Connectivity Check:
                            // Just 1 shared vertex is enough if the normal is identical.
                            // This fixes the "Ring" issue.
                            let sharedVerts = 0;
                            for(let k=0; k<3; k++) {
                                const kKey = getVertKey(currentFace * 3 + k);
                                for(let j=0; j<3; j++) {
                                    if(kKey === getVertKey(n * 3 + j)) sharedVerts++;
                                }
                            }

                            if(sharedVerts >= 1) {
                                selectedFaces.add(n);
                                queue.push(n);
                            }
                        }
                    }
                }
            }
        }

        const indices = [];
        selectedFaces.forEach(f => {
            indices.push(f * 3, f * 3 + 1, f * 3 + 2);
        });

        return { indices };
    }

// 1. START PLACEMENT MODE
    window.dStartText = () => {
        if(!loadedFont) return alert("Font loading... try again in a second.");

        // Deselect everything
        selectObject(null);

        // Enter Mode
        textPlaceMode = true;
        document.body.style.cursor = 'crosshair';

        // Create Ghost
        const geo = new TextGeometry('Text', { font: loadedFont, size: 10, height: 2, curveSegments: 4 });
        geo.center();

        // Create a parent wrapper to handle the offset easily
        textGhost = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: 0x0d6efd, transparent: true, opacity: 0.5, wireframe: true }));
        textGhost.userData.isGhost = true;
        scene.add(textGhost);

        const status = document.getElementById("auto-save-status");
        status.innerText = "Click on a surface to place text";
        status.style.opacity = 1;
    };

    // 2. CREATE THE REAL TEXT
function createTextObject(pos, quat, bendValue) { // Added bendValue param
        const textString = "Text";

        // Use the new helper to generate the initial geometry with the correct bend
        const dummyMesh = {
            userData: { geoParams: { type: 'text', text: textString, bend: bendValue || 0 } },
            geometry: null
        };

        // We hijack the regenerate function to create our first geometry
        // Use a temp geometry to start
        dummyMesh.geometry = new TextGeometry(textString, { font: loadedFont, size: 10, height: 2, curveSegments: 4 });
        regenerateText(dummyMesh); // This applies the bend math immediately

        const mat = new THREE.MeshStandardMaterial({ color: 0x0d6efd });
        const mesh = new THREE.Mesh(dummyMesh.geometry, mat);

        mesh.position.copy(pos);
        mesh.quaternion.copy(quat);

        const nameCount = scene.children.filter(e => e.userData && e.userData.name && e.userData.name.startsWith("Text")).length + 1;
        mesh.userData = {
            name: `Text ${nameCount}`,
            isHole: false,
            geoParams: { type: 'text', text: textString, bend: bendValue || 0 }
        };

        mesh.castShadow = true;
        mesh.receiveShadow = true;

        scene.add(mesh);
        selectObject(mesh);
        saveState();
    }

    // 3. REGENERATE TEXT (When typing or bending)
function regenerateText(mesh) {
        // SAFETY CHECK
        if (!loadedFont) {
            console.warn("Font not loaded yet, skipping regeneration");
            return;
        }
        const p = mesh.userData.geoParams;
        if(!p || p.type !== 'text') return;

        // 1. Create Base Geometry
        let geo = new TextGeometry(p.text, {
            font: loadedFont,
            size: 10,
            height: 2, // This is the Z-thickness
            curveSegments: 4
        });

        // Center X/Y but keep Z at 0 (back of text) for easier bending
        geo.computeBoundingBox();
        const centerOffset = - 0.5 * ( geo.boundingBox.max.x - geo.boundingBox.min.x );
        const centerOffsetY = - 0.5 * ( geo.boundingBox.max.y - geo.boundingBox.min.y );
        geo.translate( centerOffset, centerOffsetY, 0 );

        // 2. APPLY BEND (The "Wrapping" Logic)
        // We use 'curvature' (1/radius). 0 = Flat. 0.1 = Radius 10.
        if (Math.abs(p.bend) > 0.001) {
            const posAttribute = geo.attributes.position;
            const vertex = new THREE.Vector3();

            // Calculate Radius from Curvature
            // p.bend is now "Curvature".
            // If bend is 0.05, Radius is 20.
            const radius = 1 / p.bend;

            for ( let i = 0; i < posAttribute.count; i ++ ) {
                vertex.fromBufferAttribute( posAttribute, i );

                // The "Depth" of this vertex (0 to 2)
                const zDepth = vertex.z;

                // The effective radius for THIS vertex (Thickness preservation)
                // We wrap around the cylinder. The back of text is at 'radius'.
                // The front of text is at 'radius + zDepth'.
                const effectiveR = radius + zDepth;

                // Calculate angle based on X position
                const angle = vertex.x / radius;

                // New positions (Cylindrical coordinates)
                // We subtract radius from Z at the end to bring the "back" of the text to Z=0
                const nx = effectiveR * Math.sin(angle);
                const nz = effectiveR * Math.cos(angle) - radius;

                posAttribute.setXYZ( i, nx, vertex.y, nz );
            }

            geo.computeVertexNormals();
        }

        // 3. Update Mesh
        mesh.geometry.dispose();
        mesh.geometry = geo;

        // IMPORTANT: Re-calculate bounds so the Selection Box / Gizmo matches the new curved shape
        mesh.geometry.computeBoundingBox();

        window.requestRender();
    }


window.reSnapText = () => {
        if(selectedObjects.length !== 1) return;
        const obj = selectedObjects[0];
        if(!obj.userData.geoParams || obj.userData.geoParams.type !== 'text') return;

        // 1. Setup Ray from Object Center, pointing "Inwards" (Local -Z)
        const origin = obj.position.clone();
        // The text's "back" is its local negative Z? Actually we oriented Z as Normal.
        // So we cast ray in direction of -Z (into the surface)
        const direction = new THREE.Vector3(0,0,-1).applyQuaternion(obj.quaternion).normalize();

        // Start ray slightly "above" text to ensure we hit the surface
        const startPt = origin.clone().sub(direction.clone().multiplyScalar(2)); // Back up 2 units

        ray.set(startPt, direction);

        // Filter out the text itself
        const targets = scene.children.filter(o => o.isMesh && o !== obj && !o.userData.isGhost && !o.userData.isRuler && o !== liftCone);
        const intersects = ray.intersectObjects(targets, false);

        if(intersects.length > 0) {
            const hit = intersects[0];
            // Reuse the math from onPointerMove...
            // Or simpler: Just calculate the curvature logic here.

            // ... Copy/Paste the "UNIVERSAL CURVATURE DETECTION" block from onPointerMove here ...
            // ... using 'hit' as the target ...

            // Simplified Logic for Re-Snap:
            const normal = hit.face.normal.clone().applyQuaternion(hit.object.quaternion).normalize();

            // Re-Align Rotation (Optional, maybe user likes their rotation?)
            // Let's just update the BEND for now to avoid flipping rotated text.

            const rightVec = new THREE.Vector3(1,0,0).applyQuaternion(obj.quaternion).normalize();
            const sampleDist = 5.0;
            const leftOrigin = hit.point.clone().sub(rightVec.clone().multiplyScalar(sampleDist)).add(normal.clone().multiplyScalar(2));
            const rightOrigin = hit.point.clone().add(rightVec.clone().multiplyScalar(sampleDist)).add(normal.clone().multiplyScalar(2));

            const rayDown = new THREE.Raycaster();
            const dir = normal.clone().negate();
            rayDown.set(leftOrigin, dir);
            const lHit = rayDown.intersectObject(hit.object, false);
            rayDown.set(rightOrigin, dir);
            const rHit = rayDown.intersectObject(hit.object, false);

            if(lHit.length>0 && rHit.length>0) {
                 const lNorm = lHit[0].face.normal.clone().applyQuaternion(hit.object.quaternion).normalize();
                 const rNorm = rHit[0].face.normal.clone().applyQuaternion(hit.object.quaternion).normalize();
                 const angle = lNorm.angleTo(rNorm);
                 if (angle > 0.001) {
                     const newBend = (angle / (sampleDist * 2)) * 1.0;
                     obj.userData.geoParams.bend = newBend;
                     regenerateText(obj);
                     updatePropertiesPanel(); // Refresh slider
                     saveState();
                 }
            }
        } else {
            alert("No surface found behind text to snap to.");
        }
    };

const onPointerMove = e => {
        // BUG FIX: Don't set isInteracting = true here.
        // We only want a single frame update for hovering, not a continuous loop.
        window.requestRender();

        // --- NEW: TEXT PLACEMENT GHOST ---
// --- ADVANCED TEXT PLACEMENT ---
        if (textPlaceMode && textGhost) {
            const rect = ren.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1);
            ray.setFromCamera(mouse, cam);

            // 1. Raycast Center
            const targets = scene.children.filter(o => o.isMesh && !o.userData.isGhost && !o.userData.isRuler && o !== liftCone);
            const intersects = ray.intersectObjects(targets, false);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const pt = hit.point;
                const normal = hit.face.normal.clone().applyQuaternion(hit.object.quaternion).normalize();

                // 2. STABLE ROTATION (No upside down flipping)
                // We want the text's "Up" (Local Y) to align with Surface Normal (Z in our text logic?)
                // Actually TextGeometry is created on XY plane.
                // So Local Z = Surface Normal.

                // Calculate a stable "Right" vector (Local X) that is parallel to the horizon
                const worldUp = new THREE.Vector3(0, 0, 1);
                let rightVec = new THREE.Vector3();

                // If surface is floor/ceiling, define arbitrary right
                if (Math.abs(normal.dot(worldUp)) > 0.99) {
                    rightVec.set(1, 0, 0);
                } else {
                    // Cross WorldUp with Normal to get a horizon line
                    rightVec.crossVectors(worldUp, normal).normalize();
                    // If looking "backwards", flip it to keep text readable left-to-right
                    // (Simple heuristic: assumes camera is somewhat upright)
                }

                // Create Basis Matrix
                const upVec = new THREE.Vector3().crossVectors(normal, rightVec).normalize();
                const basis = new THREE.Matrix4().makeBasis(rightVec, upVec, normal);
                textGhost.quaternion.setFromRotationMatrix(basis);

                // Position with nudge
                textGhost.position.copy(pt).add(normal.clone().multiplyScalar(0.5));
                textGhost.visible = true;

                // 3. UNIVERSAL CURVATURE DETECTION (Tri-Ray Sample)
                // We cast rays to the Left and Right of the hit point to measure surface angle
                const sampleDist = 5.0; // Check 5mm to the side
                const leftOrigin = pt.clone().sub(rightVec.clone().multiplyScalar(sampleDist)).add(normal.clone().multiplyScalar(2));
                const rightOrigin = pt.clone().add(rightVec.clone().multiplyScalar(sampleDist)).add(normal.clone().multiplyScalar(2));

                // Cast rays "Down" towards the surface (-Normal)
                const rayDown = new THREE.Raycaster();
                const dir = normal.clone().negate();

                rayDown.set(leftOrigin, dir);
                const leftHits = rayDown.intersectObject(hit.object, false);

                rayDown.set(rightOrigin, dir);
                const rightHits = rayDown.intersectObject(hit.object, false);

                let autoBend = 0;

                if (leftHits.length > 0 && rightHits.length > 0) {
                    const lNorm = leftHits[0].face.normal.clone().applyQuaternion(hit.object.quaternion).normalize();
                    const rNorm = rightHits[0].face.normal.clone().applyQuaternion(hit.object.quaternion).normalize();

                    // Angle between normals
                    let angle = lNorm.angleTo(rNorm);

                    // Convex or Concave? Check dot product with center normal
                    // Simple convex assumption for now (Curve wrap).
                    // Calculation: Curvature = Angle / ArcLength (approx Distance)
                    // Note: If normals point away, it's convex (+). If they point in, concave (-).
                    // We assume convex for external placement.

                    if (angle > 0.01) {
                         // Curvature K = 1/R.
                         // If we are placing on outside, we wrap positive.
                         // Using a dampener because the math for text bending is sensitive
                         autoBend = (angle / (sampleDist * 2)) * 1.0;
                    }
                }

                // Apply
                 if (!textGhost.userData.geoParams) textGhost.userData.geoParams = { type: 'text', text: 'Text', bend: 0 };
                 if (Math.abs(textGhost.userData.geoParams.bend - autoBend) > 0.005) {
                    textGhost.userData.geoParams.bend = autoBend;
                    regenerateText(textGhost);
                }

            } else {
                textGhost.visible = false;
            }
            return;
        }

        // 1. UPDATE GHOST IF IN ALIGN MODE
        if (alignState !== 'none' && e.buttons === 0) {
            const rect = ren.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1);
            ray.setFromCamera(mouse, cam);
            handleAlignHover(ray, mouse);
            return;
        }

        // ... Existing Lift Logic ...
        if (isLifting && selectedObjects.length === 1) {
            const deltaY = liftStartMouseY - e.clientY;
            selectedObjects[0].position.z = liftStartObjZ + (deltaY * 0.2);
            updateLiftConePos();
            updateTinkerLabels();
            updatePropertiesPanel();
        }
    };


    window.setMode = mode => { if(tCtrl) tCtrl.setMode(mode); document.querySelectorAll(".btn-tool").forEach(b => b.classList.remove("active-tool")); const btn = document.querySelector(`button[data-mode="${mode}"]`); if(btn) btn.classList.add("active-tool"); };

// --- GEOMETRY GENERATOR (FIXED AXIS) ---

    window.dAdd = type => {
        let geo, params = {};
        const nameCount = scene.children.filter(e => e.userData && e.userData.name).length + 1;
        let baseName = "Shape";
        const defaultChamfer = 0;

        switch (type) {
            case "cube":
                geo = new RoundedBoxGeometry(20, 20, 20, 4, defaultChamfer);
                baseName = "Cube";
                params = { type: 'box', w: 20, h: 20, d: 20, r: defaultChamfer };
                break;

            case "cyl":
                baseName = "Cylinder";
                // Standard Cylinder is Y-up. We rotate it to Z-up.
                geo = new THREE.CylinderGeometry(10, 10, 20, 32);
                geo.rotateX(Math.PI/2);
                params = { type: 'cylinder', rt: 10, rb: 10, h: 20, s: 32, chamfer: defaultChamfer };
                break;

            case "cone":
                baseName = "Cone";
                geo = new THREE.CylinderGeometry(0, 10, 20, 64);
                geo.rotateX(Math.PI/2);
                params = { type: 'cone', rt: 0, rb: 10, h: 20, s: 64, chamfer: defaultChamfer };
                break;

            case "wedge":
                baseName = "Wedge";
                geo = new THREE.CylinderGeometry(10, 10, 20, 3);
                geo.rotateZ(Math.PI / 6);
                geo.rotateX(Math.PI / 2); // Rotate Upright (Z-up)
                params = { type: 'wedge', rt: 10, rb: 10, h: 20, s: 3, chamfer: defaultChamfer };
                break;

            case "sph":
                geo = new THREE.SphereGeometry(10, 32, 32);
                baseName = "Sphere";
                params = { type: 'sphere', r: 10, wSeg: 32, hSeg: 32 };
                break;

            case "torus":
                geo = new THREE.TorusGeometry(10, 3, 16, 32);
                baseName = "Torus";
                params = { type: 'torus', r: 10, t: 3, rSeg: 16, tSeg: 32 };
                break;
        }

        // Note: We no longer rotate the MESH. We rotated the GEOMETRY above.
        // This keeps Scale X=Width, Scale Y=Depth, Scale Z=Height consistent.
        buildAndAddMesh(geo, `${baseName} ${nameCount}`, params);
    };

    function generateExtrudedGeo(p) {
        const shape = new THREE.Shape();
        const bevel = p.chamfer || 0;

        // LOGIC: Adjust radius so adding chamfer doesn't make object wider
        // We subtract the bevel size from the base radius.

        if (p.type === 'cylinder' || p.type === 'cone') {
            if (Math.abs(p.rt - p.rb) > 0.1) {
                // Tapered: Fallback to Standard (Z-up)
                const g = new THREE.CylinderGeometry(p.rt, p.rb, p.h, p.s);
                g.rotateX(Math.PI/2);
                return g;
            } else {
                // Straight: Extrude (Naturally Z-up)
                const r = Math.max(0.1, p.rb - bevel); // Subtract bevel
                shape.absarc(0, 0, r, 0, Math.PI * 2, false);
            }
        }
        else if (p.type === 'wedge') {
            if (Math.abs(p.rt - p.rb) > 0.1) {
                const g = new THREE.CylinderGeometry(p.rt, p.rb, p.h, p.s);
                g.rotateZ(Math.PI / 6);
                g.rotateX(Math.PI / 2);
                return g;
            }
            const r = Math.max(0.1, p.rb - bevel);
            const step = (Math.PI * 2) / 3;
            // Draw triangle
            shape.moveTo(r * Math.cos(0), r * Math.sin(0));
            shape.lineTo(r * Math.cos(step), r * Math.sin(step));
            shape.lineTo(r * Math.cos(step*2), r * Math.sin(step*2));
            shape.lineTo(r * Math.cos(0), r * Math.sin(0));
        }

        const extrudeSettings = {
            depth: p.h - (bevel * 2), // Subtract bevel from height
            bevelEnabled: bevel > 0,
            bevelThickness: bevel,
            bevelSize: bevel,
            bevelSegments: 4,
            curveSegments: p.s
        };

        const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        geo.center();

        // ExtrudeGeometry is created in XY and extruded Z. It is ALREADY Z-up.
        // We do NOT need to rotate it.

        return geo;
    }

    function regenerateGeometry(mesh) {
        const p = mesh.userData.geoParams;
        if (!p) return;

        let newGeo;

        if (p.type === 'box') {
            newGeo = new RoundedBoxGeometry(p.w, p.h, p.d, 4, p.r || 0);
        }
        else if (p.type === 'cylinder' || p.type === 'cone') {
            newGeo = generateExtrudedGeo(p);
        }
        else if (p.type === 'wedge') {
            newGeo = generateExtrudedGeo(p);
        }
        else if (p.type === 'torus') {
            newGeo = new THREE.TorusGeometry(p.r, p.t, p.rSeg, p.tSeg);
        }
        else if (p.type === 'sphere') {
            newGeo = new THREE.SphereGeometry(p.r, p.wSeg, p.wSeg);
        }

        if (newGeo) {
            newGeo.computeBoundingBox();
            if(p.type !== 'box') newGeo.center();
            mesh.geometry.dispose();
            mesh.geometry = newGeo;
            updateTinkerLabels();
            window.requestRender();
        }
    }

    // Function for Merged Objects (Fake Chamfer via Normals)
    window.updateSmoothness = (val) => {
        if(selectedObjects.length !== 1) return;
        const obj = selectedObjects[0];

        // Only for merged objects or non-parametric meshes
        if(obj.userData.geoParams) {
            // Parametric: Update the 'r' or 'chamfer' param
            obj.userData.geoParams.r = val; // For Box
            obj.userData.geoParams.chamfer = val; // For Extrusions
            regenerateGeometry(obj);
        } else {
            // Merged: Smooth Shading Logic
            const geo = obj.geometry;

            if (val > 0) {
                // Smooth: Merge vertices to allow normal smoothing
                if (!geo.userData.merged) {
                    const mergedGeo = mergeVertices(geo, 0.01);
                    obj.geometry.dispose();
                    obj.geometry = mergedGeo;
                    obj.geometry.userData.merged = true;
                }
                obj.geometry.computeVertexNormals();
                obj.material.flatShading = false;
            } else {
                // Sharp: Use flat shading
                obj.material.flatShading = true;
            }
            obj.material.needsUpdate = true;
        }
        window.requestRender();
        saveState();
    };

function buildAndAddMesh(geometry, name, geoParams = null, incomingMaterial = null) {
        // Ensure UVs exist (Critical for textures)
        if (!geometry.attributes.uv) {
            const count = geometry.attributes.position.count;
            geometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(count * 2), 2));
        }

        // Center the geometry for easier manipulation
        geometry.computeBoundingBox();
        geometry.center();

        let material;

        if (incomingMaterial) {
            // 1. USE IMPORTED MATERIAL (TEXTURES)
            // We clone it so if you import the same file twice, you can edit them independently
            material = incomingMaterial.clone();

            // Ensure wireframe toggle respects global settings
            material.wireframe = appSettings.wireframe;

            // Fix for some scanners exporting dark materials
            if(material.map) material.map.colorSpace = THREE.SRGBColorSpace;

            // Ensure we can see it (some imports come in with 0 opacity)
            material.transparent = false;
            material.opacity = 1.0;
        } else {
            // 2. DEFAULT BLUE MATERIAL
            material = new THREE.MeshStandardMaterial({
                color: 0x0d6efd,
                roughness: 0.4,
                metalness: 0.2,
                wireframe: appSettings.wireframe
            });
        }

        const mesh = new THREE.Mesh(geometry, material);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.position.set(0, 0, 10);

        mesh.userData = { isHole: false, name: name, geoParams: geoParams };

        scene.add(mesh);
        selectObject(mesh);
        updateObjectList();
        saveState();
        window.requestRender();

        return mesh;
    }
function updateParametricUI(obj) {
        const container = document.getElementById("shape-params");
        container.innerHTML = ""; // Clear previous

        if (!obj.userData.geoParams) {
            container.style.display = "none";
            return;
        }

        container.style.display = "block";
        const p = obj.userData.geoParams;

        // Helper to create slider
        const addSlider = (label, key, min, max, step) => {
            const div = document.createElement("div");
            div.className = "d-flex justify-content-between align-items-center mb-1";
            div.innerHTML = `
                <span class="small text-muted">${label}</span>
                <input type="range" class="form-range w-50" min="${min}" max="${max}" step="${step}" value="${p[key]}">
                <span class="small fw-bold" style="width:25px; text-align:right;">${p[key]}</span>
            `;
            const range = div.querySelector("input");
            const valSpan = div.querySelectorAll("span")[1];

            range.oninput = (e) => {
                valSpan.innerText = e.target.value;
                p[key] = parseFloat(e.target.value);
                regenerateGeometry(obj);
            };
            // Save state on release
            range.onchange = () => saveState();
            container.appendChild(div);
        };

        // 1. CONE / PYRAMID CONTROLS
        if (p.type === 'cone') {
            container.innerHTML += `<div class="small fw-bold mb-1"><i class="bi bi-cone-striped"></i> Shape Settings</div>`;
            addSlider("Sides", "s", 3, 64, 1);     // 3=Pyramid, 64=Cone
            addSlider("Top Width", "rt", 0, 20, 1);// 0=Pointy, >0=Truncated
            addSlider("Base Width", "rb", 1, 30, 1);
        }

        // 2. CYLINDER / WEDGE CONTROLS
        else if (p.type === 'cylinder') {
            container.innerHTML += `<div class="small fw-bold mb-1"><i class="bi bi-database"></i> Shape Settings</div>`;
            addSlider("Sides", "s", 3, 64, 1); // 3=Wedge, 32=Cylinder
            addSlider("Top Width", "rt", 1, 30, 1);
            addSlider("Bot Width", "rb", 1, 30, 1);
        }

        // 3. TORUS CONTROLS
        else if (p.type === 'torus') {
            container.innerHTML += `<div class="small fw-bold mb-1"><i class="bi bi-circle-half"></i> Torus Settings</div>`;
            addSlider("Radius", "r", 1, 50, 0.5);
            addSlider("Tube", "t", 0.1, 10, 0.1);
            addSlider("Resolution", "tSeg", 3, 64, 1);
        }

        // 4. SPHERE CONTROLS
        else if (p.type === 'sphere') {
             container.innerHTML += `<div class="small fw-bold mb-1"><i class="bi bi-circle"></i> Sphere Settings</div>`;
             addSlider("Detail", "wSeg", 4, 64, 1); // Only scaling one param for simplicity
        }

        else {
             container.style.display = "none";
        }
    }

    window.dRot = () => { if (selectedObjects.length!==1) return; const o=selectedObjects[0]; o.rotation.set(document.getElementById("opt-rot-x").value*(Math.PI/180), document.getElementById("opt-rot-y").value*(Math.PI/180), document.getElementById("opt-rot-z").value*(Math.PI/180)); updateTinkerLabels(); saveState(); };
window.dSz = () => {
    if (selectedObjects.length !== 1) return;

    const obj = selectedObjects[0];

    // 1. Capture ALL values immediately (before the UI gets updated/reset)
    const vX = parseFloat(document.getElementById("opt-sz-x").value);
    const vY = parseFloat(document.getElementById("opt-sz-y").value);
    const vZ = parseFloat(document.getElementById("opt-sz-z").value);

    // 2. Apply them using the CAPTURED values
    // Even if resizeObject resets the text box, we already have the value stored in vY/vZ
    if(!isNaN(vX)) resizeObject(obj, 'x', vX);
    if(!isNaN(vY)) resizeObject(obj, 'y', vY);
    if(!isNaN(vZ)) resizeObject(obj, 'z', vZ);
};
    window.dDrop = function() { if (selectedObjects.length === 0) return alert("Select object."); selectedObjects.forEach(obj => { const box = new THREE.Box3().setFromObject(obj); obj.position.z -= box.min.z; }); updateTinkerLabels(); updateLiftConePos(); saveState(); };

    function selectObject(obj, multi = false) {
            if (!multi) {
                selectedObjects.forEach(o => { if(o.material) o.material.emissive.setHex(0); });
                selectedObjects = [];
                document.querySelectorAll(".object-list-item").forEach(el => el.classList.remove("selected"));
            }
            if (obj) {
                if (selectedObjects.includes(obj)) {
                    if (multi) { selectedObjects = selectedObjects.filter(o => o !== obj); if(obj.material) obj.material.emissive.setHex(0); }
                } else {
                    selectedObjects.push(obj);
                    if(obj.material && !obj.userData.isRuler) obj.material.emissive.setHex(MESH_HIGHLIGHT_COLOR);
                    if(obj.userData.name) { const el = document.getElementById(obj.uuid); if(el) el.classList.add("selected"); }
                }
            }

            // Handle Gizmo
            if (selectedObjects.length === 1) {
                tCtrl.attach(selectedObjects[0]);
                if(selectedObjects[0].userData.isRuler) tCtrl.setMode('translate');
                updateLiftConePos(); updateTinkerLabels();
            } else {
                tCtrl.detach();
                updateLiftConePos();
                activeLabels.forEach(l => scene.remove(l)); activeLabels.length = 0;
                while(schematicGroup.children.length > 0){ schematicGroup.remove(schematicGroup.children[0]); }
            }

            updatePropertiesPanel();
            updateObjectList();

            // --- CRITICAL UPDATE ---
            // Force a re-render so the gizmo disappears immediately
            window.requestRender();
        }

const updatePropertiesPanel = () => {
        const panel = document.getElementById("prop-panel");
        const container = document.getElementById("shape-params");

        if (selectedObjects.length === 1 && !selectedObjects[0].userData.isRuler) {
            panel.style.display = "block";

            // Auto-Expand Logic
            if (!tCtrl.dragging) {
                 panel.classList.remove('minimized');
                 const icon = document.getElementById('icon-panel-props');
                 if(icon) { icon.classList.remove('bi-chevron-up'); icon.classList.add('bi-chevron-down'); }
            }

            const n = selectedObjects[0];

            // 1. Standard Properties (Name, Type, Color)
            document.getElementById("opt-obj-name").value = n.userData.name;
            document.getElementById("opt-d-type").value = n.userData.isHole ? "hole" : "solid";
            if(n.material) updateColorPicker(n.material.color);

            // =========================================================
            // 2. SHAPE SPECIFIC UI (Text vs Standard) - MODIFIED SECTION
            // =========================================================
if (n.userData.geoParams && n.userData.geoParams.type === 'text') {
                container.innerHTML = "";
                container.style.display = "block";

                container.innerHTML += `
                    <div class="mb-2">
                        <label class="small fw-bold">Text Content</label>
                        <input type="text" class="form-control form-control-sm" value="${n.userData.geoParams.text}" id="prop-text-input">
                    </div>`;

                // Curvature Slider: Range -0.2 to 0.2 covers flat to Radius ~5
                container.innerHTML += `
                    <div class="d-flex justify-content-between align-items-center mb-1">
                        <span class="small text-muted">Bend (Auto)</span>
                        <input type="range" class="form-range w-50" min="-0.2" max="0.2" step="0.005" value="${n.userData.geoParams.bend}" id="prop-text-bend">
                    </div>`;
                container.innerHTML += `
                    <div class="d-grid gap-2 mt-2">
                        <button class="btn btn-sm btn-outline-primary" onclick="window.reSnapText()">
                            <i class="bi bi-arrow-repeat"></i> Auto-Wrap to Surface
                        </button>
                    </div>`;

                setTimeout(() => {
                    const txtIn = document.getElementById('prop-text-input');
                    const bendIn = document.getElementById('prop-text-bend');

                    if(txtIn) {
                        txtIn.onchange = (e) => {
                            n.userData.geoParams.text = e.target.value;
                            regenerateText(n);
                            saveState();
                        };
                    }
                    if(bendIn) {
                        bendIn.oninput = (e) => {
                            n.userData.geoParams.bend = parseFloat(e.target.value);
                            regenerateText(n);
                        };
                        bendIn.onchange = () => saveState();
                    }
                }, 0);
            } else {
                // B. IT IS NOT TEXT -> Use standard sliders (Cone, Cylinder, etc)
                updateParametricUI(n);
            }
            // =========================================================


            // 3. Add Chamfer / Smoothness Slider (Existing Logic)
            const isParametric = !!n.userData.geoParams;
            const isBox = isParametric && n.userData.geoParams.type === 'box';
            const isStraightExtrusion = isParametric &&
                (n.userData.geoParams.type === 'cylinder' || n.userData.geoParams.type === 'wedge') &&
                Math.abs(n.userData.geoParams.rt - n.userData.geoParams.rb) < 0.1;
            const isMerged = !isParametric;

            if (isBox || isStraightExtrusion || isMerged) {
                let currentVal = 0;
                if (isParametric) {
                    currentVal = n.userData.geoParams.r || n.userData.geoParams.chamfer || 0;
                } else {
                    currentVal = n.material.flatShading ? 0 : 1;
                }

                const maxVal = isParametric ? 5 : 1;
                const step = isParametric ? 0.1 : 1;
                const label = isParametric ? "Edge Rounding" : "Smooth Edges";

                const div = document.createElement("div");
                div.className = "d-flex justify-content-between align-items-center mb-1 mt-2 border-top pt-2";
                div.innerHTML = `
                    <span class="small fw-bold">${label}</span>
                    <input type="range" class="form-range w-50" min="0" max="${maxVal}" step="${step}" value="${currentVal}">
                `;

                div.querySelector("input").oninput = (e) => window.updateSmoothness(parseFloat(e.target.value));
                container.appendChild(div);
                container.style.display = "block";
            }

            // 4. Update Transform Inputs
            const box = new THREE.Box3().setFromObject(n);
            const size = box.getSize(new THREE.Vector3());

            document.getElementById("opt-sz-x").value = Math.round(size.x);
            document.getElementById("opt-sz-y").value = Math.round(size.y);
            document.getElementById("opt-sz-z").value = Math.round(size.z);

            const r = n.rotation;
            document.getElementById("opt-rot-x").value = Math.round(r.x * (180/Math.PI));
            document.getElementById("opt-rot-y").value = Math.round(r.y * (180/Math.PI));
            document.getElementById("opt-rot-z").value = Math.round(r.z * (180/Math.PI));

        } else {
            panel.style.display = "none";
        }
    };

    window.updateObjectName = e => { if(selectedObjects.length===1) { selectedObjects[0].userData.name = e; updateObjectList(); saveState(); } };
    window.dUpdMat = e => { const t = e==="hole"; selectedObjects.forEach(n => { n.userData.isHole = t; n.material.transparent = t; n.material.opacity = t ? 0.5 : 1; }); saveState(); };
    const buildColorPicker = () => { const e = ["#0d6efd", "#6c757d", "#198754", "#dc3545", "#ffc107", "#0dcaf0", "#212529", "#f8f9fa"]; document.getElementById("color-picker").innerHTML = e.map(c => `<div class="color-option" style="background:${c}" data-color="${c}" onclick="window.setObjectColor('${c}')"></div>`).join(''); };
    window.setObjectColor = c => { const col = new THREE.Color(c); selectedObjects.forEach(o => o.material.color = col); updateColorPicker(col); saveState(); };
    const updateColorPicker = e => { const t = e.getHexString().toLowerCase(); document.querySelectorAll(".color-option").forEach(el => el.classList.toggle("selected", el.dataset.color.includes(t))); };


    window.selectObject = (obj, multi = false) => {
        // 1. Clear previous selection if not multi-select
        if (!multi) {
            selectedObjects.forEach(o => { if(o.material) o.material.emissive.setHex(0); });
            selectedObjects = [];
            document.querySelectorAll(".object-list-item").forEach(el => el.classList.remove("selected"));
        }

        // 2. Add new object to selection
        if (obj) {
            if (selectedObjects.includes(obj)) {
                if (multi) {
                    // Toggle off if already selected
                    selectedObjects = selectedObjects.filter(o => o !== obj);
                    if(obj.material) obj.material.emissive.setHex(0);
                }
            } else {
                selectedObjects.push(obj);
                // Highlight
                if(obj.material && !obj.userData.isRuler) obj.material.emissive.setHex(MESH_HIGHLIGHT_COLOR);
                // Highlight in list
                if(obj.userData.name) {
                    const el = document.getElementById(obj.uuid);
                    if(el) el.classList.add("selected");
                }
            }
        }

        // 3. Attach/Detach Gizmo (TransformControls)
        if (selectedObjects.length === 1) {
            tCtrl.attach(selectedObjects[0]);
            // If selecting the ruler, default to move mode
            if(selectedObjects[0].userData.isRuler) tCtrl.setMode('translate');

            updateLiftConePos();
            updateTinkerLabels();
        } else {
            tCtrl.detach();
            updateLiftConePos();
            // Clear dimensions labels
            activeLabels.forEach(l => scene.remove(l));
            activeLabels.length = 0;
            while(schematicGroup.children.length > 0){ schematicGroup.remove(schematicGroup.children[0]); }
        }

        // 4. Update UI
        updatePropertiesPanel();
        updateObjectList();

        // 5. Force Render (Important for responsiveness)
        window.requestRender();
    };
// --- LIST INTERACTION FUNCTIONS ---

    // This function needs to be explicitly attached to 'window' so the HTML onclick can access it.
    window.selectObjectFromList = (uuid) => {
        const t = scene.getObjectByProperty("uuid", uuid);
        if(t) window.selectObject(t); // Also ensure selectObject is called with window prefix
    };

    // This one you already have correctly prefixed
    window.toggleMergeStatus = uuid => {
        const t = scene.getObjectByProperty("uuid", uuid);
        if(t) {
            t.userData.markForMerge = !t.userData.markForMerge;
            updateMergeButton();
        }
    };

    const updateObjectList = () => {
        const list = document.getElementById("object-list"); list.innerHTML = "";
        scene.children.filter(e => e.userData.name).forEach(t => {
            const li = document.createElement("li"); li.className = `object-list-item ${selectedObjects.includes(t)?'selected':''}`;
            // This is where you call the window-prefixed function
            li.onclick = () => window.selectObjectFromList(t.uuid);
            li.innerHTML = `<input type="checkbox" class="form-check-input me-2" ${t.userData.markForMerge?'checked':''} onclick="event.stopPropagation(); window.toggleMergeStatus('${t.uuid}')"> <span>${t.userData.name}</span>`;
            list.appendChild(li);
        });
        updateMergeButton();

        // Toggle Unmerge Button
        const unmergeBtn = document.getElementById('unmerge-btn');
        if (selectedObjects.length === 1 && selectedObjects[0].userData.mergeHistory) {
            unmergeBtn.style.display = 'inline-block';
        } else {
            unmergeBtn.style.display = 'none';
        }
    };

    const updateMergeButton = () => {
        document.getElementById("merge-btn").innerText = `Merge (${scene.children.filter(e => e.userData.markForMerge).length})`;
    };
function cleanObject(obj) {
        if (!obj) return;

        // Dispose Geometry
        if (obj.geometry) obj.geometry.dispose();

        // Dispose Material
        if (obj.material) {
            // Handle array of materials
            if (Array.isArray(obj.material)) {
                obj.material.forEach(m => m.dispose());
            } else {
                obj.material.dispose();
            }
        }

        // Recursively clean children
        if (obj.children) {
            obj.children.forEach(c => cleanObject(c));
        }
    }

    window.dDel = () => {
        selectedObjects.forEach(e => {
            scene.remove(e);
            cleanObject(e); // <--- CLEAN GPU MEMORY
        });
        selectObject(null);
        updateObjectList();
        saveState();
        window.requestRender(); // Request frame update
    };

    window.dDelAll = () => {
        const toRemove = scene.children.filter(e => e.isMesh && !e.userData.isRuler && e !== liftCone);
        toRemove.forEach(e => {
            scene.remove(e);
            cleanObject(e); // <--- CLEAN GPU MEMORY
        });
        selectObject(null);
        updateObjectList();
        saveState();
        window.requestRender();
    };
    window.dDuplicate = () => {
        let targets = selectedObjects.length > 0 ? selectedObjects : scene.children.filter(e => e.userData.markForMerge && e.isMesh);
        if(!targets.length) return alert("Select object(s).");
        const newSel = [];
        targets.forEach(obj => {
            const clone = obj.clone();
            if(clone.material) clone.material = obj.material.clone();
            clone.material.emissive.setHex(0);
            clone.position.add(new THREE.Vector3(10, 0, 0));
            clone.userData = JSON.parse(JSON.stringify(obj.userData));
            clone.userData.name = obj.userData.name + " (Copy)";
            clone.userData.markForMerge = false;
            // Clear history on copy to avoid giant files? No, keep it so copies are editable
            // clone.userData.mergeHistory = undefined;
            scene.add(clone); newSel.push(clone);
        });
        selectObject(null); newSel.forEach(o=>selectObject(o, true)); saveState();
    };

    // --- REVISED MERGE LOGIC WITH HISTORY ---
window.dMerge = () => {
        const marked = selectedObjects.length > 1 ? selectedObjects : scene.children.filter(e => e.userData.markForMerge && e.isMesh && !e.userData.isRuler);
        if (marked.length < 2) return alert("Check 2+ boxes or Select 2+ objects.");
        const solids = marked.filter(e => !e.userData.isHole);
        if (!solids.length) return alert("Need 1 solid.");

        // 1. Serialize Ingredients (SAFE MODE)
        // We must apply the same "Swap to Box" logic here, or unmerging will crash
        const historyData = marked.map(obj => {
            if (obj.userData.geoParams && obj.userData.geoParams.type === 'text') {
                const clone = obj.clone();
                clone.geometry = new THREE.BoxGeometry(1, 1, 1);
                return clone.toJSON();
            }
            return obj.toJSON();
        });

        const ev = new Evaluator();
        const brush = mesh => {
            const b = new Brush(prepareCSG(mesh.geometry));
            b.position.copy(mesh.position); b.rotation.copy(mesh.rotation); b.scale.copy(mesh.scale);
            b.updateMatrixWorld(); return b;
        };
        let res = brush(solids[0]);
        for (let i = 1; i < solids.length; i++) res = ev.evaluate(res, brush(solids[i]), ADDITION);
        marked.filter(e => e.userData.isHole).forEach(h => res = ev.evaluate(res, brush(h), SUBTRACTION));

        const geo = res.geometry; geo.computeBoundingBox(); const c = geo.boundingBox.getCenter(new THREE.Vector3()); geo.translate(-c.x, -c.y, -c.z);

        const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: 0x0d6efd }));
        mesh.position.copy(c);

        // 2. Store Ingredients in UserData
        mesh.userData = {
            name: "Merged Part",
            isHole: false,
            mergeHistory: historyData
        };

        // Remove old objects
        marked.forEach(e => scene.remove(e));
        scene.add(mesh);
        selectObject(mesh);
        saveState();
    };

    // --- NEW UNMERGE LOGIC ---
window.dUnmerge = () => {
        if (selectedObjects.length !== 1) return;
        const obj = selectedObjects[0];

        if (!obj.userData.mergeHistory) return alert("This object has no merge history.");

        const loader = new THREE.ObjectLoader();
        const newObjects = [];

        obj.userData.mergeHistory.forEach(jsonData => {
            const restoredMesh = loader.parse(jsonData);

            // FIX: Ensure boolean value for transparency
            const isHole = !!restoredMesh.userData.isHole;

            restoredMesh.material = new THREE.MeshStandardMaterial({
                color: restoredMesh.material.color,
                roughness: 0.4, metalness: 0.2,
                transparent: isHole,
                opacity: isHole ? 0.5 : 1.0,
                wireframe: appSettings.wireframe
            });

            if (restoredMesh.userData.geoParams) {
                if (restoredMesh.userData.geoParams.type === 'text') {
                    regenerateText(restoredMesh);
                } else {
                    regenerateGeometry(restoredMesh);
                }
            }

            scene.add(restoredMesh);
            newObjects.push(restoredMesh);
        });

        scene.remove(obj);
        cleanObject(obj);

        selectObject(null);
        newObjects.forEach(o => selectObject(o, true));
        saveState();
    };

window.dShell = () => {
        if (selectedObjects.length !== 1) return alert("Select exactly 1 object.");

        const obj = selectedObjects[0];

        // 1. Get LOCAL Geometry Bounds
        // We measure the raw geometry to ensure rotation doesn't confuse the math
        if (!obj.geometry.boundingBox) obj.geometry.computeBoundingBox();
        const gBox = obj.geometry.boundingBox;

        // 2. Calculate True Local Dimensions (Geometry Size * Current Scale)
        const dimX = (gBox.max.x - gBox.min.x) * obj.scale.x;
        const dimY = (gBox.max.y - gBox.min.y) * obj.scale.y;
        const dimZ = (gBox.max.z - gBox.min.z) * obj.scale.z;

        const minDim = Math.min(dimX, dimY);

        // 3. User Input
        const input = prompt(`Object Base: ${Math.round(dimX)}x${Math.round(dimY)}mm.\nWall Thickness (mm):`, "2");
        if (input === null) return;
        const mm = parseFloat(input);

        // Safety Checks
        if (isNaN(mm) || mm <= 0) return alert("Invalid thickness.");
        if (mm * 2 >= minDim) return alert(`Too thick! Max thickness is ${(minDim/2) - 0.1}mm`);

        const isTube = confirm("Make it a Tube (Open Ends)?\n\nOK = Yes (Tube)\nCancel = No (Hollow Inside)");

        // 4. Calculate Shrink Ratios (TargetSize / CurrentSize)
        const ratX = (dimX - (mm * 2)) / dimX;
        const ratY = (dimY - (mm * 2)) / dimY;

        // 5. Z-Axis Logic (The Fix)
        let ratZ;
        if (isTube) {
            // TUBE MODE:
            // Instead of stretching by 20% (which ruins cones/pyramids),
            // we add just 1mm extra height (0.5mm sticking out top/bottom).
            // This ensures it cuts open the ends without destroying the side wall slope.
            ratZ = (dimZ + 1.0) / dimZ;
        } else {
            // HOLLOW MODE:
            // Shrink Z to keep the top and bottom closed
            ratZ = (dimZ - (mm * 2)) / dimZ;
        }

        // 6. Prepare CSG
        const ev = new Evaluator();

        // Outer Brush
        const bOut = new Brush(prepareCSG(obj.geometry));
        bOut.position.copy(obj.position);
        bOut.rotation.copy(obj.rotation);
        bOut.scale.copy(obj.scale);
        bOut.updateMatrixWorld();

        // Inner Brush
        const bIn = new Brush(prepareCSG(obj.geometry));
        bIn.position.copy(obj.position);
        bIn.rotation.copy(obj.rotation);

        // Apply calculated scales
        bIn.scale.set(
            obj.scale.x * ratX,
            obj.scale.y * ratY,
            obj.scale.z * ratZ
        );
        bIn.updateMatrixWorld();

        // 7. Center Fix
        // Ensure the inner shape cuts exactly from the volumetric center
        const boxOut = new THREE.Box3().setFromObject(bOut);
        const boxIn = new THREE.Box3().setFromObject(bIn);
        const centerOut = boxOut.getCenter(new THREE.Vector3());
        const centerIn = boxIn.getCenter(new THREE.Vector3());

        const shift = new THREE.Vector3().subVectors(centerOut, centerIn);
        bIn.position.add(shift);
        bIn.updateMatrixWorld();

        // 8. Boolean Subtract
        let result = ev.evaluate(bOut, bIn, SUBTRACTION);

        // 9. Build Result
        const newMesh = new THREE.Mesh(
            result.geometry,
            obj.material.clone()
        );

        newMesh.position.set(0,0,0);
        newMesh.rotation.set(0,0,0);
        newMesh.scale.set(1,1,1);

        newMesh.castShadow = true;
        newMesh.receiveShadow = true;

        newMesh.userData = {
            ...obj.userData,
            name: obj.userData.name + (isTube ? " (Tube)" : " (Shell)"),
            geoParams: null // Shape is no longer parametric
        };

        scene.remove(obj);
        scene.add(newMesh);
        selectObject(newMesh);
        saveState();
    };

window.toggleRulerMode = () => {
    // Toggle State
    rulerMode = (rulerMode === 'endpoint') ? 'midpoint' : 'endpoint';

    // Update UI Button
    const btn = document.getElementById('btn-ruler-mode');
    const icon = btn.querySelector('i');

    if(rulerMode === 'midpoint') {
        btn.title = "Mode: Midpoint";
        icon.className = "bi bi-align-center"; // Bootstrap icon for center
        btn.classList.add("text-primary");
    } else {
        btn.title = "Mode: Endpoint";
        icon.className = "bi bi-arrows-collapse"; // Bootstrap icon for edges
        btn.classList.remove("text-primary");
    }

    // Refresh View
    updateTinkerLabels();
    window.requestRender();
};
// --- UPDATED LOFT FUNCTION ---
    window.dLoft = () => {
        // 1. STANDARD LOFT (Between 2+ whole objects)
        if (selectedObjects.length >= 2) {
            const points = [];
            selectedObjects.forEach(obj => {
                obj.updateMatrixWorld();
                const posAttr = obj.geometry.attributes.position;
                for(let i=0; i < posAttr.count; i++){
                    const vec = new THREE.Vector3().fromBufferAttribute(posAttr, i).applyMatrix4(obj.matrixWorld);
                    points.push(vec);
                }
            });

            if(points.length < 4) return alert("Not enough points to generate a solid.");

            // Calculate Center to normalize coordinates (helps accuracy)
            const centerBox = new THREE.Box3().setFromPoints(points);
            const center = centerBox.getCenter(new THREE.Vector3());
            const localPoints = points.map(p => p.clone().sub(center));

            // Generate Hull
            let geo = new ConvexGeometry(localPoints);

            // --- CRITICAL FIX FOR TUBE/SHELL ---
            // 1. Merge vertices to make it watertight (CSG requires this)
            geo = mergeVertices(geo, 0.001);
            // 2. Recompute normals for smooth shading and correct inside/outside detection
            geo.computeVertexNormals();
            // ------------------------------------

            const material = new THREE.MeshStandardMaterial({
                color: 0x0d6efd,
                roughness: 0.4,
                metalness: 0.2,
                wireframe: appSettings.wireframe
            });

            const mesh = new THREE.Mesh(geo, material);
            mesh.position.copy(center);
            mesh.userData = { isHole: false, name: "Loft Object" };

            // Ensure shadow capability
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            scene.add(mesh);
            selectObject(mesh);
            updateObjectList();
            saveState();
            return;
        }

        // 2. FACE LOFT MODE (Specific faces)
        if (!isFaceLoftMode) {
            // Enter Face Selection Mode
            isFaceLoftMode = true;
            selectObject(null);
            document.body.style.cursor = "crosshair";

            // Highlight button
            const btn = document.querySelector('button[onclick="window.dLoft()"]');
            if(btn) btn.classList.add('active-tool');

            // Notification
            const status = document.getElementById("auto-save-status");
            status.innerText = "Select 2 Faces, then click Loft again";
            status.style.opacity = 1;

        } else {
            // Execute Loft
            if (selectedFacesData.length < 2) {
                alert("Please select at least 2 faces to connect.");
                return;
            }

            let allPoints = [];
            selectedFacesData.forEach(data => allPoints.push(...data.points));

            try {
                // Center calculations
                const centerBox = new THREE.Box3().setFromPoints(allPoints);
                const center = centerBox.getCenter(new THREE.Vector3());
                const localPoints = allPoints.map(p => p.clone().sub(center));

                let geo = new ConvexGeometry(localPoints);

                // --- CRITICAL FIX FOR TUBE/SHELL ---
                // ConvexGeometry creates flat shading with split vertices.
                // We must merge them to allow the Shell algorithm to work.
                geo.deleteAttribute('normal'); // Remove old flat normals
                geo.deleteAttribute('uv');     // Remove bad UVs

                geo = mergeVertices(geo, 0.001); // Weld vertices
                geo.computeVertexNormals();      // Smooth normals
                // ------------------------------------

                // Add basic UVs so textures don't crash
                if (!geo.attributes.uv) {
                    const count = geo.attributes.position.count;
                    geo.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(count * 2), 2));
                }

                const material = new THREE.MeshStandardMaterial({
                    color: 0x0d6efd,
                    roughness: 0.4,
                    metalness: 0.2,
                    wireframe: appSettings.wireframe
                });

                const mesh = new THREE.Mesh(geo, material);
                mesh.position.copy(center);
                mesh.userData = { isHole: false, name: "Face Loft" };

                mesh.castShadow = true;
                mesh.receiveShadow = true;

                scene.add(mesh);
                selectObject(mesh);
                updateObjectList();

            } catch (e) {
                console.error(e);
                alert("Could not generate geometry. Try faces that face each other.");
            }

            // Cleanup Mode
            isFaceLoftMode = false;
            selectedFacesData = [];
            while(faceMarkerGroup.children.length > 0){
                faceMarkerGroup.remove(faceMarkerGroup.children[0]);
            }
            document.body.style.cursor = "default";
            const btn = document.querySelector('button[onclick="window.dLoft()"]');
            if(btn) btn.classList.remove('active-tool');

            const status = document.getElementById("auto-save-status");
            status.innerText = "Saved";
            status.style.opacity = 0;

            saveState();
        }
    };

window.dImportFile = function(input) {
        if (!input.files || input.files.length === 0) return;

        const files = Array.from(input.files);
        const fileMap = {};

        // 1. Create Blob URLs for every file and map them by name
        files.forEach(f => {
            fileMap[f.name] = URL.createObjectURL(f);
        });

        // 2. Setup the Loading Manager to redirect network requests to our Blobs
        const manager = new THREE.LoadingManager();
        manager.setURLModifier((url) => {
            // If Three.js asks for "folder/texture.jpg", we strip path and look for "texture.jpg" in our list
            const fileName = url.replace(/^.*[\\\/]/, '');
            return fileMap[fileName] || url;
        });

        // 3. Helper for Scaling (Same as before)
        const checkAndFixScale = (geometry) => {
            geometry.computeBoundingBox();
            const size = new THREE.Vector3();
            geometry.boundingBox.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            if (maxDim < 2.0 && maxDim > 0.0001) {
                console.log("Detected AR Scale. Fixing...");
                geometry.scale(1000, 1000, 1000);
            }
            return geometry;
        };

        // 4. Find the Main Model File
        const mainFile = files.find(f => /\.(obj|stl|gltf|glb|usdz)$/i.test(f.name));
        if (!mainFile) return alert("No model file (.obj, .stl, .glb) found in selection.");

        const ext = mainFile.name.split('.').pop().toLowerCase();
        const url = fileMap[mainFile.name]; // Get the blob URL for the main file

        // 5. Load based on extension
        if (ext === 'obj') {
            // Check if there is a matching MTL file in the selection
            const mtlFile = files.find(f => f.name.endsWith('.mtl'));

            const loadObj = (materials = null) => {
                const loader = new OBJLoader(manager);
                if(materials) {
                    loader.setMaterials(materials);
                }
                loader.load(url, (objGroup) => {
                    objGroup.traverse(child => {
                        if (child.isMesh) buildAndAddMesh(checkAndFixScale(child.geometry), mainFile.name, null, child.material);
                    });
                });
            };

            if (mtlFile) {
                // Load MTL first, then OBJ
                const mtlLoader = new MTLLoader(manager);
                mtlLoader.load(fileMap[mtlFile.name], (materials) => {
                    materials.preload();
                    loadObj(materials);
                });
            } else {
                // Just load OBJ
                loadObj();
            }
        }
        else if (ext === 'stl') {
            new STLLoader(manager).load(url, (geo) => {
                buildAndAddMesh(checkAndFixScale(geo), mainFile.name, null, null);
            });
        }
        else if (ext === 'gltf' || ext === 'glb') {
            new GLTFLoader(manager).load(url, (gltf) => {
                gltf.scene.traverse(child => {
                    if (child.isMesh) buildAndAddMesh(checkAndFixScale(child.geometry), mainFile.name, null, child.material);
                });
            });
        }
        else if (ext === 'usdz') {
            // USDZ usually self-contained, logic remains similar but uses the Blob URL
            // Note: USDZLoader doesn't fully support LoadingManager in all versions,
            // but usually works fine for textures embedded in the archive.
            const reader = new FileReader();
            reader.onload = (e) => {
                const group = new USDZLoader().parse(e.target.result);
                group.traverse(child => {
                    if (child.isMesh) buildAndAddMesh(checkAndFixScale(child.geometry), mainFile.name, null, child.material);
                });
            };
            reader.readAsArrayBuffer(mainFile);
        }

        // Cleanup: Reset input so you can select the same file again
        input.value = '';
    };

    window.triggerExport = () => window.downloadExport(document.getElementById("export-format").value);

    window.downloadExport = async fmt => {
            // 0. Project File Export
            if (fmt === 'json') {
                const rawData = createSnapshot(); // This is the compressed state
                // We download it as a raw file
                const blob = new Blob([rawData], { type: "application/octet-stream" });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = (document.getElementById("d-name").value || "Project") + ".tinker";
                a.click();
                return;
            }

            // 1. Collect Objects
            const l = selectedObjects.length ? selectedObjects : scene.children.filter(c => c.isMesh && !c.userData.isRuler && c !== liftCone && c.parent !== faceMarkerGroup);
            if(!l.length) return alert("Nothing to export");

            const g = new THREE.Group();
            l.forEach(o => g.add(o.clone()));

            // --- AR SCALE LOGIC ---
            // Scale GLB and USDZ to Meters (0.001).
            // Keep STL, OBJ, and standard GLTF in Millimeters (1.0).
            if (fmt === 'usdz' || fmt === 'glb') {
                g.scale.set(0.001, 0.001, 0.001);
                g.updateMatrixWorld(true);
            }
            // ----------------------

            const name = (document.getElementById("d-name").value || "Design") + "." + fmt;
            const saveData = (b,n) => { const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download=n; a.click(); };

            if(fmt==='stl') saveData(new Blob([new STLExporter().parse(g, {binary:true})]), name);
            if(fmt==='obj') saveData(new Blob([new OBJExporter().parse(g)]), name);

            // GLTF (Text based JSON)
            if(fmt==='gltf') new GLTFExporter().parse(g, r=>saveData(new Blob([JSON.stringify(r)]), name));

            // GLB (Binary) - THE FIX IS HERE
            // Note the 3rd argument is an error handler, 4th is options
            if(fmt==='glb') {
                new GLTFExporter().parse(
                    g,
                    r => saveData(new Blob([r]), name),
                    (err) => console.error(err),
                    { binary: true }
                );
            }

            if(fmt==='usdz') { const e = new USDZExporter(); const u = await e.parse(g, { quickLookAR: true }); saveData(new Blob([u], { type: 'model/vnd.usdz+zip' }), name); }
        };

    // --- NEW: PROJECT LOADING ---
    window.loadProjectFile = function(input) {
        if (!input.files || input.files.length === 0) return;
        const file = input.files[0];

        const reader = new FileReader();
        reader.onload = function(e) {
            const buffer = new Uint8Array(e.target.result);
            try {
                loadSnapshot(buffer);
                // Reset history stack
                historyStack = [buffer];
                historyStep = 0;
                saveState();
                alert("Project Loaded Successfully!");
            } catch (err) {
                console.error(err);
                alert("Failed to load project file.");
            }
        };
        reader.readAsArrayBuffer(file);
        input.value = '';
    };

    function createRuler() {
        if(rulerGroup) scene.remove(rulerGroup);
        rulerGroup = new THREE.Group();
        rulerGroup.userData = { isRuler: true };

        // The L-Shape axes
        const len = 100;
        const matMain = new THREE.LineBasicMaterial({ color: 0x444444, linewidth: 2 });

        // X Axis line
        const xPts = [new THREE.Vector3(0,0,0), new THREE.Vector3(len,0,0)];
        rulerGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(xPts), matMain));

        // Y Axis line
        const yPts = [new THREE.Vector3(0,0,0), new THREE.Vector3(0,len,0)];
        rulerGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(yPts), matMain));

        // Ticks
        const matTick = new THREE.LineBasicMaterial({ color: 0x888888, transparent:true, opacity:0.5 });
        const ticksPts = [];
        for(let i=0; i<=len; i+=10) {
            // X-Axis Ticks
            ticksPts.push(new THREE.Vector3(i, 0, 0), new THREE.Vector3(i, -2, 0));
            // Y-Axis Ticks
            ticksPts.push(new THREE.Vector3(0, i, 0), new THREE.Vector3(-2, i, 0));
        }
        rulerGroup.add(new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(ticksPts), matTick));

        // Default Position (Bottom Left area)
        rulerGroup.position.set(-50, -50, 0.1);
        rulerGroup.visible = showRuler; // Sync with state
        scene.add(rulerGroup);
    }

    function updateLiftConePos() { if(selectedObjects.length===1 && !selectedObjects[0].userData.isRuler) { const b=new THREE.Box3().setFromObject(selectedObjects[0]); liftCone.position.set((b.min.x+b.max.x)/2, (b.min.y+b.max.y)/2, b.max.z+50); liftCone.visible=true; } else liftCone.visible=false; }
    function createLiftCone() { const g=new THREE.ConeGeometry(3,6,16); g.rotateX(Math.PI/2); liftCone=new THREE.Mesh(g,new THREE.MeshBasicMaterial({color:0x222222,transparent:true,opacity:0.8})); liftCone.visible=false; scene.add(liftCone); }
    function createRotationLabel() { rotLabelDiv=document.createElement('div'); rotLabelDiv.className='rot-label'; rotLabelObj=new CSS2DObject(rotLabelDiv); scene.add(rotLabelObj); }
    function updateRotationFeedback() { if(selectedObjects.length===1 && tCtrl.mode==='rotate' && tCtrl.dragging) { const r=selectedObjects[0].rotation; rotLabelDiv.innerText=`X:${Math.round(r.x*57.3)} Y:${Math.round(r.y*57.3)} Z:${Math.round(r.z*57.3)}`; rotLabelDiv.style.visibility='visible'; rotLabelObj.position.copy(selectedObjects[0].position); } else rotLabelDiv.style.visibility='hidden'; }

    // --- UNDO / REDO / SAVE SYSTEM ---

function createSnapshot() {
        const l = [];
        scene.children.forEach(c => {
            // FIX: Added !c.userData.isGhost so we don't save the placement tool
            if (c.isMesh && !c.userData.isRuler && c !== liftCone && c.userData.name !== "FaceMarker" && !c.userData.isGhost) {
                l.push(c);
            }
        });

        const d = { metadata: { type: 'Save' }, scene: new THREE.Scene().toJSON() };

        const childrenJSON = l.map(c => {
            // Swap Text for Box during save to prevent crash
            if (c.userData.geoParams && c.userData.geoParams.type === 'text') {
                const clone = c.clone();
                clone.geometry = new THREE.BoxGeometry(1, 1, 1);
                return clone.toJSON();
            }
            return c.toJSON();
        });

        d.scene.object = { children: childrenJSON };
        const jsonStr = JSON.stringify(d);

        const encoder = new TextEncoder();
        const data = encoder.encode(jsonStr);

        if (zstdReady) {
            return compress(data, 10);
        } else {
            return data;
        }
    }

function saveState() {
        // 1. Always update view when state changes (Fixes UI lag)
        window.requestRender();

        // 2. Stop immediately if we already know storage is full
        if (isStorageFull) {
            const status = document.getElementById("auto-save-status");
            status.innerText = "Storage Full - Auto-save Disabled";
            status.style.opacity = 1;
            status.style.background = "rgba(255, 0, 0, 0.6)"; // Red alert
            return;
        }

        if(!isUndoRedoAction) {
            if (historyStep < historyStack.length - 1) {
                historyStack = historyStack.slice(0, historyStep + 1);
            }
            const snapshot = createSnapshot();
            historyStack.push(snapshot);
            if(historyStack.length > MAX_HISTORY) { historyStack.shift(); } else { historyStep++; }
        }

        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(()=>{
            // Double check flag inside timeout
            if (isStorageFull) return;

            const currentSnapshot = historyStack[historyStep];
            if(!currentSnapshot) return;

            const b64 = uint8ToBase64(currentSnapshot);

            try {
                // TRY TO SAVE
                localStorage.setItem("3d_save", b64);

                // If successful:
                const el = document.getElementById("auto-save-status");
                el.innerText = "Saved";
                el.style.background = "rgba(0,0,0,0.6)";
                el.style.opacity = 1;
                setTimeout(()=>el.style.opacity=0, 2000);
                window.updateStorageUI();

            } catch (e) {
                // CATCH QUOTA ERROR
                if (e.name === 'QuotaExceededError' || e.code === 22) {
                    console.warn("Local Storage Full! Disabling Auto-save.");
                    isStorageFull = true; // <--- Disable future attempts

                    const el = document.getElementById("auto-save-status");
                    el.innerText = "Scene too big to Auto-save";
                    el.style.background = "rgba(220, 53, 69, 0.8)"; // Red
                    el.style.opacity = 1;
                    // Don't fade out immediately so user sees it
                    setTimeout(()=>el.style.opacity=0, 5000);

                    window.updateStorageUI(); // Update bar to show full
                }
            }
        }, 1000);
    }

function loadSnapshot(compressedData) {
        if (!compressedData) return;

        let jsonStr;
        if (zstdReady) {
            try {
                const decompressed = decompress(compressedData);
                const decoder = new TextDecoder();
                jsonStr = decoder.decode(decompressed);
            } catch (e) {
                try {
                    const decoder = new TextDecoder();
                    jsonStr = decoder.decode(compressedData);
                    JSON.parse(jsonStr);
                } catch (e2) {
                    console.error("Decompression failed", e);
                    return;
                }
            }
        } else {
            const decoder = new TextDecoder();
            jsonStr = decoder.decode(compressedData);
        }

        let data;
        try { data = JSON.parse(jsonStr); } catch (e) { return; }

        selectObject(null);
        scene.children.filter(c => c.isMesh && !c.userData.isRuler && c !== liftCone).forEach(c => scene.remove(c));

        const loader = new THREE.ObjectLoader();

        if (data.scene && data.scene.object && data.scene.object.children) {
            data.scene.object.children.forEach(childData => {
                try {
                    // Check if this is a ghost data before even parsing
                    if(childData.userData && childData.userData.isGhost) return;

                    const mesh = loader.parse(childData);

                    if (mesh.isMesh) {
                        // FIX: Ensure transparent is strictly true/false
                        const isHole = !!mesh.userData.isHole;

                        mesh.material = new THREE.MeshStandardMaterial({
                            color: mesh.material.color,
                            roughness: 0.5, metalness: 0.1,
                            transparent: isHole,
                            opacity: isHole ? 0.5 : 1,
                            wireframe: appSettings.wireframe
                        });

                        if (mesh.userData.geoParams && mesh.userData.geoParams.type === 'text') {
                            regenerateText(mesh);
                        }
                        else if (mesh.userData.geoParams) {
                            regenerateGeometry(mesh);
                        }

                        scene.add(mesh);
                    }
                } catch (err) {
                    console.warn("Skipping corrupted object:", err);
                }
            });
        }
        updateObjectList();
        window.requestRender();
    }

    // --- FIX: Robust Load Logic ---
    function loadFromStorage() {
        const rawData = localStorage.getItem("3d_save");
        if (!rawData) {
            // First time run
            window.dAdd('cube');
            return;
        }

        try {
            // 1. Try treating it as the NEW format (Base64 -> Binary -> Zstd)
            // base64ToUint8 throws immediately if string has invalid chars (like old JSON)
            const u8 = base64ToUint8(rawData);
            historyStack.push(u8);
            historyStep = 0;
            loadSnapshot(u8);
        } catch (e) {
            console.warn("Could not load as Zstd/Base64. Trying legacy JSON...", e);

            // 2. Fallback: Treat as OLD format (Plain JSON string)
            try {
                const legacyData = JSON.parse(rawData);
                // Convert to new format immediately so Undo stack works
                const jsonStr = JSON.stringify(legacyData);
                const encoder = new TextEncoder();
                const bytes = encoder.encode(jsonStr);

                // Compress if Zstd is ready, else use raw bytes
                const compressed = zstdReady ? compress(bytes, 10) : bytes;

                historyStack.push(compressed);
                historyStep = 0;

                // Load using the new binary data we just created
                loadSnapshot(compressed);

            } catch (jsonErr) {
                console.error("Total load failure. Clearing storage.", jsonErr);
                localStorage.removeItem("3d_save");
                window.dAdd('cube');
            }
        }
    }

    window.undo = () => {
        if(historyStep > 0) {
            isUndoRedoAction = true;
            historyStep--;
            loadSnapshot(historyStack[historyStep]);
            isUndoRedoAction = false;
            saveState();
        }
    };

    window.redo = () => {
        if(historyStep < historyStack.length - 1) {
            isUndoRedoAction = true;
            historyStep++;
            loadSnapshot(historyStack[historyStep]);
            isUndoRedoAction = false;
            saveState();
        }
    };
    window.toggleRuler = () => {
        showRuler = !showRuler;

        // Toggle Visuals
        if(rulerGroup) rulerGroup.visible = showRuler;

        // Toggle UI Button State
        const btn = document.getElementById('btn-ruler');
        if(btn) {
            if(showRuler) {
                btn.classList.remove('btn-outline-dark');
                btn.classList.add('btn-primary');
            } else {
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-outline-dark');
            }
        }

        // Update labels immediately
        updateTinkerLabels();
    };

    // Initialize
    init3D();

</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
